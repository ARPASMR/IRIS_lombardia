--
-- PostgreSQL database dump
--

-- Dumped from database version 9.3.15
-- Dumped by pg_dump version 9.5.1

-- Started on 2018-02-28 12:16:59

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

DROP DATABASE iris_base;
--
-- TOC entry 4996 (class 1262 OID 29746)
-- Name: iris_base; Type: DATABASE; Schema: -; Owner: postgres
--

CREATE DATABASE iris_base WITH TEMPLATE = template0 ENCODING = 'UTF8' LC_COLLATE = 'it_IT.UTF-8' LC_CTYPE = 'it_IT.UTF-8';


ALTER DATABASE iris_base OWNER TO postgres;

\connect iris_base

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 4997 (class 1262 OID 29746)
-- Dependencies: 4996
-- Name: iris_base; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON DATABASE iris_base IS 'configurazione minima per un sistema webgis generico';


--
-- TOC entry 8 (class 2615 OID 31234)
-- Name: config; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA config;


ALTER SCHEMA config OWNER TO postgres;

--
-- TOC entry 4998 (class 0 OID 0)
-- Dependencies: 8
-- Name: SCHEMA config; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA config IS 'schema con tabelle di configurazione dei sistemi WebGis';


--
-- TOC entry 9 (class 2615 OID 31235)
-- Name: dati_di_base; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA dati_di_base;


ALTER SCHEMA dati_di_base OWNER TO postgres;

--
-- TOC entry 5000 (class 0 OID 0)
-- Dependencies: 9
-- Name: SCHEMA dati_di_base; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA dati_di_base IS 'Dati di base comuni ai servizi';


--
-- TOC entry 10 (class 2615 OID 2200)
-- Name: public; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA public;


ALTER SCHEMA public OWNER TO postgres;

--
-- TOC entry 5002 (class 0 OID 0)
-- Dependencies: 10
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA public IS 'standard public schema';


--
-- TOC entry 11 (class 2615 OID 31236)
-- Name: realtime; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA realtime;


ALTER SCHEMA realtime OWNER TO postgres;

--
-- TOC entry 5004 (class 0 OID 0)
-- Dependencies: 11
-- Name: SCHEMA realtime; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA realtime IS 'Realtime con i dati dell''ultimo anno';


--
-- TOC entry 7 (class 2615 OID 31076)
-- Name: topology; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA topology;


ALTER SCHEMA topology OWNER TO postgres;

--
-- TOC entry 12 (class 2615 OID 31237)
-- Name: warning; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA warning;


ALTER SCHEMA warning OWNER TO postgres;

--
-- TOC entry 5006 (class 0 OID 0)
-- Dependencies: 12
-- Name: SCHEMA warning; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA warning IS 'Tabelle per il sistema di warning - mail e webgis';


--
-- TOC entry 1 (class 3079 OID 12671)
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- TOC entry 5008 (class 0 OID 0)
-- Dependencies: 1
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

--
-- TOC entry 322 (class 1255 OID 29747)
-- Name: plr_call_handler(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_call_handler() RETURNS language_handler
    LANGUAGE c
    AS '$libdir/plr', 'plr_call_handler';


ALTER FUNCTION public.plr_call_handler() OWNER TO postgres;

--
-- TOC entry 2289 (class 2612 OID 29748)
-- Name: plr; Type: PROCEDURAL LANGUAGE; Schema: public; Owner: postgres
--

CREATE PROCEDURAL LANGUAGE plr HANDLER plr_call_handler;


ALTER PROCEDURAL LANGUAGE plr OWNER TO postgres;

--
-- TOC entry 1926 (class 1247 OID 30563)
-- Name: addbandarg; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE addbandarg AS (
	index integer,
	pixeltype text,
	initialvalue double precision,
	nodataval double precision
);


ALTER TYPE addbandarg OWNER TO postgres;

--
-- TOC entry 1917 (class 0 OID 0)
-- Name: raster; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE raster;


--
-- TOC entry 908 (class 1255 OID 30525)
-- Name: raster_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_in(cstring) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_in';


ALTER FUNCTION public.raster_in(cstring) OWNER TO postgres;

--
-- TOC entry 909 (class 1255 OID 30526)
-- Name: raster_out(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_out(raster) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_out';


ALTER FUNCTION public.raster_out(raster) OWNER TO postgres;

--
-- TOC entry 1916 (class 1247 OID 30524)
-- Name: raster; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE raster (
    INTERNALLENGTH = variable,
    INPUT = raster_in,
    OUTPUT = raster_out,
    ALIGNMENT = double,
    STORAGE = extended
);


ALTER TYPE raster OWNER TO postgres;

--
-- TOC entry 1932 (class 1247 OID 30923)
-- Name: agg_samealignment; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE agg_samealignment AS (
	refraster raster,
	aligned boolean
);


ALTER TYPE agg_samealignment OWNER TO postgres;

--
-- TOC entry 1874 (class 0 OID 0)
-- Name: box2d; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box2d;


--
-- TOC entry 372 (class 1255 OID 29823)
-- Name: box2d_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d_in(cstring) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX2D_in';


ALTER FUNCTION public.box2d_in(cstring) OWNER TO postgres;

--
-- TOC entry 373 (class 1255 OID 29824)
-- Name: box2d_out(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d_out(box2d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX2D_out';


ALTER FUNCTION public.box2d_out(box2d) OWNER TO postgres;

--
-- TOC entry 1873 (class 1247 OID 29822)
-- Name: box2d; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box2d (
    INTERNALLENGTH = 65,
    INPUT = box2d_in,
    OUTPUT = box2d_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE box2d OWNER TO postgres;

--
-- TOC entry 1878 (class 0 OID 0)
-- Name: box2df; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box2df;


--
-- TOC entry 374 (class 1255 OID 29827)
-- Name: box2df_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2df_in(cstring) RETURNS box2df
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'box2df_in';


ALTER FUNCTION public.box2df_in(cstring) OWNER TO postgres;

--
-- TOC entry 375 (class 1255 OID 29828)
-- Name: box2df_out(box2df); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2df_out(box2df) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'box2df_out';


ALTER FUNCTION public.box2df_out(box2df) OWNER TO postgres;

--
-- TOC entry 1877 (class 1247 OID 29826)
-- Name: box2df; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box2df (
    INTERNALLENGTH = 16,
    INPUT = box2df_in,
    OUTPUT = box2df_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE box2df OWNER TO postgres;

--
-- TOC entry 1870 (class 0 OID 0)
-- Name: box3d; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box3d;


--
-- TOC entry 370 (class 1255 OID 29819)
-- Name: box3d_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_in(cstring) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_in';


ALTER FUNCTION public.box3d_in(cstring) OWNER TO postgres;

--
-- TOC entry 371 (class 1255 OID 29820)
-- Name: box3d_out(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_out(box3d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_out';


ALTER FUNCTION public.box3d_out(box3d) OWNER TO postgres;

--
-- TOC entry 1869 (class 1247 OID 29818)
-- Name: box3d; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box3d (
    INTERNALLENGTH = 52,
    INPUT = box3d_in,
    OUTPUT = box3d_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE box3d OWNER TO postgres;

--
-- TOC entry 1907 (class 0 OID 0)
-- Name: geography; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geography;


--
-- TOC entry 785 (class 1255 OID 30350)
-- Name: geography_analyze(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-2.1', 'gserialized_analyze_nd';


ALTER FUNCTION public.geography_analyze(internal) OWNER TO postgres;

--
-- TOC entry 781 (class 1255 OID 30346)
-- Name: geography_in(cstring, oid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_in(cstring, oid, integer) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_in';


ALTER FUNCTION public.geography_in(cstring, oid, integer) OWNER TO postgres;

--
-- TOC entry 782 (class 1255 OID 30347)
-- Name: geography_out(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_out(geography) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_out';


ALTER FUNCTION public.geography_out(geography) OWNER TO postgres;

--
-- TOC entry 783 (class 1255 OID 30348)
-- Name: geography_recv(internal, oid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_recv(internal, oid, integer) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_recv';


ALTER FUNCTION public.geography_recv(internal, oid, integer) OWNER TO postgres;

--
-- TOC entry 784 (class 1255 OID 30349)
-- Name: geography_send(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_send(geography) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_send';


ALTER FUNCTION public.geography_send(geography) OWNER TO postgres;

--
-- TOC entry 779 (class 1255 OID 30343)
-- Name: geography_typmod_in(cstring[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_in(cstring[]) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_typmod_in';


ALTER FUNCTION public.geography_typmod_in(cstring[]) OWNER TO postgres;

--
-- TOC entry 780 (class 1255 OID 30344)
-- Name: geography_typmod_out(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_out(integer) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'postgis_typmod_out';


ALTER FUNCTION public.geography_typmod_out(integer) OWNER TO postgres;

--
-- TOC entry 1906 (class 1247 OID 30345)
-- Name: geography; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geography (
    INTERNALLENGTH = variable,
    INPUT = geography_in,
    OUTPUT = geography_out,
    RECEIVE = geography_recv,
    SEND = geography_send,
    TYPMOD_IN = geography_typmod_in,
    TYPMOD_OUT = geography_typmod_out,
    ANALYZE = geography_analyze,
    DELIMITER = ':',
    ALIGNMENT = double,
    STORAGE = main
);


ALTER TYPE geography OWNER TO postgres;

--
-- TOC entry 1866 (class 0 OID 0)
-- Name: geometry; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geometry;


--
-- TOC entry 356 (class 1255 OID 29796)
-- Name: geometry_analyze(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-2.1', 'gserialized_analyze_nd';


ALTER FUNCTION public.geometry_analyze(internal) OWNER TO postgres;

--
-- TOC entry 352 (class 1255 OID 29792)
-- Name: geometry_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_in(cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_in';


ALTER FUNCTION public.geometry_in(cstring) OWNER TO postgres;

--
-- TOC entry 353 (class 1255 OID 29793)
-- Name: geometry_out(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_out(geometry) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_out';


ALTER FUNCTION public.geometry_out(geometry) OWNER TO postgres;

--
-- TOC entry 357 (class 1255 OID 29797)
-- Name: geometry_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_recv(internal) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_recv';


ALTER FUNCTION public.geometry_recv(internal) OWNER TO postgres;

--
-- TOC entry 358 (class 1255 OID 29798)
-- Name: geometry_send(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_send(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_send';


ALTER FUNCTION public.geometry_send(geometry) OWNER TO postgres;

--
-- TOC entry 354 (class 1255 OID 29794)
-- Name: geometry_typmod_in(cstring[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_typmod_in(cstring[]) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_typmod_in';


ALTER FUNCTION public.geometry_typmod_in(cstring[]) OWNER TO postgres;

--
-- TOC entry 355 (class 1255 OID 29795)
-- Name: geometry_typmod_out(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_typmod_out(integer) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'postgis_typmod_out';


ALTER FUNCTION public.geometry_typmod_out(integer) OWNER TO postgres;

--
-- TOC entry 1865 (class 1247 OID 29791)
-- Name: geometry; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geometry (
    INTERNALLENGTH = variable,
    INPUT = geometry_in,
    OUTPUT = geometry_out,
    RECEIVE = geometry_recv,
    SEND = geometry_send,
    TYPMOD_IN = geometry_typmod_in,
    TYPMOD_OUT = geometry_typmod_out,
    ANALYZE = geometry_analyze,
    DELIMITER = ':',
    ALIGNMENT = double,
    STORAGE = main
);


ALTER TYPE geometry OWNER TO postgres;

--
-- TOC entry 1892 (class 1247 OID 30048)
-- Name: geometry_dump; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geometry_dump AS (
	path integer[],
	geom geometry
);


ALTER TYPE geometry_dump OWNER TO postgres;

--
-- TOC entry 1923 (class 1247 OID 30537)
-- Name: geomval; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geomval AS (
	geom geometry,
	val double precision
);


ALTER TYPE geomval OWNER TO postgres;

--
-- TOC entry 1882 (class 0 OID 0)
-- Name: gidx; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gidx;


--
-- TOC entry 376 (class 1255 OID 29831)
-- Name: gidx_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gidx_in(cstring) RETURNS gidx
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gidx_in';


ALTER FUNCTION public.gidx_in(cstring) OWNER TO postgres;

--
-- TOC entry 348 (class 1255 OID 29832)
-- Name: gidx_out(gidx); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gidx_out(gidx) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gidx_out';


ALTER FUNCTION public.gidx_out(gidx) OWNER TO postgres;

--
-- TOC entry 1881 (class 1247 OID 29830)
-- Name: gidx; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gidx (
    INTERNALLENGTH = variable,
    INPUT = gidx_in,
    OUTPUT = gidx_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE gidx OWNER TO postgres;

--
-- TOC entry 1903 (class 0 OID 0)
-- Name: pgis_abs; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE pgis_abs;


--
-- TOC entry 618 (class 1255 OID 30176)
-- Name: pgis_abs_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_abs_in(cstring) RETURNS pgis_abs
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'pgis_abs_in';


ALTER FUNCTION public.pgis_abs_in(cstring) OWNER TO postgres;

--
-- TOC entry 619 (class 1255 OID 30177)
-- Name: pgis_abs_out(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_abs_out(pgis_abs) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'pgis_abs_out';


ALTER FUNCTION public.pgis_abs_out(pgis_abs) OWNER TO postgres;

--
-- TOC entry 1902 (class 1247 OID 30175)
-- Name: pgis_abs; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE pgis_abs (
    INTERNALLENGTH = 8,
    INPUT = pgis_abs_in,
    OUTPUT = pgis_abs_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE pgis_abs OWNER TO postgres;

--
-- TOC entry 1852 (class 1247 OID 29757)
-- Name: plr_environ_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE plr_environ_type AS (
	name text,
	value text
);


ALTER TYPE plr_environ_type OWNER TO postgres;

--
-- TOC entry 1855 (class 1247 OID 29761)
-- Name: r_typename; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE r_typename AS (
	typename text,
	typeoid oid
);


ALTER TYPE r_typename OWNER TO postgres;

--
-- TOC entry 1858 (class 1247 OID 29766)
-- Name: r_version_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE r_version_type AS (
	name text,
	value text
);


ALTER TYPE r_version_type OWNER TO postgres;

--
-- TOC entry 1920 (class 1247 OID 30534)
-- Name: rastbandarg; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE rastbandarg AS (
	rast raster,
	nband integer
);


ALTER TYPE rastbandarg OWNER TO postgres;

--
-- TOC entry 1929 (class 1247 OID 30686)
-- Name: reclassarg; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE reclassarg AS (
	nband integer,
	reclassexpr text,
	pixeltype text,
	nodataval double precision
);


ALTER TYPE reclassarg OWNER TO postgres;

--
-- TOC entry 1862 (class 0 OID 0)
-- Name: spheroid; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE spheroid;


--
-- TOC entry 350 (class 1255 OID 29788)
-- Name: spheroid_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION spheroid_in(cstring) RETURNS spheroid
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ellipsoid_in';


ALTER FUNCTION public.spheroid_in(cstring) OWNER TO postgres;

--
-- TOC entry 351 (class 1255 OID 29789)
-- Name: spheroid_out(spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION spheroid_out(spheroid) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ellipsoid_out';


ALTER FUNCTION public.spheroid_out(spheroid) OWNER TO postgres;

--
-- TOC entry 1861 (class 1247 OID 29787)
-- Name: spheroid; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE spheroid (
    INTERNALLENGTH = 65,
    INPUT = spheroid_in,
    OUTPUT = spheroid_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE spheroid OWNER TO postgres;

--
-- TOC entry 1935 (class 1247 OID 30979)
-- Name: unionarg; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE unionarg AS (
	nband integer,
	uniontype text
);


ALTER TYPE unionarg OWNER TO postgres;

--
-- TOC entry 1899 (class 1247 OID 30146)
-- Name: valid_detail; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE valid_detail AS (
	valid boolean,
	reason character varying,
	location geometry
);


ALTER TYPE valid_detail OWNER TO postgres;

SET search_path = topology, pg_catalog;

--
-- TOC entry 1968 (class 1247 OID 31190)
-- Name: getfaceedges_returntype; Type: TYPE; Schema: topology; Owner: postgres
--

CREATE TYPE getfaceedges_returntype AS (
	sequence integer,
	edge integer
);


ALTER TYPE getfaceedges_returntype OWNER TO postgres;

--
-- TOC entry 1962 (class 1247 OID 31115)
-- Name: topoelement; Type: DOMAIN; Schema: topology; Owner: postgres
--

CREATE DOMAIN topoelement AS integer[]
	CONSTRAINT dimensions CHECK (((array_upper(VALUE, 2) IS NULL) AND (array_upper(VALUE, 1) = 2)))
	CONSTRAINT lower_dimension CHECK ((array_lower(VALUE, 1) = 1))
	CONSTRAINT type_range CHECK (((VALUE)[2] > 0));


ALTER DOMAIN topoelement OWNER TO postgres;

--
-- TOC entry 1966 (class 1247 OID 31119)
-- Name: topoelementarray; Type: DOMAIN; Schema: topology; Owner: postgres
--

CREATE DOMAIN topoelementarray AS integer[]
	CONSTRAINT dimensions CHECK ((((array_upper(VALUE, 2) IS NOT NULL) AND (array_upper(VALUE, 2) = 2)) AND (array_upper(VALUE, 3) IS NULL)));


ALTER DOMAIN topoelementarray OWNER TO postgres;

--
-- TOC entry 1959 (class 1247 OID 31114)
-- Name: topogeometry; Type: TYPE; Schema: topology; Owner: postgres
--

CREATE TYPE topogeometry AS (
	topology_id integer,
	layer_id integer,
	id integer,
	type integer
);


ALTER TYPE topogeometry OWNER TO postgres;

--
-- TOC entry 1953 (class 1247 OID 31111)
-- Name: validatetopology_returntype; Type: TYPE; Schema: topology; Owner: postgres
--

CREATE TYPE validatetopology_returntype AS (
	error character varying,
	id1 integer,
	id2 integer
);


ALTER TYPE validatetopology_returntype OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- TOC entry 1479 (class 1255 OID 31238)
-- Name: update_legend_variable(); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION update_legend_variable() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE config.webgis_ol_layers SET default_legend_variable = 'layer' || NEW.layer_idx WHERE NEW.layer_idx=layer_idx;
RETURN NULL;
END;
$$;


ALTER FUNCTION config.update_legend_variable() OWNER TO postgres;

SET search_path = dati_di_base, pg_catalog;

--
-- TOC entry 1480 (class 1255 OID 31239)
-- Name: update_the_geom_rete_web(); Type: FUNCTION; Schema: dati_di_base; Owner: radar
--

CREATE FUNCTION update_the_geom_rete_web() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE dati_di_base.rete_web SET the_geom = ST_SetSRID(ST_MakePoint(NEW.lonx, NEW.latx),4326)
	WHERE NEW.id=id;
RETURN NULL;
END;
$$;


ALTER FUNCTION dati_di_base.update_the_geom_rete_web() OWNER TO radar;

SET search_path = public, pg_catalog;

--
-- TOC entry 1386 (class 1255 OID 31062)
-- Name: _add_overview_constraint(name, name, name, name, name, name, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_overview_constraint(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, factor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_overview_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_overview_constraint(' || quote_ident($3)
			|| ',' || $7
			|| ',' || quote_literal($4)
			|| ',' || quote_literal($5)
			|| ',' || quote_literal($6)
			|| '))';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_overview_constraint(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, factor integer) OWNER TO postgres;

--
-- TOC entry 1336 (class 1255 OID 31007)
-- Name: _add_raster_constraint(name, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint(cn name, sql text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $$
	BEGIN
		BEGIN
			EXECUTE sql;
		EXCEPTION
			WHEN duplicate_object THEN
				RAISE NOTICE 'The constraint "%" already exists.  To replace the existing constraint, delete the constraint and call ApplyRasterConstraints again', cn;
			WHEN OTHERS THEN
				RAISE NOTICE 'Unable to add constraint: %', cn;
				RAISE NOTICE 'SQL used for failed constraint: %', sql;
				RAISE NOTICE 'Returned error message: %', SQLERRM;
				RETURN FALSE;
		END;

		RETURN TRUE;
	END;
	$$;


ALTER FUNCTION public._add_raster_constraint(cn name, sql text) OWNER TO postgres;

--
-- TOC entry 1351 (class 1255 OID 31022)
-- Name: _add_raster_constraint_alignment(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_same_alignment_' || $3;

		sql := 'SELECT st_makeemptyraster(1, 1, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid) FROM st_metadata((SELECT '
			|| quote_ident($3)
			|| ' FROM ' || fqtn || ' LIMIT 1))';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the alignment of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_samealignment(' || quote_ident($3) || ', ''' || attr || '''::raster))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1346 (class 1255 OID 31016)
-- Name: _add_raster_constraint_blocksize(name, name, name, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attrset integer[];
		attr integer;
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either "width" or "height"';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_' || $4 || '_' || $3;

		sql := 'SELECT st_' || $4 || '('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' GROUP BY 1 ORDER BY count(*) DESC';
		BEGIN
			attrset := ARRAY[]::integer[];
			FOR attr IN EXECUTE sql LOOP
				attrset := attrset || attr;
			END LOOP;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the % of a sample raster', $4;
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_' || $4 || '('
			|| quote_ident($3)
			|| ') IN (' || array_to_string(attrset, ',') || '))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) OWNER TO postgres;

--
-- TOC entry 1359 (class 1255 OID 31028)
-- Name: _add_raster_constraint_coverage_tile(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_coverage_tile(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;

		_scalex double precision;
		_scaley double precision;
		_skewx double precision;
		_skewy double precision;
		_tilewidth integer;
		_tileheight integer;
		_alignment boolean;

		_covextent geometry;
		_covrast raster;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_coverage_tile_' || $3;

		-- metadata
		BEGIN
			sql := 'WITH foo AS (SELECT ST_Metadata(' || quote_ident($3) || ') AS meta, ST_ConvexHull(' || quote_ident($3) || ') AS hull FROM ' || fqtn || ') SELECT max((meta).scalex), max((meta).scaley), max((meta).skewx), max((meta).skewy), max((meta).width), max((meta).height), ST_Union(hull) FROM foo';
			EXECUTE sql INTO _scalex, _scaley, _skewx, _skewy, _tilewidth, _tileheight, _covextent;
		EXCEPTION WHEN OTHERS THEN
		END;

		-- rasterize extent
		BEGIN
			_covrast := ST_AsRaster(_covextent, _scalex, _scaley, '8BUI', 1, 0, NULL, NULL, _skewx, _skewy);
			IF _covrast IS NULL THEN
				RAISE NOTICE 'Unable to create coverage raster. Cannot add coverage tile constraint';
				RETURN FALSE;
			END IF;

			-- remove band
			_covrast := ST_MakeEmptyRaster(_covrast);
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to create coverage raster. Cannot add coverage tile constraint';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_iscoveragetile(' || quote_ident($3) || ', ''' || _covrast || '''::raster, ' || _tilewidth || ', ' || _tileheight || '))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_coverage_tile(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1348 (class 1255 OID 31019)
-- Name: _add_raster_constraint_extent(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_max_extent_' || $3;

		sql := 'SELECT st_ashexewkb(st_union(st_convexhull('
			|| quote_ident($3)
			|| '))) FROM '
			|| fqtn;
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the extent of the raster column. Attempting memory efficient (slower) approach';

			sql := 'SELECT st_ashexewkb(st_memunion(st_convexhull('
				|| quote_ident($3)
				|| '))) FROM '
				|| fqtn;
			BEGIN
				EXECUTE sql INTO attr;
			EXCEPTION WHEN OTHERS THEN
				RAISE NOTICE 'Still unable to get the extent of the raster column. Cannot add extent constraint';
				RETURN FALSE;
			END;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_coveredby(st_convexhull('
			|| quote_ident($3)
			|| '), ''' || attr || '''::geometry))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1370 (class 1255 OID 31041)
-- Name: _add_raster_constraint_nodata_values(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_nodata_values_' || $3;

		sql := 'SELECT _raster_constraint_nodata_values(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_nodata_values(' || quote_ident($3)
			|| ')::numeric(16,10)[] = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS NULL THEN
				sql := sql || 'NULL';
			ELSE
				sql := sql || attr[x];
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::numeric(16,10)[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1364 (class 1255 OID 31033)
-- Name: _add_raster_constraint_num_bands(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_num_bands_' || $3;

		sql := 'SELECT st_numbands(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the number of bands of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_numbands(' || quote_ident($3)
			|| ') = ' || attr
			|| ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1374 (class 1255 OID 31045)
-- Name: _add_raster_constraint_out_db(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr boolean[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_out_db_' || $3;

		sql := 'SELECT _raster_constraint_out_db(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_out_db(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS FALSE THEN
				sql := sql || 'FALSE';
			ELSE
				sql := sql || 'TRUE';
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::boolean[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1368 (class 1255 OID 31037)
-- Name: _add_raster_constraint_pixel_types(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_pixel_types_' || $3;

		sql := 'SELECT _raster_constraint_pixel_types(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_pixel_types(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			sql := sql || '"' || attr[x] || '"';
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::text[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1343 (class 1255 OID 31013)
-- Name: _add_raster_constraint_scale(name, name, name, character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision;
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either "x" or "y"';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_scale' || $4 || '_' || $3;

		sql := 'SELECT st_scale' || $4 || '('
			|| quote_ident($3)
			|| ') FROM '
			|| fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the %-scale of a sample raster', upper($4);
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_scale' || $4 || '('
			|| quote_ident($3)
			|| ')::numeric(25,10) = (' || attr || ')::numeric(25,10))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) OWNER TO postgres;

--
-- TOC entry 1354 (class 1255 OID 31025)
-- Name: _add_raster_constraint_spatially_unique(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_spatially_unique(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
		meta record;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_spatially_unique_' || quote_ident($2) || '_'|| $3;

		sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' EXCLUDE ((' || quote_ident($3) || '::geometry) WITH =)';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_spatially_unique(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1340 (class 1255 OID 31010)
-- Name: _add_raster_constraint_srid(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _add_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_srid_' || $3;

		sql := 'SELECT st_srid('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the SRID of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_srid('
			|| quote_ident($3)
			|| ') = ' || attr || ')';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;


ALTER FUNCTION public._add_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1387 (class 1255 OID 31063)
-- Name: _drop_overview_constraint(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_overview_constraint(ovschema name, ovtable name, ovcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_overview_' || $3) $_$;


ALTER FUNCTION public._drop_overview_constraint(ovschema name, ovtable name, ovcolumn name) OWNER TO postgres;

--
-- TOC entry 1338 (class 1255 OID 31008)
-- Name: _drop_raster_constraint(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint(rastschema name, rasttable name, cn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		BEGIN
			EXECUTE 'ALTER TABLE '
				|| fqtn
				|| ' DROP CONSTRAINT '
				|| quote_ident(cn);
			RETURN TRUE;
		EXCEPTION
			WHEN undefined_object THEN
				RAISE NOTICE 'The constraint "%" does not exist.  Skipping', cn;
			WHEN OTHERS THEN
				RAISE NOTICE 'Unable to drop constraint "%"', cn;
				RETURN FALSE;
		END;

		RETURN TRUE;
	END;
	$_$;


ALTER FUNCTION public._drop_raster_constraint(rastschema name, rasttable name, cn name) OWNER TO postgres;

--
-- TOC entry 1352 (class 1255 OID 31023)
-- Name: _drop_raster_constraint_alignment(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_same_alignment_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1347 (class 1255 OID 31017)
-- Name: _drop_raster_constraint_blocksize(name, name, name, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either "width" or "height"';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_' || $4 || '_' || $3);
	END;
	$_$;


ALTER FUNCTION public._drop_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) OWNER TO postgres;

--
-- TOC entry 1360 (class 1255 OID 31029)
-- Name: _drop_raster_constraint_coverage_tile(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_coverage_tile(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_coverage_tile_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_coverage_tile(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1349 (class 1255 OID 31020)
-- Name: _drop_raster_constraint_extent(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_max_extent_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1371 (class 1255 OID 31042)
-- Name: _drop_raster_constraint_nodata_values(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_nodata_values_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1365 (class 1255 OID 31034)
-- Name: _drop_raster_constraint_num_bands(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_num_bands_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1375 (class 1255 OID 31046)
-- Name: _drop_raster_constraint_out_db(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_out_db_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1369 (class 1255 OID 31038)
-- Name: _drop_raster_constraint_pixel_types(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_pixel_types_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1362 (class 1255 OID 31031)
-- Name: _drop_raster_constraint_regular_blocking(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_regular_blocking_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_regular_blocking(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1344 (class 1255 OID 31014)
-- Name: _drop_raster_constraint_scale(name, name, name, character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either "x" or "y"';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_scale' || $4 || '_' || $3);
	END;
	$_$;


ALTER FUNCTION public._drop_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) OWNER TO postgres;

--
-- TOC entry 1355 (class 1255 OID 31026)
-- Name: _drop_raster_constraint_spatially_unique(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_spatially_unique(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		cn text;
	BEGIN
		SELECT
			s.conname INTO cn
		FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s, pg_index idx, pg_operator op
		WHERE n.nspname = $1
			AND c.relname = $2
			AND a.attname = $3
			AND a.attrelid = c.oid
			AND s.connamespace = n.oid
			AND s.conrelid = c.oid
			AND s.contype = 'x'
			AND 0::smallint = ANY (s.conkey)
			AND idx.indexrelid = s.conindid
			AND pg_get_indexdef(idx.indexrelid, 1, true) LIKE '(' || quote_ident($3) || '::geometry)'
			AND s.conexclop[1] = op.oid
			AND op.oprname = '=';

		RETURN _drop_raster_constraint($1, $2, cn); 
	END;
	$_$;


ALTER FUNCTION public._drop_raster_constraint_spatially_unique(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1341 (class 1255 OID 31011)
-- Name: _drop_raster_constraint_srid(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _drop_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _drop_raster_constraint($1, $2, 'enforce_srid_' || $3) $_$;


ALTER FUNCTION public._drop_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1385 (class 1255 OID 31060)
-- Name: _overview_constraint(raster, integer, name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _overview_constraint(ov raster, factor integer, refschema name, reftable name, refcolumn name) RETURNS boolean
    LANGUAGE sql STABLE
    AS $_$ SELECT COALESCE((SELECT TRUE FROM raster_columns WHERE r_table_catalog = current_database() AND r_table_schema = $3 AND r_table_name = $4 AND r_raster_column = $5), FALSE) $_$;


ALTER FUNCTION public._overview_constraint(ov raster, factor integer, refschema name, reftable name, refcolumn name) OWNER TO postgres;

--
-- TOC entry 1378 (class 1255 OID 31061)
-- Name: _overview_constraint_info(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _overview_constraint_info(ovschema name, ovtable name, ovcolumn name, OUT refschema name, OUT reftable name, OUT refcolumn name, OUT factor integer) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		split_part(split_part(s.consrc, '''::name', 1), '''', 2)::name,
		split_part(split_part(s.consrc, '''::name', 2), '''', 2)::name,
		split_part(split_part(s.consrc, '''::name', 3), '''', 2)::name,
		trim(both from split_part(s.consrc, ',', 2))::integer
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%_overview_constraint(%'
	$_$;


ALTER FUNCTION public._overview_constraint_info(ovschema name, ovtable name, ovcolumn name, OUT refschema name, OUT reftable name, OUT refcolumn name, OUT factor integer) OWNER TO postgres;

--
-- TOC entry 349 (class 1255 OID 29786)
-- Name: _postgis_deprecate(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _postgis_deprecate(oldname text, newname text, version text) RETURNS void
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
  curver_text text;
BEGIN
  --
  -- Raises a NOTICE if it was deprecated in this version,
  -- a WARNING if in a previous version (only up to minor version checked)
  --
    curver_text := '2.1.8';
    IF split_part(curver_text,'.',1)::int > split_part(version,'.',1)::int OR
       ( split_part(curver_text,'.',1) = split_part(version,'.',1) AND
         split_part(curver_text,'.',2) != split_part(version,'.',2) )
    THEN
      RAISE WARNING '% signature was deprecated in %. Please use %', oldname, version, newname;
    ELSE
      RAISE DEBUG '% signature was deprecated in %. Please use %', oldname, version, newname;
    END IF;
END;
$$;


ALTER FUNCTION public._postgis_deprecate(oldname text, newname text, version text) OWNER TO postgres;

--
-- TOC entry 392 (class 1255 OID 29862)
-- Name: _postgis_join_selectivity(regclass, text, regclass, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _postgis_join_selectivity(regclass, text, regclass, text, text DEFAULT '2'::text) RETURNS double precision
    LANGUAGE c STRICT
    AS '$libdir/postgis-2.1', '_postgis_gserialized_joinsel';


ALTER FUNCTION public._postgis_join_selectivity(regclass, text, regclass, text, text) OWNER TO postgres;

--
-- TOC entry 391 (class 1255 OID 29861)
-- Name: _postgis_selectivity(regclass, text, geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _postgis_selectivity(tbl regclass, att_name text, geom geometry, mode text DEFAULT '2'::text) RETURNS double precision
    LANGUAGE c STRICT
    AS '$libdir/postgis-2.1', '_postgis_gserialized_sel';


ALTER FUNCTION public._postgis_selectivity(tbl regclass, att_name text, geom geometry, mode text) OWNER TO postgres;

--
-- TOC entry 393 (class 1255 OID 29863)
-- Name: _postgis_stats(regclass, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _postgis_stats(tbl regclass, att_name text, text DEFAULT '2'::text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/postgis-2.1', '_postgis_gserialized_stats';


ALTER FUNCTION public._postgis_stats(tbl regclass, att_name text, text) OWNER TO postgres;

--
-- TOC entry 1350 (class 1255 OID 31021)
-- Name: _raster_constraint_info_alignment(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_alignment(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		TRUE
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_samealignment(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_alignment(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1345 (class 1255 OID 31015)
-- Name: _raster_constraint_info_blocksize(name, name, name, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		CASE
			WHEN strpos(s.consrc, 'ANY (ARRAY[') > 0 THEN
				split_part((regexp_matches(s.consrc, E'ARRAY\\[(.*?){1}\\]'))[1], ',', 1)::integer
			ELSE
				replace(replace(split_part(s.consrc, '= ', 2), ')', ''), '(', '')::integer
			END
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_' || $4 || '(%= %';
	$_$;


ALTER FUNCTION public._raster_constraint_info_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) OWNER TO postgres;

--
-- TOC entry 1356 (class 1255 OID 31027)
-- Name: _raster_constraint_info_coverage_tile(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_coverage_tile(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		TRUE
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_iscoveragetile(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_coverage_tile(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1337 (class 1255 OID 31018)
-- Name: _raster_constraint_info_extent(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_extent(rastschema name, rasttable name, rastcolumn name) RETURNS geometry
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		trim(both '''' from split_part(trim(split_part(s.consrc, ',', 2)), '::', 1))::geometry
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_coveredby(st_convexhull(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_extent(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1357 (class 1255 OID 31039)
-- Name: _raster_constraint_info_nodata_values(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_nodata_values(rastschema name, rasttable name, rastcolumn name) RETURNS double precision[]
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		trim(both '''' from split_part(replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', ''), '::', 1))::double precision[]
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%_raster_constraint_nodata_values(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_nodata_values(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1363 (class 1255 OID 31032)
-- Name: _raster_constraint_info_num_bands(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_num_bands(rastschema name, rasttable name, rastcolumn name) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_numbands(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_num_bands(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1372 (class 1255 OID 31043)
-- Name: _raster_constraint_info_out_db(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_out_db(rastschema name, rasttable name, rastcolumn name) RETURNS boolean[]
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		trim(both '''' from split_part(replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', ''), '::', 1))::boolean[]
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%_raster_constraint_out_db(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_out_db(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1366 (class 1255 OID 31035)
-- Name: _raster_constraint_info_pixel_types(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_pixel_types(rastschema name, rasttable name, rastcolumn name) RETURNS text[]
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		trim(both '''' from split_part(replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', ''), '::', 1))::text[]
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%_raster_constraint_pixel_types(%';
	$_$;


ALTER FUNCTION public._raster_constraint_info_pixel_types(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1361 (class 1255 OID 31030)
-- Name: _raster_constraint_info_regular_blocking(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		covtile boolean;
		spunique boolean;
	BEGIN
		-- check existance of constraints
		-- coverage tile constraint
		covtile := COALESCE(_raster_constraint_info_coverage_tile($1, $2, $3), FALSE);

		-- spatially unique constraint
		spunique := COALESCE(_raster_constraint_info_spatially_unique($1, $2, $3), FALSE);

		RETURN (covtile AND spunique);
	END;
	$_$;


ALTER FUNCTION public._raster_constraint_info_regular_blocking(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1342 (class 1255 OID 31012)
-- Name: _raster_constraint_info_scale(name, name, name, character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		replace(replace(split_part(split_part(s.consrc, ' = ', 2), '::', 1), ')', ''), '(', '')::double precision
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_scale' || $4 || '(% = %';
	$_$;


ALTER FUNCTION public._raster_constraint_info_scale(rastschema name, rasttable name, rastcolumn name, axis character) OWNER TO postgres;

--
-- TOC entry 1353 (class 1255 OID 31024)
-- Name: _raster_constraint_info_spatially_unique(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_spatially_unique(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		TRUE
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s, pg_index idx, pg_operator op
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND s.contype = 'x'
		AND 0::smallint = ANY (s.conkey)
		AND idx.indexrelid = s.conindid
		AND pg_get_indexdef(idx.indexrelid, 1, true) LIKE '(' || quote_ident($3) || '::geometry)'
		AND s.conexclop[1] = op.oid
		AND op.oprname = '=';
	$_$;


ALTER FUNCTION public._raster_constraint_info_spatially_unique(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1339 (class 1255 OID 31009)
-- Name: _raster_constraint_info_srid(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_info_srid(rastschema name, rasttable name, rastcolumn name) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT
		replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
	FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_srid(% = %';
	$_$;


ALTER FUNCTION public._raster_constraint_info_srid(rastschema name, rasttable name, rastcolumn name) OWNER TO postgres;

--
-- TOC entry 1358 (class 1255 OID 31040)
-- Name: _raster_constraint_nodata_values(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_nodata_values(rast raster) RETURNS double precision[]
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT array_agg(nodatavalue)::double precision[] FROM st_bandmetadata($1, ARRAY[]::int[]); $_$;


ALTER FUNCTION public._raster_constraint_nodata_values(rast raster) OWNER TO postgres;

--
-- TOC entry 1373 (class 1255 OID 31044)
-- Name: _raster_constraint_out_db(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_out_db(rast raster) RETURNS boolean[]
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT array_agg(isoutdb)::boolean[] FROM st_bandmetadata($1, ARRAY[]::int[]); $_$;


ALTER FUNCTION public._raster_constraint_out_db(rast raster) OWNER TO postgres;

--
-- TOC entry 1367 (class 1255 OID 31036)
-- Name: _raster_constraint_pixel_types(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _raster_constraint_pixel_types(rast raster) RETURNS text[]
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT array_agg(pixeltype)::text[] FROM st_bandmetadata($1, ARRAY[]::int[]); $_$;


ALTER FUNCTION public._raster_constraint_pixel_types(rast raster) OWNER TO postgres;

--
-- TOC entry 885 (class 1255 OID 30492)
-- Name: _st_3ddfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_dfullywithin3d';


ALTER FUNCTION public._st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 882 (class 1255 OID 30490)
-- Name: _st_3ddwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_3ddwithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_dwithin3d';


ALTER FUNCTION public._st_3ddwithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 887 (class 1255 OID 30494)
-- Name: _st_3dintersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_3dintersects(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'intersects3d';


ALTER FUNCTION public._st_3dintersects(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 823 (class 1255 OID 30423)
-- Name: _st_asgeojson(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgeojson(integer, geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_as_geojson';


ALTER FUNCTION public._st_asgeojson(integer, geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 675 (class 1255 OID 30239)
-- Name: _st_asgeojson(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgeojson(integer, geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asGeoJson';


ALTER FUNCTION public._st_asgeojson(integer, geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 815 (class 1255 OID 30415)
-- Name: _st_asgml(integer, geography, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgml(integer, geography, integer, integer, text, text) RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'geography_as_gml';


ALTER FUNCTION public._st_asgml(integer, geography, integer, integer, text, text) OWNER TO postgres;

--
-- TOC entry 669 (class 1255 OID 30233)
-- Name: _st_asgml(integer, geometry, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgml(integer, geometry, integer, integer, text, text) RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'LWGEOM_asGML';


ALTER FUNCTION public._st_asgml(integer, geometry, integer, integer, text, text) OWNER TO postgres;

--
-- TOC entry 819 (class 1255 OID 30419)
-- Name: _st_askml(integer, geography, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_askml(integer, geography, integer, text) RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'geography_as_kml';


ALTER FUNCTION public._st_askml(integer, geography, integer, text) OWNER TO postgres;

--
-- TOC entry 672 (class 1255 OID 30236)
-- Name: _st_askml(integer, geometry, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_askml(integer, geometry, integer, text) RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'LWGEOM_asKML';


ALTER FUNCTION public._st_askml(integer, geometry, integer, text) OWNER TO postgres;

--
-- TOC entry 1165 (class 1255 OID 30787)
-- Name: _st_aspect4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_aspect4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		x integer;
		y integer;
		z integer;

		_width double precision;
		_height double precision;
		_units text;

		dz_dx double precision;
		dz_dy double precision;
		aspect double precision;
		halfpi double precision;

		_value double precision[][][];
		ndims int;
	BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
		END IF;

		IF array_length(userargs, 1) < 3 THEN
			RAISE EXCEPTION 'At least three elements must be provided for the third parameter';
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		_width := userargs[1]::double precision;
		_height := userargs[2]::double precision;
		_units := userargs[3];

		
		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
		ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
					END IF;
				END LOOP;
			END LOOP;
		END IF;

		dz_dy := ((_value[z][3][1] + _value[z][3][2] + _value[z][3][2] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][1][2] + _value[z][1][2] + _value[z][1][3]));
		dz_dx := ((_value[z][1][3] + _value[z][2][3] + _value[z][2][3] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][2][1] + _value[z][2][1] + _value[z][3][1]));

		-- aspect is flat
		IF abs(dz_dx) = 0::double precision AND abs(dz_dy) = 0::double precision THEN
			RETURN -1;
		END IF;

		-- aspect is in radians
		aspect := atan2(dz_dy, -dz_dx);

		-- north = 0, pi/2 = east, 3pi/2 = west
		halfpi := pi() / 2.0;
		IF aspect > halfpi THEN
			aspect := (5.0 * halfpi) - aspect;
		ELSE
			aspect := halfpi - aspect;
		END IF;

		IF aspect = 2 * pi() THEN
			aspect := 0.;
		END IF;

		-- output depends on user preference
		CASE substring(upper(trim(leading from _units)) for 3)
			-- radians
			WHEN 'rad' THEN
				RETURN aspect;
			-- degrees (default)
			ELSE
				RETURN degrees(aspect);
		END CASE;

	END;
	$$;


ALTER FUNCTION public._st_aspect4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1086 (class 1255 OID 30711)
-- Name: _st_asraster(geometry, double precision, double precision, integer, integer, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asraster(geom geometry, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0, width integer DEFAULT 0, height integer DEFAULT 0, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_asRaster';


ALTER FUNCTION public._st_asraster(geom geometry, scalex double precision, scaley double precision, width integer, height integer, pixeltype text[], value double precision[], nodataval double precision[], upperleftx double precision, upperlefty double precision, gridx double precision, gridy double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 906 (class 1255 OID 30515)
-- Name: _st_asx3d(integer, geometry, integer, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asx3d(integer, geometry, integer, integer, text) RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'LWGEOM_asX3D';


ALTER FUNCTION public._st_asx3d(integer, geometry, integer, integer, text) OWNER TO postgres;

--
-- TOC entry 860 (class 1255 OID 30460)
-- Name: _st_bestsrid(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_bestsrid(geography) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_BestSRID($1,$1)$_$;


ALTER FUNCTION public._st_bestsrid(geography) OWNER TO postgres;

--
-- TOC entry 859 (class 1255 OID 30459)
-- Name: _st_bestsrid(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_bestsrid(geography, geography) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_bestsrid';


ALTER FUNCTION public._st_bestsrid(geography, geography) OWNER TO postgres;

--
-- TOC entry 585 (class 1255 OID 30135)
-- Name: _st_buffer(geometry, double precision, cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_buffer(geometry, double precision, cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'buffer';


ALTER FUNCTION public._st_buffer(geometry, double precision, cstring) OWNER TO postgres;

--
-- TOC entry 1320 (class 1255 OID 30991)
-- Name: _st_clip(raster, integer[], geometry, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_clip(rast raster, nband integer[], geom geometry, nodataval double precision[] DEFAULT NULL::double precision[], crop boolean DEFAULT true) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_clip';


ALTER FUNCTION public._st_clip(rast raster, nband integer[], geom geometry, nodataval double precision[], crop boolean) OWNER TO postgres;

--
-- TOC entry 1064 (class 1255 OID 30691)
-- Name: _st_colormap(raster, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_colormap(rast raster, nband integer, colormap text, method text DEFAULT 'INTERPOLATE'::text) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_colorMap';


ALTER FUNCTION public._st_colormap(rast raster, nband integer, colormap text, method text) OWNER TO postgres;

--
-- TOC entry 904 (class 1255 OID 30512)
-- Name: _st_concavehull(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_concavehull(param_inputgeom geometry) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE     
	vexhull GEOMETRY;
	var_resultgeom geometry;
	var_inputgeom geometry;
	vexring GEOMETRY;
	cavering GEOMETRY;
	cavept geometry[];
	seglength double precision;
	var_tempgeom geometry;
	scale_factor integer := 1;
	i integer;
	
	BEGIN

		-- First compute the ConvexHull of the geometry
		vexhull := ST_ConvexHull(param_inputgeom);
		var_inputgeom := param_inputgeom;
		--A point really has no concave hull
		IF ST_GeometryType(vexhull) = 'ST_Point' OR ST_GeometryType(vexHull) = 'ST_LineString' THEN
			RETURN vexhull;
		END IF;

		-- convert the hull perimeter to a linestring so we can manipulate individual points
		vexring := CASE WHEN ST_GeometryType(vexhull) = 'ST_LineString' THEN vexhull ELSE ST_ExteriorRing(vexhull) END;
		IF abs(ST_X(ST_PointN(vexring,1))) < 1 THEN --scale the geometry to prevent stupid precision errors - not sure it works so make low for now
			scale_factor := 100;
			vexring := ST_Scale(vexring, scale_factor,scale_factor);
			var_inputgeom := ST_Scale(var_inputgeom, scale_factor, scale_factor);
			--RAISE NOTICE 'Scaling';
		END IF;
		seglength := ST_Length(vexring)/least(ST_NPoints(vexring)*2,1000) ;

		vexring := ST_Segmentize(vexring, seglength);
		-- find the point on the original geom that is closest to each point of the convex hull and make a new linestring out of it.
		cavering := ST_Collect(
			ARRAY(

				SELECT 
					ST_ClosestPoint(var_inputgeom, pt ) As the_geom
					FROM (
						SELECT  ST_PointN(vexring, n ) As pt, n
							FROM 
							generate_series(1, ST_NPoints(vexring) ) As n
						) As pt
				
				)
			)
		; 
		

		var_resultgeom := ST_MakeLine(geom) 
			FROM ST_Dump(cavering) As foo;

		IF ST_IsSimple(var_resultgeom) THEN
			var_resultgeom := ST_MakePolygon(var_resultgeom);
			--RAISE NOTICE 'is Simple: %', var_resultgeom;
		ELSE 
			--RAISE NOTICE 'is not Simple: %', var_resultgeom;
			var_resultgeom := ST_ConvexHull(var_resultgeom);
		END IF;
		
		IF scale_factor > 1 THEN -- scale the result back
			var_resultgeom := ST_Scale(var_resultgeom, 1/scale_factor, 1/scale_factor);
		END IF;
		RETURN var_resultgeom;
	
	END;
$$;


ALTER FUNCTION public._st_concavehull(param_inputgeom geometry) OWNER TO postgres;

--
-- TOC entry 639 (class 1255 OID 30203)
-- Name: _st_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_contains(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'contains';


ALTER FUNCTION public._st_contains(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1285 (class 1255 OID 30943)
-- Name: _st_contains(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_contains(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_contains';


ALTER FUNCTION public._st_contains(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 645 (class 1255 OID 30209)
-- Name: _st_containsproperly(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_containsproperly(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'containsproperly';


ALTER FUNCTION public._st_containsproperly(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1146 (class 1255 OID 30946)
-- Name: _st_containsproperly(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_containsproperly(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_containsProperly';


ALTER FUNCTION public._st_containsproperly(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 1154 (class 1255 OID 30773)
-- Name: _st_convertarray4ma(double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_convertarray4ma(value double precision[]) RETURNS double precision[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE
		_value double precision[][][];
		x int;
		y int;
	BEGIN
		IF array_ndims(value) != 2 THEN
			RAISE EXCEPTION 'Function parameter must be a 2-dimension array';
		END IF;

		_value := array_fill(NULL::double precision, ARRAY[1, array_length(value, 1), array_length(value, 2)]::int[], ARRAY[1, array_lower(value, 1), array_lower(value, 2)]::int[]);

		-- row
		FOR y IN array_lower(value, 1)..array_upper(value, 1) LOOP
			-- column
			FOR x IN array_lower(value, 2)..array_upper(value, 2) LOOP
				_value[1][y][x] = value[y][x];
			END LOOP;
		END LOOP;

		RETURN _value;
	END;
	$$;


ALTER FUNCTION public._st_convertarray4ma(value double precision[]) OWNER TO postgres;

--
-- TOC entry 962 (class 1255 OID 30588)
-- Name: _st_count(raster, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_count(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) RETURNS bigint
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		rtn bigint;
	BEGIN
		IF exclude_nodata_value IS FALSE THEN
			SELECT width * height INTO rtn FROM ST_Metadata(rast);
		ELSE
			SELECT count INTO rtn FROM _st_summarystats($1, $2, $3, $4);
		END IF;

		RETURN rtn;
	END;
	$_$;


ALTER FUNCTION public._st_count(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 969 (class 1255 OID 30595)
-- Name: _st_count(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_count(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) RETURNS bigint
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		curs refcursor;

		ctable text;
		ccolumn text;
		rast raster;

		rtn bigint;
		tmp bigint;
	BEGIN
		-- nband
		IF nband < 1 THEN
			RAISE WARNING 'Invalid band index (must use 1-based). Returning NULL';
			RETURN NULL;
		END IF;

		-- sample percent
		IF sample_percent < 0 OR sample_percent > 1 THEN
			RAISE WARNING 'Invalid sample percentage (must be between 0 and 1). Returning NULL';
			RETURN NULL;
		END IF;

		-- exclude_nodata_value IS TRUE
		IF exclude_nodata_value IS TRUE THEN
			SELECT count INTO rtn FROM _st_summarystats($1, $2, $3, $4, $5);
			RETURN rtn;
		END IF;

		-- clean rastertable and rastercolumn
		ctable := quote_ident(rastertable);
		ccolumn := quote_ident(rastercolumn);

		BEGIN
			OPEN curs FOR EXECUTE 'SELECT '
					|| ccolumn
					|| ' FROM '
					|| ctable
					|| ' WHERE '
					|| ccolumn
					|| ' IS NOT NULL';
		EXCEPTION
			WHEN OTHERS THEN
				RAISE WARNING 'Invalid table or column name. Returning NULL';
				RETURN NULL;
		END;

		rtn := 0;
		LOOP
			FETCH curs INTO rast;
			EXIT WHEN NOT FOUND;

			SELECT (width * height) INTO tmp FROM ST_Metadata(rast);
			rtn := rtn + tmp;
		END LOOP;

		CLOSE curs;

		RETURN rtn;
	END;
	$_$;


ALTER FUNCTION public._st_count(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 641 (class 1255 OID 30205)
-- Name: _st_coveredby(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_coveredby(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'coveredby';


ALTER FUNCTION public._st_coveredby(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1291 (class 1255 OID 30952)
-- Name: _st_coveredby(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_coveredby(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_coveredby';


ALTER FUNCTION public._st_coveredby(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 851 (class 1255 OID 30451)
-- Name: _st_covers(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_covers(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_covers';


ALTER FUNCTION public._st_covers(geography, geography) OWNER TO postgres;

--
-- TOC entry 643 (class 1255 OID 30207)
-- Name: _st_covers(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_covers(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'covers';


ALTER FUNCTION public._st_covers(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1288 (class 1255 OID 30949)
-- Name: _st_covers(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_covers(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_covers';


ALTER FUNCTION public._st_covers(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 637 (class 1255 OID 30201)
-- Name: _st_crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_crosses(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'crosses';


ALTER FUNCTION public._st_crosses(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 761 (class 1255 OID 30325)
-- Name: _st_dfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dfullywithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_dfullywithin';


ALTER FUNCTION public._st_dfullywithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 1300 (class 1255 OID 30961)
-- Name: _st_dfullywithin(raster, integer, raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dfullywithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_dfullywithin';


ALTER FUNCTION public._st_dfullywithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) OWNER TO postgres;

--
-- TOC entry 827 (class 1255 OID 30427)
-- Name: _st_distance(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distance(geography, geography, double precision, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_distance';


ALTER FUNCTION public._st_distance(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 840 (class 1255 OID 30440)
-- Name: _st_distancetree(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distancetree(geography, geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_DistanceTree($1, $2, 0.0, true)$_$;


ALTER FUNCTION public._st_distancetree(geography, geography) OWNER TO postgres;

--
-- TOC entry 839 (class 1255 OID 30439)
-- Name: _st_distancetree(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distancetree(geography, geography, double precision, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_distance_tree';


ALTER FUNCTION public._st_distancetree(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 838 (class 1255 OID 30438)
-- Name: _st_distanceuncached(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distanceuncached(geography, geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_DistanceUnCached($1, $2, 0.0, true)$_$;


ALTER FUNCTION public._st_distanceuncached(geography, geography) OWNER TO postgres;

--
-- TOC entry 837 (class 1255 OID 30437)
-- Name: _st_distanceuncached(geography, geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distanceuncached(geography, geography, boolean) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_DistanceUnCached($1, $2, 0.0, $3)$_$;


ALTER FUNCTION public._st_distanceuncached(geography, geography, boolean) OWNER TO postgres;

--
-- TOC entry 836 (class 1255 OID 30436)
-- Name: _st_distanceuncached(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distanceuncached(geography, geography, double precision, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_distance_uncached';


ALTER FUNCTION public._st_distanceuncached(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 524 (class 1255 OID 30051)
-- Name: _st_dumppoints(geometry, integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  -- RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case collections : iterate and return the DumpPoints of the geometries

  IF (ST_IsCollection(the_geom)) THEN
 
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

  -- Special case (TRIANGLE) : return the points of the external rings of a TRIANGLE
  IF (ST_GeometryType(the_geom) = 'ST_Triangle') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING, CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;


ALTER FUNCTION public._st_dumppoints(the_geom geometry, cur_path integer[]) OWNER TO postgres;

--
-- TOC entry 633 (class 1255 OID 30197)
-- Name: _st_dwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_dwithin';


ALTER FUNCTION public._st_dwithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 828 (class 1255 OID 30428)
-- Name: _st_dwithin(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithin(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_dwithin';


ALTER FUNCTION public._st_dwithin(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 1297 (class 1255 OID 30958)
-- Name: _st_dwithin(raster, integer, raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_dwithin';


ALTER FUNCTION public._st_dwithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) OWNER TO postgres;

--
-- TOC entry 842 (class 1255 OID 30442)
-- Name: _st_dwithinuncached(geography, geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithinuncached(geography, geography, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithinUnCached($1, $2, $3, true)$_$;


ALTER FUNCTION public._st_dwithinuncached(geography, geography, double precision) OWNER TO postgres;

--
-- TOC entry 841 (class 1255 OID 30441)
-- Name: _st_dwithinuncached(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithinuncached(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_dwithin_uncached';


ALTER FUNCTION public._st_dwithinuncached(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 657 (class 1255 OID 30221)
-- Name: _st_equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_equals(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_Equals';


ALTER FUNCTION public._st_equals(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 832 (class 1255 OID 30432)
-- Name: _st_expand(geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_expand(geography, double precision) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_expand';


ALTER FUNCTION public._st_expand(geography, double precision) OWNER TO postgres;

--
-- TOC entry 1098 (class 1255 OID 30722)
-- Name: _st_gdalwarp(raster, text, double precision, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_gdalwarp(rast raster, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, srid integer DEFAULT NULL::integer, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, width integer DEFAULT NULL::integer, height integer DEFAULT NULL::integer) RETURNS raster
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_GDALWarp';


ALTER FUNCTION public._st_gdalwarp(rast raster, algorithm text, maxerr double precision, srid integer, scalex double precision, scaley double precision, gridx double precision, gridy double precision, skewx double precision, skewy double precision, width integer, height integer) OWNER TO postgres;

--
-- TOC entry 660 (class 1255 OID 30224)
-- Name: _st_geomfromgml(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_geomfromgml(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'geom_from_gml';


ALTER FUNCTION public._st_geomfromgml(text, integer) OWNER TO postgres;

--
-- TOC entry 1169 (class 1255 OID 30790)
-- Name: _st_hillshade4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_hillshade4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_pixwidth double precision;
		_pixheight double precision;
		_width double precision;
		_height double precision;
		_azimuth double precision;
		_altitude double precision;
		_bright double precision;
		_scale double precision;

		dz_dx double precision;
		dz_dy double precision;
		azimuth double precision;
		zenith double precision;
		slope double precision;
		aspect double precision;
		shade double precision;

		_value double precision[][][];
		ndims int;
		z int;
	BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
		END IF;

		IF array_length(userargs, 1) < 8 THEN
			RAISE EXCEPTION 'At least eight elements must be provided for the third parameter';
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		_pixwidth := userargs[1]::double precision;
		_pixheight := userargs[2]::double precision;
		_width := userargs[3]::double precision;
		_height := userargs[4]::double precision;
		_azimuth := userargs[5]::double precision;
		_altitude := userargs[6]::double precision;
		_bright := userargs[7]::double precision;
		_scale := userargs[8]::double precision;

		-- check that pixel is not edge pixel
		IF (pos[1][1] = 1 OR pos[1][2] = 1) OR (pos[1][1] = _width OR pos[1][2] = _height) THEN
			RETURN NULL;
		END IF;

		-- clamp azimuth
		IF _azimuth < 0. THEN
			RAISE NOTICE 'Clamping provided azimuth value % to 0', _azimuth;
			_azimuth := 0.;
		ELSEIF _azimuth >= 360. THEN
			RAISE NOTICE 'Converting provided azimuth value % to be between 0 and 360', _azimuth;
			_azimuth := _azimuth - (360. * floor(_azimuth / 360.));
		END IF;
		azimuth := 360. - _azimuth + 90.;
		IF azimuth >= 360. THEN
			azimuth := azimuth - 360.;
		END IF;
		azimuth := radians(azimuth);
		--RAISE NOTICE 'azimuth = %', azimuth;

		-- clamp altitude
		IF _altitude < 0. THEN
			RAISE NOTICE 'Clamping provided altitude value % to 0', _altitude;
			_altitude := 0.;
		ELSEIF _altitude > 90. THEN
			RAISE NOTICE 'Clamping provided altitude value % to 90', _altitude;
			_altitude := 90.;
		END IF;
		zenith := radians(90. - _altitude);
		--RAISE NOTICE 'zenith = %', zenith;

		-- clamp bright
		IF _bright < 0. THEN
			RAISE NOTICE 'Clamping provided bright value % to 0', _bright;
			_bright := 0.;
		ELSEIF _bright > 255. THEN
			RAISE NOTICE 'Clamping provided bright value % to 255', _bright;
			_bright := 255.;
		END IF;

		dz_dy := ((_value[z][3][1] + _value[z][3][2] + _value[z][3][2] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][1][2] + _value[z][1][2] + _value[z][1][3])) / (8 * _pixheight);
		dz_dx := ((_value[z][1][3] + _value[z][2][3] + _value[z][2][3] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][2][1] + _value[z][2][1] + _value[z][3][1])) / (8 * _pixwidth);

		slope := atan(sqrt(dz_dx * dz_dx + dz_dy * dz_dy) / _scale);

		IF dz_dx != 0. THEN
			aspect := atan2(dz_dy, -dz_dx);

			IF aspect < 0. THEN
				aspect := aspect + (2.0 * pi());
			END IF;
		ELSE
			IF dz_dy > 0. THEN
				aspect := pi() / 2.;
			ELSEIF dz_dy < 0. THEN
				aspect := (2. * pi()) - (pi() / 2.);
			-- set to pi as that is the expected PostgreSQL answer in Linux
			ELSE
				aspect := pi();
			END IF;
		END IF;

		shade := _bright * ((cos(zenith) * cos(slope)) + (sin(zenith) * sin(slope) * cos(azimuth - aspect)));

		IF shade < 0. THEN
			shade := 0;
		END IF;

		RETURN shade;
	END;
	$$;


ALTER FUNCTION public._st_hillshade4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 990 (class 1255 OID 30613)
-- Name: _st_histogram(text, text, integer, boolean, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_histogram(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_histogramCoverage';


ALTER FUNCTION public._st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 977 (class 1255 OID 30602)
-- Name: _st_histogram(raster, integer, boolean, double precision, integer, double precision[], boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_histogram(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, min double precision DEFAULT NULL::double precision, max double precision DEFAULT NULL::double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_histogram';


ALTER FUNCTION public._st_histogram(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, width double precision[], "right" boolean, min double precision, max double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 635 (class 1255 OID 30199)
-- Name: _st_intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_intersects(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'intersects';


ALTER FUNCTION public._st_intersects(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1275 (class 1255 OID 30932)
-- Name: _st_intersects(geometry, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_intersects(geom geometry, rast raster, nband integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE COST 1000
    AS $$
	DECLARE
		hasnodata boolean := TRUE;
		nodata float8 := 0.0;
		convexhull geometry;
		geomintersect geometry;
		x1w double precision := 0.0;
		x2w double precision := 0.0;
		y1w double precision := 0.0;
		y2w double precision := 0.0;
		x1 integer := 0;
		x2 integer := 0;
		x3 integer := 0;
		x4 integer := 0;
		y1 integer := 0;
		y2 integer := 0;
		y3 integer := 0;
		y4 integer := 0;
		x integer := 0;
		y integer := 0;
		xinc integer := 0;
		yinc integer := 0;
		pixelval double precision;
		bintersect boolean := FALSE;
		gtype text;
		scale float8;
		w int;
		h int;
	BEGIN
		IF ST_SRID(rast) != ST_SRID(geom) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
		END IF;

		convexhull := ST_ConvexHull(rast);
		IF nband IS NOT NULL THEN
			SELECT CASE WHEN bmd.nodatavalue IS NULL THEN FALSE ELSE NULL END INTO hasnodata FROM ST_BandMetaData(rast, nband) AS bmd;
		END IF;

		IF ST_Intersects(geom, convexhull) IS NOT TRUE THEN
			RETURN FALSE;
		ELSEIF nband IS NULL OR hasnodata IS FALSE THEN
			RETURN TRUE;
		END IF;

		-- Get the intersection between with the geometry.
		-- We will search for withvalue pixel only in this area.
		geomintersect := st_intersection(geom, convexhull);

--RAISE NOTICE 'geomintersect=%', st_astext(geomintersect);

		-- If the intersection is empty, return false
		IF st_isempty(geomintersect) THEN
			RETURN FALSE;
		END IF;

		-- We create a minimalistic buffer around the intersection in order to scan every pixels
		-- that would touch the edge or intersect with the geometry
		SELECT sqrt(scalex * scalex + skewy * skewy), width, height INTO scale, w, h FROM ST_Metadata(rast);
		IF scale != 0 THEN
			geomintersect := st_buffer(geomintersect, scale / 1000000);
		END IF;

--RAISE NOTICE 'geomintersect2=%', st_astext(geomintersect);

		-- Find the world coordinates of the bounding box of the intersecting area
		x1w := st_xmin(geomintersect);
		y1w := st_ymin(geomintersect);
		x2w := st_xmax(geomintersect);
		y2w := st_ymax(geomintersect);
		nodata := st_bandnodatavalue(rast, nband);

--RAISE NOTICE 'x1w=%, y1w=%, x2w=%, y2w=%', x1w, y1w, x2w, y2w;

		-- Convert world coordinates to raster coordinates
		x1 := st_worldtorastercoordx(rast, x1w, y1w);
		y1 := st_worldtorastercoordy(rast, x1w, y1w);
		x2 := st_worldtorastercoordx(rast, x2w, y1w);
		y2 := st_worldtorastercoordy(rast, x2w, y1w);
		x3 := st_worldtorastercoordx(rast, x1w, y2w);
		y3 := st_worldtorastercoordy(rast, x1w, y2w);
		x4 := st_worldtorastercoordx(rast, x2w, y2w);
		y4 := st_worldtorastercoordy(rast, x2w, y2w);

--RAISE NOTICE 'x1=%, y1=%, x2=%, y2=%, x3=%, y3=%, x4=%, y4=%', x1, y1, x2, y2, x3, y3, x4, y4;

		-- Order the raster coordinates for the upcoming FOR loop.
		x1 := int4smaller(int4smaller(int4smaller(x1, x2), x3), x4);
		y1 := int4smaller(int4smaller(int4smaller(y1, y2), y3), y4);
		x2 := int4larger(int4larger(int4larger(x1, x2), x3), x4);
		y2 := int4larger(int4larger(int4larger(y1, y2), y3), y4);

		-- Make sure the range is not lower than 1.
		-- This can happen when world coordinate are exactly on the left border
		-- of the raster and that they do not span on more than one pixel.
		x1 := int4smaller(int4larger(x1, 1), w);
		y1 := int4smaller(int4larger(y1, 1), h);

		-- Also make sure the range does not exceed the width and height of the raster.
		-- This can happen when world coordinate are exactly on the lower right border
		-- of the raster.
		x2 := int4smaller(x2, w);
		y2 := int4smaller(y2, h);

--RAISE NOTICE 'x1=%, y1=%, x2=%, y2=%', x1, y1, x2, y2;

		-- Search exhaustively for withvalue pixel on a moving 3x3 grid
		-- (very often more efficient than searching on a mere 1x1 grid)
		FOR xinc in 0..2 LOOP
			FOR yinc in 0..2 LOOP
				FOR x IN x1+xinc..x2 BY 3 LOOP
					FOR y IN y1+yinc..y2 BY 3 LOOP
						-- Check first if the pixel intersects with the geometry. Often many won't.
						bintersect := NOT st_isempty(st_intersection(st_pixelaspolygon(rast, x, y), geom));

						IF bintersect THEN
							-- If the pixel really intersects, check its value. Return TRUE if with value.
							pixelval := st_value(rast, nband, x, y);
							IF pixelval != nodata THEN
								RETURN TRUE;
							END IF;
						END IF;
					END LOOP;
				END LOOP;
			END LOOP;
		END LOOP;

		RETURN FALSE;
	END;
	$$;


ALTER FUNCTION public._st_intersects(geom geometry, rast raster, nband integer) OWNER TO postgres;

--
-- TOC entry 1272 (class 1255 OID 30929)
-- Name: _st_intersects(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_intersects(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_intersects';


ALTER FUNCTION public._st_intersects(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 590 (class 1255 OID 30140)
-- Name: _st_linecrossingdirection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_linecrossingdirection(geom1 geometry, geom2 geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_LineCrossingDirection';


ALTER FUNCTION public._st_linecrossingdirection(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 759 (class 1255 OID 30323)
-- Name: _st_longestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_longestline(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_longestline2d';


ALTER FUNCTION public._st_longestline(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1149 (class 1255 OID 30768)
-- Name: _st_mapalgebra(rastbandarg[], text, text, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_mapalgebra(rastbandargset rastbandarg[], expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_nMapAlgebraExpr';


ALTER FUNCTION public._st_mapalgebra(rastbandargset rastbandarg[], expression text, pixeltype text, extenttype text, nodata1expr text, nodata2expr text, nodatanodataval double precision) OWNER TO postgres;

--
-- TOC entry 1143 (class 1255 OID 30763)
-- Name: _st_mapalgebra(rastbandarg[], regprocedure, text, integer, integer, text, raster, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_mapalgebra(rastbandargset rastbandarg[], callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, distancex integer DEFAULT 0, distancey integer DEFAULT 0, extenttype text DEFAULT 'INTERSECTION'::text, customextent raster DEFAULT NULL::raster, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_nMapAlgebra';


ALTER FUNCTION public._st_mapalgebra(rastbandargset rastbandarg[], callbackfunc regprocedure, pixeltype text, distancex integer, distancey integer, extenttype text, customextent raster, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 755 (class 1255 OID 30319)
-- Name: _st_maxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_maxdistance(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_maxdistance2d_linestring';


ALTER FUNCTION public._st_maxdistance(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1331 (class 1255 OID 31002)
-- Name: _st_neighborhood(raster, integer, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_neighborhood(rast raster, band integer, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_neighborhood';


ALTER FUNCTION public._st_neighborhood(rast raster, band integer, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 894 (class 1255 OID 30501)
-- Name: _st_orderingequals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_orderingequals(geometrya geometry, geometryb geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_same';


ALTER FUNCTION public._st_orderingequals(geometrya geometry, geometryb geometry) OWNER TO postgres;

--
-- TOC entry 647 (class 1255 OID 30211)
-- Name: _st_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_overlaps(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'overlaps';


ALTER FUNCTION public._st_overlaps(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1279 (class 1255 OID 30937)
-- Name: _st_overlaps(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_overlaps(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_overlaps';


ALTER FUNCTION public._st_overlaps(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 1229 (class 1255 OID 30848)
-- Name: _st_pixelaspolygons(raster, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_pixelaspolygons(rast raster, band integer DEFAULT 1, columnx integer DEFAULT NULL::integer, rowy integer DEFAULT NULL::integer, exclude_nodata_value boolean DEFAULT true, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_getPixelPolygons';


ALTER FUNCTION public._st_pixelaspolygons(rast raster, band integer, columnx integer, rowy integer, exclude_nodata_value boolean, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 850 (class 1255 OID 30450)
-- Name: _st_pointoutside(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_pointoutside(geography) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_point_outside';


ALTER FUNCTION public._st_pointoutside(geography) OWNER TO postgres;

--
-- TOC entry 1000 (class 1255 OID 30624)
-- Name: _st_quantile(raster, integer, boolean, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_quantile(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_quantile';


ALTER FUNCTION public._st_quantile(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1016 (class 1255 OID 30641)
-- Name: _st_quantile(text, text, integer, boolean, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_quantile(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_quantileCoverage';


ALTER FUNCTION public._st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1243 (class 1255 OID 30864)
-- Name: _st_rastertoworldcoord(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_rastertoworldcoord(rast raster, columnx integer DEFAULT NULL::integer, rowy integer DEFAULT NULL::integer, OUT longitude double precision, OUT latitude double precision) RETURNS record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_rasterToWorldCoord';


ALTER FUNCTION public._st_rastertoworldcoord(rast raster, columnx integer, rowy integer, OUT longitude double precision, OUT latitude double precision) OWNER TO postgres;

--
-- TOC entry 1060 (class 1255 OID 30687)
-- Name: _st_reclass(raster, reclassarg[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_reclass(rast raster, VARIADIC reclassargset reclassarg[]) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_reclass';


ALTER FUNCTION public._st_reclass(rast raster, VARIADIC reclassargset reclassarg[]) OWNER TO postgres;

--
-- TOC entry 1176 (class 1255 OID 30795)
-- Name: _st_roughness4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_roughness4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		x integer;
		y integer;
		z integer;

		minimum double precision;
		maximum double precision;

		_value double precision[][][];
		ndims int;
	BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
		END IF;

		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
		ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
					END IF;
				END LOOP;
			END LOOP;
		END IF;

		minimum := _value[z][1][1];
		maximum := _value[z][1][1];

		FOR Y IN 1..3 LOOP
		    FOR X IN 1..3 LOOP
		    	 IF _value[z][y][x] < minimum THEN
			    minimum := _value[z][y][x];
			 ELSIF _value[z][y][x] > maximum THEN
			    maximum := _value[z][y][x];
			 END IF;
		    END LOOP;
		END LOOP;

		RETURN maximum - minimum;
	END;
	$$;


ALTER FUNCTION public._st_roughness4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1269 (class 1255 OID 30925)
-- Name: _st_samealignment_finalfn(agg_samealignment); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_samealignment_finalfn(agg agg_samealignment) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT $1.aligned $_$;


ALTER FUNCTION public._st_samealignment_finalfn(agg agg_samealignment) OWNER TO postgres;

--
-- TOC entry 1268 (class 1255 OID 30924)
-- Name: _st_samealignment_transfn(agg_samealignment, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_samealignment_transfn(agg agg_samealignment, rast raster) RETURNS agg_samealignment
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		m record;
		aligned boolean;
	BEGIN
		IF agg IS NULL THEN
			agg.refraster := NULL;
			agg.aligned := NULL;
		END IF;

		IF rast IS NULL THEN
			agg.aligned := NULL;
		ELSE
			IF agg.refraster IS NULL THEN
				m := ST_Metadata(rast);
				agg.refraster := ST_MakeEmptyRaster(1, 1, m.upperleftx, m.upperlefty, m.scalex, m.scaley, m.skewx, m.skewy, m.srid);
				agg.aligned := TRUE;
			ELSE IF agg.aligned IS TRUE THEN
					agg.aligned := ST_SameAlignment(agg.refraster, rast);
				END IF;
			END IF;
		END IF;
		RETURN agg;
	END;
	$$;


ALTER FUNCTION public._st_samealignment_transfn(agg agg_samealignment, rast raster) OWNER TO postgres;

--
-- TOC entry 1214 (class 1255 OID 30834)
-- Name: _st_setvalues(raster, integer, integer, integer, double precision[], boolean[], boolean, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], noset boolean[] DEFAULT NULL::boolean[], hasnosetvalue boolean DEFAULT false, nosetvalue double precision DEFAULT NULL::double precision, keepnodata boolean DEFAULT false) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_setPixelValuesArray';


ALTER FUNCTION public._st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], noset boolean[], hasnosetvalue boolean, nosetvalue double precision, keepnodata boolean) OWNER TO postgres;

--
-- TOC entry 1162 (class 1255 OID 30784)
-- Name: _st_slope4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_slope4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		x integer;
		y integer;
		z integer;

		_pixwidth double precision;
		_pixheight double precision;
		_width double precision;
		_height double precision;
		_units text;
		_scale double precision;

		dz_dx double precision;
		dz_dy double precision;

		slope double precision;

		_value double precision[][][];
		ndims int;
	BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
		END IF;

		IF array_length(userargs, 1) < 6 THEN
			RAISE EXCEPTION 'At least six elements must be provided for the third parameter';
		END IF;

		_pixwidth := userargs[1]::double precision;
		_pixheight := userargs[2]::double precision;
		_width := userargs[3]::double precision;
		_height := userargs[4]::double precision;
		_units := userargs[5];
		_scale := userargs[6]::double precision;

		
		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
		ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
					END IF;
				END LOOP;
			END LOOP;
		END IF;

		dz_dy := ((_value[z][3][1] + _value[z][3][2] + _value[z][3][2] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][1][2] + _value[z][1][2] + _value[z][1][3])) / _pixheight;
		dz_dx := ((_value[z][1][3] + _value[z][2][3] + _value[z][2][3] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][2][1] + _value[z][2][1] + _value[z][3][1])) / _pixwidth;

		slope := sqrt(dz_dx * dz_dx + dz_dy * dz_dy) / (8 * _scale);

		-- output depends on user preference
		CASE substring(upper(trim(leading from _units)) for 3)
			-- percentages
			WHEN 'PER' THEN
				slope := 100.0 * slope;
			-- radians
			WHEN 'rad' THEN
				slope := atan(slope);
			-- degrees (default)
			ELSE
				slope := degrees(atan(slope));
		END CASE;

		RETURN slope;
	END;
	$$;


ALTER FUNCTION public._st_slope4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 947 (class 1255 OID 30574)
-- Name: _st_summarystats(raster, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_summarystats(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_summaryStats';


ALTER FUNCTION public._st_summarystats(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 954 (class 1255 OID 30581)
-- Name: _st_summarystats(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_summarystats(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_summaryStatsCoverage';


ALTER FUNCTION public._st_summarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 1206 (class 1255 OID 30827)
-- Name: _st_tile(raster, integer, integer, integer[], boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_tile(rast raster, width integer, height integer, nband integer[] DEFAULT NULL::integer[], padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) RETURNS SETOF raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_tile';


ALTER FUNCTION public._st_tile(rast raster, width integer, height integer, nband integer[], padwithnodata boolean, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 631 (class 1255 OID 30195)
-- Name: _st_touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_touches(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'touches';


ALTER FUNCTION public._st_touches(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1282 (class 1255 OID 30940)
-- Name: _st_touches(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_touches(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 1000
    AS '$libdir/rtpostgis-2.1', 'RASTER_touches';


ALTER FUNCTION public._st_touches(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 1174 (class 1255 OID 30793)
-- Name: _st_tpi4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_tpi4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		x integer;
		y integer;
		z integer;

		Z1 double precision;
		Z2 double precision;
		Z3 double precision;
		Z4 double precision;
		Z5 double precision;
		Z6 double precision;
		Z7 double precision;
		Z8 double precision;
		Z9 double precision;

		tpi double precision;
		mean double precision;
		_value double precision[][][];
		ndims int;
	BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
		END IF;

		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
		ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
					END IF;
				END LOOP;
			END LOOP;
		END IF;

		-------------------------------------------------
		--|   Z1= Z(-1,1) |  Z2= Z(0,1)	| Z3= Z(1,1)  |--
		-------------------------------------------------
		--|   Z4= Z(-1,0) |  Z5= Z(0,0) | Z6= Z(1,0)  |--
		-------------------------------------------------
		--|   Z7= Z(-1,-1)|  Z8= Z(0,-1)|  Z9= Z(1,-1)|--
		-------------------------------------------------

		Z1 := _value[z][1][1];
		Z2 := _value[z][2][1];
		Z3 := _value[z][3][1];
		Z4 := _value[z][1][2];
		Z5 := _value[z][2][2];
		Z6 := _value[z][3][2];
		Z7 := _value[z][1][3];
		Z8 := _value[z][2][3];
		Z9 := _value[z][3][3];

		mean := (Z1 + Z2 + Z3 + Z4 + Z6 + Z7 + Z8 + Z9)/8;
		tpi := Z5-mean;
		
		return tpi;
	END;
	$$;


ALTER FUNCTION public._st_tpi4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1178 (class 1255 OID 30797)
-- Name: _st_tri4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_tri4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		x integer;
		y integer;
		z integer;

		Z1 double precision;
		Z2 double precision;
		Z3 double precision;
		Z4 double precision;
		Z5 double precision;
		Z6 double precision;
		Z7 double precision;
		Z8 double precision;
		Z9 double precision;

		tri double precision;
		_value double precision[][][];
		ndims int;
	BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
		END IF;

		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
		ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
					END IF;
				END LOOP;
			END LOOP;
		END IF;

		-------------------------------------------------
		--|   Z1= Z(-1,1) |  Z2= Z(0,1)	| Z3= Z(1,1)  |--
		-------------------------------------------------
		--|   Z4= Z(-1,0) |  Z5= Z(0,0) | Z6= Z(1,0)  |--
		-------------------------------------------------
		--|   Z7= Z(-1,-1)|  Z8= Z(0,-1)|  Z9= Z(1,-1)|--
		-------------------------------------------------

		-- _scale width and height units / z units to make z units equal to height width units
		Z1 := _value[z][1][1];
		Z2 := _value[z][2][1];
		Z3 := _value[z][3][1];
		Z4 := _value[z][1][2];
		Z5 := _value[z][2][2];
		Z6 := _value[z][3][2];
		Z7 := _value[z][1][3];
		Z8 := _value[z][2][3];
		Z9 := _value[z][3][3];

		tri := ( abs(Z1 - Z5 ) + abs( Z2 - Z5 ) + abs( Z3 - Z5 ) + abs( Z4 - Z5 ) + abs( Z6 - Z5 ) + abs( Z7 - Z5 ) + abs( Z8 - Z5 ) + abs ( Z9 - Z5 )) / 8;
		
		return tri;  
	END;
	$$;


ALTER FUNCTION public._st_tri4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1314 (class 1255 OID 30980)
-- Name: _st_union_finalfn(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_union_finalfn(internal) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_union_finalfn';


ALTER FUNCTION public._st_union_finalfn(internal) OWNER TO postgres;

--
-- TOC entry 1318 (class 1255 OID 30987)
-- Name: _st_union_transfn(internal, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_union_transfn(internal, raster) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_union_transfn';


ALTER FUNCTION public._st_union_transfn(internal, raster) OWNER TO postgres;

--
-- TOC entry 1317 (class 1255 OID 30985)
-- Name: _st_union_transfn(internal, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_union_transfn(internal, raster, integer) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_union_transfn';


ALTER FUNCTION public._st_union_transfn(internal, raster, integer) OWNER TO postgres;

--
-- TOC entry 1319 (class 1255 OID 30989)
-- Name: _st_union_transfn(internal, raster, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_union_transfn(internal, raster, text) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_union_transfn';


ALTER FUNCTION public._st_union_transfn(internal, raster, text) OWNER TO postgres;

--
-- TOC entry 1315 (class 1255 OID 30981)
-- Name: _st_union_transfn(internal, raster, unionarg[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_union_transfn(internal, raster, unionarg[]) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_union_transfn';


ALTER FUNCTION public._st_union_transfn(internal, raster, unionarg[]) OWNER TO postgres;

--
-- TOC entry 1316 (class 1255 OID 30983)
-- Name: _st_union_transfn(internal, raster, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_union_transfn(internal, raster, integer, text) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_union_transfn';


ALTER FUNCTION public._st_union_transfn(internal, raster, integer, text) OWNER TO postgres;

--
-- TOC entry 1031 (class 1255 OID 30658)
-- Name: _st_valuecount(raster, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_valuecount(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer, OUT percent double precision) RETURNS SETOF record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_valueCount';


ALTER FUNCTION public._st_valuecount(rast raster, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1047 (class 1255 OID 30671)
-- Name: _st_valuecount(text, text, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_valuecount(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer, OUT percent double precision) RETURNS SETOF record
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_valueCountCoverage';


ALTER FUNCTION public._st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 648 (class 1255 OID 30212)
-- Name: _st_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_within(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT _ST_Contains($2,$1)$_$;


ALTER FUNCTION public._st_within(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1294 (class 1255 OID 30955)
-- Name: _st_within(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_within(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT _st_contains($3, $4, $1, $2) $_$;


ALTER FUNCTION public._st_within(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 1236 (class 1255 OID 30855)
-- Name: _st_worldtorastercoord(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_worldtorastercoord(rast raster, longitude double precision DEFAULT NULL::double precision, latitude double precision DEFAULT NULL::double precision, OUT columnx integer, OUT rowy integer) RETURNS record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_worldToRasterCoord';


ALTER FUNCTION public._st_worldtorastercoord(rast raster, longitude double precision, latitude double precision, OUT columnx integer, OUT rowy integer) OWNER TO postgres;

--
-- TOC entry 1392 (class 1255 OID 31073)
-- Name: _updaterastersrid(name, name, name, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		fqtn text;
		schema name;
		sql text;
		srid integer;
		ct boolean;
	BEGIN
		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		-- clamp SRID
		IF new_srid < 0 THEN
			srid := ST_SRID('POINT EMPTY'::geometry);
			RAISE NOTICE 'SRID % converted to the officially unknown SRID %', new_srid, srid;
		ELSE
			srid := new_srid;
		END IF;

		-- drop coverage tile constraint
		-- done separately just in case constraint doesn't exist
		ct := _raster_constraint_info_coverage_tile(schema, $2, $3);
		IF ct IS TRUE THEN
			PERFORM _drop_raster_constraint_coverage_tile(schema, $2, $3);
		END IF;

		-- drop SRID, extent, alignment constraints
		PERFORM DropRasterConstraints(schema, $2, $3, 'extent', 'alignment', 'srid');

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		-- update SRID
		sql := 'UPDATE ' || fqtn ||
			' SET ' || quote_ident($3) ||
			' = ST_SetSRID(' || quote_ident($3) ||
			'::raster, ' || srid || ')';
		RAISE NOTICE 'sql = %', sql;
		EXECUTE sql;

		-- add SRID constraint
		PERFORM AddRasterConstraints(schema, $2, $3, 'srid', 'extent', 'alignment');

		-- add coverage tile constraint if needed
		IF ct IS TRUE THEN
			PERFORM _add_raster_constraint_coverage_tile(schema, $2, $3);
		END IF;

		RETURN TRUE;
	END;
	$_$;


ALTER FUNCTION public._updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) OWNER TO postgres;

--
-- TOC entry 771 (class 1255 OID 30335)
-- Name: addauth(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addauth(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP; 
	IF (okay <> 't') THEN 
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;
$_$;


ALTER FUNCTION public.addauth(text) OWNER TO postgres;

--
-- TOC entry 530 (class 1255 OID 30068)
-- Name: addgeometrycolumn(character varying, character varying, integer, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) OWNER TO postgres;

--
-- TOC entry 529 (class 1255 OID 30067)
-- Name: addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) OWNER TO postgres;

--
-- TOC entry 528 (class 1255 OID 30065)
-- Name: addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name "%(%)" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
		END IF;
		new_srid := new_srid_in;
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
			RETURN 'fail';
		END IF;
	ELSE
		new_srid := ST_SRID('POINT EMPTY'::geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	IF use_typmod THEN
	     sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry(' || postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
        RAISE DEBUG '%', sql;
	ELSE
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry ';
        RAISE DEBUG '%', sql;
    END IF;
	EXECUTE sql;

	IF NOT use_typmod THEN
        -- Add table CHECKs
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_srid_' || column_name)
            || ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_dims_' || column_name)
            || ' CHECK (st_ndims(' || quote_ident(column_name) ||
            ') = ' || new_dim::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        IF ( NOT (new_type = 'GEOMETRY')) THEN
            sql := 'ALTER TABLE ' ||
                quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
                quote_ident('enforce_geotype_' || column_name) ||
                ' CHECK (GeometryType(' ||
                quote_ident(column_name) || ')=' ||
                quote_literal(new_type) || ' OR (' ||
                quote_ident(column_name) || ') is null)';
            RAISE DEBUG '%', sql;
            EXECUTE sql;
        END IF;
    END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$$;


ALTER FUNCTION public.addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean) OWNER TO postgres;

--
-- TOC entry 1389 (class 1255 OID 31070)
-- Name: addoverviewconstraints(name, name, name, name, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addoverviewconstraints(ovtable name, ovcolumn name, reftable name, refcolumn name, ovfactor integer) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT AddOverviewConstraints('', $1, $2, '', $3, $4, $5) $_$;


ALTER FUNCTION public.addoverviewconstraints(ovtable name, ovcolumn name, reftable name, refcolumn name, ovfactor integer) OWNER TO postgres;

--
-- TOC entry 1388 (class 1255 OID 31069)
-- Name: addoverviewconstraints(name, name, name, name, name, name, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addoverviewconstraints(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, ovfactor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		x int;
		s name;
		t name;
		oschema name;
		rschema name;
		sql text;
		rtn boolean;
	BEGIN
		FOR x IN 1..2 LOOP
			s := '';

			IF x = 1 THEN
				s := $1;
				t := $2;
			ELSE
				s := $4;
				t := $5;
			END IF;

			-- validate user-provided schema
			IF length(s) > 0 THEN
				sql := 'SELECT nspname FROM pg_namespace '
					|| 'WHERE nspname = ' || quote_literal(s)
					|| 'LIMIT 1';
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The value % is not a valid schema', quote_literal(s);
					RETURN FALSE;
				END IF;
			END IF;

			-- no schema, determine what it could be using the table
			IF length(s) < 1 THEN
				sql := 'SELECT n.nspname AS schemaname '
					|| 'FROM pg_catalog.pg_class c '
					|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
					|| 'WHERE c.relkind = ' || quote_literal('r')
					|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
					|| ', ' || quote_literal('pg_toast')
					|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
					|| ' AND c.relname = ' || quote_literal(t);
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal(t);
					RETURN FALSE;
				END IF;
			END IF;

			IF x = 1 THEN
				oschema := s;
			ELSE
				rschema := s;
			END IF;
		END LOOP;

		-- reference raster
		rtn := _add_overview_constraint(oschema, $2, $3, rschema, $5, $6, $7);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to add the overview constraint.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;


ALTER FUNCTION public.addoverviewconstraints(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, ovfactor integer) OWNER TO postgres;

--
-- TOC entry 1377 (class 1255 OID 31048)
-- Name: addrasterconstraints(name, name, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addrasterconstraints(rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT AddRasterConstraints('', $1, $2, VARIADIC $3) $_$;


ALTER FUNCTION public.addrasterconstraints(rasttable name, rastcolumn name, VARIADIC constraints text[]) OWNER TO postgres;

--
-- TOC entry 1376 (class 1255 OID 31047)
-- Name: addrasterconstraints(name, name, name, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		cnt int;
		sql text;
		schema name;
		x int;
		kw text;
		rtn boolean;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be added.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Adding SRID constraint';
						rtn := _add_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Adding alignment constraint';
						rtn := _add_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Adding coverage tile constraint required for regular blocking';
						rtn := _add_raster_constraint_coverage_tile(schema, $2, $3);
						IF rtn IS NOT FALSE THEN
							RAISE NOTICE 'Adding spatially unique constraint required for regular blocking';
							rtn := _add_raster_constraint_spatially_unique(schema, $2, $3);
						END IF;
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Adding number of bands constraint';
						rtn := _add_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Adding pixel type constraint';
						rtn := _add_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Adding nodata value constraint';
						rtn := _add_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Adding out-of-database constraint';
						rtn := _add_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Adding maximum extent constraint';
						rtn := _add_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to add constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be added.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;


ALTER FUNCTION public.addrasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) OWNER TO postgres;

--
-- TOC entry 1380 (class 1255 OID 31050)
-- Name: addrasterconstraints(name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addrasterconstraints(rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT AddRasterConstraints('', $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) $_$;


ALTER FUNCTION public.addrasterconstraints(rasttable name, rastcolumn name, srid boolean, scale_x boolean, scale_y boolean, blocksize_x boolean, blocksize_y boolean, same_alignment boolean, regular_blocking boolean, num_bands boolean, pixel_types boolean, nodata_values boolean, out_db boolean, extent boolean) OWNER TO postgres;

--
-- TOC entry 1379 (class 1255 OID 31049)
-- Name: addrasterconstraints(name, name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN AddRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;


ALTER FUNCTION public.addrasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean, scale_x boolean, scale_y boolean, blocksize_x boolean, blocksize_y boolean, same_alignment boolean, regular_blocking boolean, num_bands boolean, pixel_types boolean, nodata_values boolean, out_db boolean, extent boolean) OWNER TO postgres;

--
-- TOC entry 560 (class 1255 OID 30098)
-- Name: box(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box(box3d) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_to_BOX';


ALTER FUNCTION public.box(box3d) OWNER TO postgres;

--
-- TOC entry 557 (class 1255 OID 30095)
-- Name: box(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box(geometry) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_BOX';


ALTER FUNCTION public.box(geometry) OWNER TO postgres;

--
-- TOC entry 558 (class 1255 OID 30096)
-- Name: box2d(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d(box3d) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_to_BOX2D';


ALTER FUNCTION public.box2d(box3d) OWNER TO postgres;

--
-- TOC entry 555 (class 1255 OID 30093)
-- Name: box2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_BOX2D';


ALTER FUNCTION public.box2d(geometry) OWNER TO postgres;

--
-- TOC entry 559 (class 1255 OID 30097)
-- Name: box3d(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d(box2d) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX2D_to_BOX3D';


ALTER FUNCTION public.box3d(box2d) OWNER TO postgres;

--
-- TOC entry 556 (class 1255 OID 30094)
-- Name: box3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d(geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_BOX3D';


ALTER FUNCTION public.box3d(geometry) OWNER TO postgres;

--
-- TOC entry 916 (class 1255 OID 30540)
-- Name: box3d(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d(raster) RETURNS box3d
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select box3d(st_convexhull($1))$_$;


ALTER FUNCTION public.box3d(raster) OWNER TO postgres;

--
-- TOC entry 562 (class 1255 OID 30100)
-- Name: box3dtobox(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3dtobox(box3d) RETURNS box
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT box($1)$_$;


ALTER FUNCTION public.box3dtobox(box3d) OWNER TO postgres;

--
-- TOC entry 788 (class 1255 OID 30355)
-- Name: bytea(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bytea(geography) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_bytea';


ALTER FUNCTION public.bytea(geography) OWNER TO postgres;

--
-- TOC entry 567 (class 1255 OID 30105)
-- Name: bytea(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bytea(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_bytea';


ALTER FUNCTION public.bytea(geometry) OWNER TO postgres;

--
-- TOC entry 1251 (class 1255 OID 30872)
-- Name: bytea(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bytea(raster) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_to_bytea';


ALTER FUNCTION public.bytea(raster) OWNER TO postgres;

--
-- TOC entry 773 (class 1255 OID 30337)
-- Name: checkauth(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkauth(text, text) RETURNS integer
    LANGUAGE sql
    AS $_$ SELECT CheckAuth('', $1, $2) $_$;


ALTER FUNCTION public.checkauth(text, text) OWNER TO postgres;

--
-- TOC entry 772 (class 1255 OID 30336)
-- Name: checkauth(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkauth(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON ' 
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;
$_$;


ALTER FUNCTION public.checkauth(text, text, text) OWNER TO postgres;

--
-- TOC entry 774 (class 1255 OID 30338)
-- Name: checkauthtrigger(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkauthtrigger() RETURNS trigger
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'check_authorization';


ALTER FUNCTION public.checkauthtrigger() OWNER TO postgres;

--
-- TOC entry 1485 (class 1255 OID 31240)
-- Name: cristal_forecast(integer, real, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION cristal_forecast(integer, real, real) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;

		the_geom geometry;
BEGIN

	select into the_geom 
ST_GeomFromText('POLYGON((' || st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ',' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd - amp) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd -amp) * pi()/180.) * ftime  * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd + amp) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd + amp) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || '))', 23032)
FROM
  realtime.g_dbstorm
WHERE
  g_dbstorm.gid2 = gid;

return the_geom;

END;
$_$;


ALTER FUNCTION public.cristal_forecast(integer, real, real) OWNER TO postgres;

--
-- TOC entry 5009 (class 0 OID 0)
-- Dependencies: 1485
-- Name: FUNCTION cristal_forecast(integer, real, real); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION cristal_forecast(integer, real, real) IS 'Updated on 19th Oct 2011';


--
-- TOC entry 778 (class 1255 OID 30342)
-- Name: disablelongtransactions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION disablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;
$$;


ALTER FUNCTION public.disablelongtransactions() OWNER TO postgres;

--
-- TOC entry 534 (class 1255 OID 30071)
-- Name: dropgeometrycolumn(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrycolumn(table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.dropgeometrycolumn(table_name character varying, column_name character varying) OWNER TO postgres;

--
-- TOC entry 533 (class 1255 OID 30070)
-- Name: dropgeometrycolumn(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) OWNER TO postgres;

--
-- TOC entry 532 (class 1255 OID 30069)
-- Name: dropgeometrycolumn(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <>  true ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = false;
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (okay <> true) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$$;


ALTER FUNCTION public.dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) OWNER TO postgres;

--
-- TOC entry 537 (class 1255 OID 30074)
-- Name: dropgeometrytable(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrytable(table_name character varying) RETURNS text
    LANGUAGE sql STRICT
    AS $_$ SELECT DropGeometryTable('','',$1) $_$;


ALTER FUNCTION public.dropgeometrytable(table_name character varying) OWNER TO postgres;

--
-- TOC entry 536 (class 1255 OID 30073)
-- Name: dropgeometrytable(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrytable(schema_name character varying, table_name character varying) RETURNS text
    LANGUAGE sql STRICT
    AS $_$ SELECT DropGeometryTable('',$1,$2) $_$;


ALTER FUNCTION public.dropgeometrytable(schema_name character varying, table_name character varying) OWNER TO postgres;

--
-- TOC entry 535 (class 1255 OID 30072)
-- Name: dropgeometrytable(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
	EXECUTE 'DROP TABLE IF EXISTS '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' RESTRICT';

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$$;


ALTER FUNCTION public.dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) OWNER TO postgres;

--
-- TOC entry 1391 (class 1255 OID 31072)
-- Name: dropoverviewconstraints(name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropoverviewconstraints(ovtable name, ovcolumn name) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT DropOverviewConstraints('', $1, $2) $_$;


ALTER FUNCTION public.dropoverviewconstraints(ovtable name, ovcolumn name) OWNER TO postgres;

--
-- TOC entry 1390 (class 1255 OID 31071)
-- Name: dropoverviewconstraints(name, name, name); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropoverviewconstraints(ovschema name, ovtable name, ovcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		schema name;
		sql text;
		rtn boolean;
	BEGIN
		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		rtn := _drop_overview_constraint(schema, $2, $3);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to drop the overview constraint .  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;


ALTER FUNCTION public.dropoverviewconstraints(ovschema name, ovtable name, ovcolumn name) OWNER TO postgres;

--
-- TOC entry 1382 (class 1255 OID 31052)
-- Name: droprasterconstraints(name, name, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION droprasterconstraints(rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT DropRasterConstraints('', $1, $2, VARIADIC $3) $_$;


ALTER FUNCTION public.droprasterconstraints(rasttable name, rastcolumn name, VARIADIC constraints text[]) OWNER TO postgres;

--
-- TOC entry 1381 (class 1255 OID 31051)
-- Name: droprasterconstraints(name, name, name, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		x int;
		schema name;
		sql text;
		kw text;
		rtn boolean;
		cnt int;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be dropped.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Dropping SRID constraint';
						rtn := _drop_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Dropping alignment constraint';
						rtn := _drop_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						rtn := _drop_raster_constraint_regular_blocking(schema, $2, $3);

						RAISE NOTICE 'Dropping coverage tile constraint required for regular blocking';
						rtn := _drop_raster_constraint_coverage_tile(schema, $2, $3);

						IF rtn IS NOT FALSE THEN
							RAISE NOTICE 'Dropping spatially unique constraint required for regular blocking';
							rtn := _drop_raster_constraint_spatially_unique(schema, $2, $3);
						END IF;
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Dropping number of bands constraint';
						rtn := _drop_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Dropping pixel type constraint';
						rtn := _drop_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Dropping nodata value constraint';
						rtn := _drop_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Dropping out-of-database constraint';
						rtn := _drop_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Dropping maximum extent constraint';
						rtn := _drop_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to drop constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be dropped.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;


ALTER FUNCTION public.droprasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) OWNER TO postgres;

--
-- TOC entry 1384 (class 1255 OID 31054)
-- Name: droprasterconstraints(name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION droprasterconstraints(rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT DropRasterConstraints('', $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) $_$;


ALTER FUNCTION public.droprasterconstraints(rasttable name, rastcolumn name, srid boolean, scale_x boolean, scale_y boolean, blocksize_x boolean, blocksize_y boolean, same_alignment boolean, regular_blocking boolean, num_bands boolean, pixel_types boolean, nodata_values boolean, out_db boolean, extent boolean) OWNER TO postgres;

--
-- TOC entry 1383 (class 1255 OID 31053)
-- Name: droprasterconstraints(name, name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN DropRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;


ALTER FUNCTION public.droprasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean, scale_x boolean, scale_y boolean, blocksize_x boolean, blocksize_y boolean, same_alignment boolean, regular_blocking boolean, num_bands boolean, pixel_types boolean, nodata_values boolean, out_db boolean, extent boolean) OWNER TO postgres;

--
-- TOC entry 1486 (class 1255 OID 31241)
-- Name: ellipse(double precision, double precision, double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ellipse(double precision, double precision, double precision, double precision, double precision, integer) RETURNS geometry
    LANGUAGE sql
    AS $_$
   SELECT ST_Translate( ST_Rotate( ST_Scale( ST_Buffer(ST_Point(0,0), 0.5, $6), $3, $4), $5), $1, $2)
$_$;


ALTER FUNCTION public.ellipse(double precision, double precision, double precision, double precision, double precision, integer) OWNER TO postgres;

--
-- TOC entry 776 (class 1255 OID 30340)
-- Name: enablelongtransactions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION enablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;
$$;


ALTER FUNCTION public.enablelongtransactions() OWNER TO postgres;

--
-- TOC entry 659 (class 1255 OID 30223)
-- Name: equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION equals(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_Equals';


ALTER FUNCTION public.equals(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 541 (class 1255 OID 30078)
-- Name: find_srid(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem varchar =  $1;
	tabl varchar = $2;
	sr int4;
BEGIN
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and strpos(tabl,'.') > 0 ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	END IF;

	select SRID into sr from geometry_columns where (f_table_schema = schem or schem = '') and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;


ALTER FUNCTION public.find_srid(character varying, character varying, character varying) OWNER TO postgres;

--
-- TOC entry 787 (class 1255 OID 30354)
-- Name: geography(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography(bytea) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_from_binary';


ALTER FUNCTION public.geography(bytea) OWNER TO postgres;

--
-- TOC entry 797 (class 1255 OID 30371)
-- Name: geography(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography(geometry) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_from_geometry';


ALTER FUNCTION public.geography(geometry) OWNER TO postgres;

--
-- TOC entry 786 (class 1255 OID 30352)
-- Name: geography(geography, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography(geography, integer, boolean) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_enforce_typmod';


ALTER FUNCTION public.geography(geography, integer, boolean) OWNER TO postgres;

--
-- TOC entry 812 (class 1255 OID 30399)
-- Name: geography_cmp(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_cmp(geography, geography) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_cmp';


ALTER FUNCTION public.geography_cmp(geography, geography) OWNER TO postgres;

--
-- TOC entry 811 (class 1255 OID 30398)
-- Name: geography_eq(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_eq(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_eq';


ALTER FUNCTION public.geography_eq(geography, geography) OWNER TO postgres;

--
-- TOC entry 810 (class 1255 OID 30397)
-- Name: geography_ge(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_ge(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_ge';


ALTER FUNCTION public.geography_ge(geography, geography) OWNER TO postgres;

--
-- TOC entry 800 (class 1255 OID 30376)
-- Name: geography_gist_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_compress';


ALTER FUNCTION public.geography_gist_compress(internal) OWNER TO postgres;

--
-- TOC entry 799 (class 1255 OID 30375)
-- Name: geography_gist_consistent(internal, geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_consistent(internal, geography, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_consistent';


ALTER FUNCTION public.geography_gist_consistent(internal, geography, integer) OWNER TO postgres;

--
-- TOC entry 805 (class 1255 OID 30381)
-- Name: geography_gist_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_decompress';


ALTER FUNCTION public.geography_gist_decompress(internal) OWNER TO postgres;

--
-- TOC entry 801 (class 1255 OID 30377)
-- Name: geography_gist_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_penalty';


ALTER FUNCTION public.geography_gist_penalty(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 802 (class 1255 OID 30378)
-- Name: geography_gist_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_picksplit';


ALTER FUNCTION public.geography_gist_picksplit(internal, internal) OWNER TO postgres;

--
-- TOC entry 804 (class 1255 OID 30380)
-- Name: geography_gist_same(box2d, box2d, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_same(box2d, box2d, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_same';


ALTER FUNCTION public.geography_gist_same(box2d, box2d, internal) OWNER TO postgres;

--
-- TOC entry 803 (class 1255 OID 30379)
-- Name: geography_gist_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_union(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_union';


ALTER FUNCTION public.geography_gist_union(bytea, internal) OWNER TO postgres;

--
-- TOC entry 809 (class 1255 OID 30396)
-- Name: geography_gt(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gt(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_gt';


ALTER FUNCTION public.geography_gt(geography, geography) OWNER TO postgres;

--
-- TOC entry 808 (class 1255 OID 30395)
-- Name: geography_le(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_le(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_le';


ALTER FUNCTION public.geography_le(geography, geography) OWNER TO postgres;

--
-- TOC entry 807 (class 1255 OID 30394)
-- Name: geography_lt(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_lt(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_lt';


ALTER FUNCTION public.geography_lt(geography, geography) OWNER TO postgres;

--
-- TOC entry 806 (class 1255 OID 30382)
-- Name: geography_overlaps(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_overlaps(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overlaps';


ALTER FUNCTION public.geography_overlaps(geography, geography) OWNER TO postgres;

--
-- TOC entry 566 (class 1255 OID 30104)
-- Name: geometry(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_bytea';


ALTER FUNCTION public.geometry(bytea) OWNER TO postgres;

--
-- TOC entry 362 (class 1255 OID 29804)
-- Name: geometry(path); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(path) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'path_to_geometry';


ALTER FUNCTION public.geometry(path) OWNER TO postgres;

--
-- TOC entry 360 (class 1255 OID 29802)
-- Name: geometry(point); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(point) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'point_to_geometry';


ALTER FUNCTION public.geometry(point) OWNER TO postgres;

--
-- TOC entry 364 (class 1255 OID 29806)
-- Name: geometry(polygon); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(polygon) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'polygon_to_geometry';


ALTER FUNCTION public.geometry(polygon) OWNER TO postgres;

--
-- TOC entry 565 (class 1255 OID 30103)
-- Name: geometry(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'parse_WKT_lwgeom';


ALTER FUNCTION public.geometry(text) OWNER TO postgres;

--
-- TOC entry 563 (class 1255 OID 30101)
-- Name: geometry(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(box2d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX2D_to_LWGEOM';


ALTER FUNCTION public.geometry(box2d) OWNER TO postgres;

--
-- TOC entry 564 (class 1255 OID 30102)
-- Name: geometry(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(box3d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_to_LWGEOM';


ALTER FUNCTION public.geometry(box3d) OWNER TO postgres;

--
-- TOC entry 798 (class 1255 OID 30373)
-- Name: geometry(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(geography) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_from_geography';


ALTER FUNCTION public.geometry(geography) OWNER TO postgres;

--
-- TOC entry 359 (class 1255 OID 29800)
-- Name: geometry(geometry, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(geometry, integer, boolean) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_enforce_typmod';


ALTER FUNCTION public.geometry(geometry, integer, boolean) OWNER TO postgres;

--
-- TOC entry 411 (class 1255 OID 29895)
-- Name: geometry_above(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_above(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_above_2d';


ALTER FUNCTION public.geometry_above(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 406 (class 1255 OID 29886)
-- Name: geometry_below(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_below(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_below_2d';


ALTER FUNCTION public.geometry_below(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 382 (class 1255 OID 29839)
-- Name: geometry_cmp(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_cmp(geom1 geometry, geom2 geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'lwgeom_cmp';


ALTER FUNCTION public.geometry_cmp(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1056 (class 1255 OID 30899)
-- Name: geometry_contained_by_raster(geometry, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_contained_by_raster(geometry, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1 @ $2::geometry$_$;


ALTER FUNCTION public.geometry_contained_by_raster(geometry, raster) OWNER TO postgres;

--
-- TOC entry 402 (class 1255 OID 29876)
-- Name: geometry_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_contains(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_contains_2d';


ALTER FUNCTION public.geometry_contains(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 401 (class 1255 OID 29873)
-- Name: geometry_distance_box(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_distance_box(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_distance_box_2d';


ALTER FUNCTION public.geometry_distance_box(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 400 (class 1255 OID 29872)
-- Name: geometry_distance_centroid(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_distance_centroid(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_distance_centroid_2d';


ALTER FUNCTION public.geometry_distance_centroid(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 381 (class 1255 OID 29838)
-- Name: geometry_eq(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_eq(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'lwgeom_eq';


ALTER FUNCTION public.geometry_eq(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 380 (class 1255 OID 29837)
-- Name: geometry_ge(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_ge(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'lwgeom_ge';


ALTER FUNCTION public.geometry_ge(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 385 (class 1255 OID 29855)
-- Name: geometry_gist_compress_2d(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_compress_2d(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_compress_2d';


ALTER FUNCTION public.geometry_gist_compress_2d(internal) OWNER TO postgres;

--
-- TOC entry 344 (class 1255 OID 29921)
-- Name: geometry_gist_compress_nd(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_compress_nd(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_compress';


ALTER FUNCTION public.geometry_gist_compress_nd(internal) OWNER TO postgres;

--
-- TOC entry 384 (class 1255 OID 29854)
-- Name: geometry_gist_consistent_2d(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_consistent_2d(internal, geometry, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_consistent_2d';


ALTER FUNCTION public.geometry_gist_consistent_2d(internal, geometry, integer) OWNER TO postgres;

--
-- TOC entry 343 (class 1255 OID 29920)
-- Name: geometry_gist_consistent_nd(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_consistent_nd(internal, geometry, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_consistent';


ALTER FUNCTION public.geometry_gist_consistent_nd(internal, geometry, integer) OWNER TO postgres;

--
-- TOC entry 390 (class 1255 OID 29860)
-- Name: geometry_gist_decompress_2d(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_decompress_2d(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_decompress_2d';


ALTER FUNCTION public.geometry_gist_decompress_2d(internal) OWNER TO postgres;

--
-- TOC entry 413 (class 1255 OID 29926)
-- Name: geometry_gist_decompress_nd(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_decompress_nd(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_decompress';


ALTER FUNCTION public.geometry_gist_decompress_nd(internal) OWNER TO postgres;

--
-- TOC entry 383 (class 1255 OID 29853)
-- Name: geometry_gist_distance_2d(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_distance_2d(internal, geometry, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_distance_2d';


ALTER FUNCTION public.geometry_gist_distance_2d(internal, geometry, integer) OWNER TO postgres;

--
-- TOC entry 386 (class 1255 OID 29856)
-- Name: geometry_gist_penalty_2d(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_penalty_2d(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_penalty_2d';


ALTER FUNCTION public.geometry_gist_penalty_2d(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 345 (class 1255 OID 29922)
-- Name: geometry_gist_penalty_nd(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_penalty_nd(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_penalty';


ALTER FUNCTION public.geometry_gist_penalty_nd(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 387 (class 1255 OID 29857)
-- Name: geometry_gist_picksplit_2d(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_picksplit_2d(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_picksplit_2d';


ALTER FUNCTION public.geometry_gist_picksplit_2d(internal, internal) OWNER TO postgres;

--
-- TOC entry 346 (class 1255 OID 29923)
-- Name: geometry_gist_picksplit_nd(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_picksplit_nd(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_picksplit';


ALTER FUNCTION public.geometry_gist_picksplit_nd(internal, internal) OWNER TO postgres;

--
-- TOC entry 389 (class 1255 OID 29859)
-- Name: geometry_gist_same_2d(geometry, geometry, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_same_2d(geom1 geometry, geom2 geometry, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_same_2d';


ALTER FUNCTION public.geometry_gist_same_2d(geom1 geometry, geom2 geometry, internal) OWNER TO postgres;

--
-- TOC entry 412 (class 1255 OID 29925)
-- Name: geometry_gist_same_nd(geometry, geometry, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_same_nd(geometry, geometry, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_same';


ALTER FUNCTION public.geometry_gist_same_nd(geometry, geometry, internal) OWNER TO postgres;

--
-- TOC entry 388 (class 1255 OID 29858)
-- Name: geometry_gist_union_2d(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_union_2d(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_union_2d';


ALTER FUNCTION public.geometry_gist_union_2d(bytea, internal) OWNER TO postgres;

--
-- TOC entry 347 (class 1255 OID 29924)
-- Name: geometry_gist_union_nd(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_union_nd(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_union';


ALTER FUNCTION public.geometry_gist_union_nd(bytea, internal) OWNER TO postgres;

--
-- TOC entry 379 (class 1255 OID 29836)
-- Name: geometry_gt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gt(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'lwgeom_gt';


ALTER FUNCTION public.geometry_gt(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 378 (class 1255 OID 29835)
-- Name: geometry_le(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_le(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'lwgeom_le';


ALTER FUNCTION public.geometry_le(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 404 (class 1255 OID 29880)
-- Name: geometry_left(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_left(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_left_2d';


ALTER FUNCTION public.geometry_left(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 377 (class 1255 OID 29834)
-- Name: geometry_lt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_lt(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'lwgeom_lt';


ALTER FUNCTION public.geometry_lt(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 410 (class 1255 OID 29894)
-- Name: geometry_overabove(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overabove(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overabove_2d';


ALTER FUNCTION public.geometry_overabove(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 407 (class 1255 OID 29889)
-- Name: geometry_overbelow(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overbelow(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overbelow_2d';


ALTER FUNCTION public.geometry_overbelow(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 398 (class 1255 OID 29868)
-- Name: geometry_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overlaps(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overlaps_2d';


ALTER FUNCTION public.geometry_overlaps(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 414 (class 1255 OID 29927)
-- Name: geometry_overlaps_nd(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overlaps_nd(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overlaps';


ALTER FUNCTION public.geometry_overlaps_nd(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 405 (class 1255 OID 29883)
-- Name: geometry_overleft(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overleft(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overleft_2d';


ALTER FUNCTION public.geometry_overleft(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 408 (class 1255 OID 29892)
-- Name: geometry_overright(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overright(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_overright_2d';


ALTER FUNCTION public.geometry_overright(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1046 (class 1255 OID 30898)
-- Name: geometry_raster_contain(geometry, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_raster_contain(geometry, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1 ~ $2::geometry$_$;


ALTER FUNCTION public.geometry_raster_contain(geometry, raster) OWNER TO postgres;

--
-- TOC entry 1070 (class 1255 OID 30900)
-- Name: geometry_raster_overlap(geometry, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_raster_overlap(geometry, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1 && $2::geometry$_$;


ALTER FUNCTION public.geometry_raster_overlap(geometry, raster) OWNER TO postgres;

--
-- TOC entry 409 (class 1255 OID 29893)
-- Name: geometry_right(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_right(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_right_2d';


ALTER FUNCTION public.geometry_right(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 399 (class 1255 OID 29870)
-- Name: geometry_same(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_same(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_same_2d';


ALTER FUNCTION public.geometry_same(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 403 (class 1255 OID 29877)
-- Name: geometry_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_within(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'gserialized_within_2d';


ALTER FUNCTION public.geometry_within(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 869 (class 1255 OID 30469)
-- Name: geometrytype(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometrytype(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_getTYPE';


ALTER FUNCTION public.geometrytype(geography) OWNER TO postgres;

--
-- TOC entry 690 (class 1255 OID 30254)
-- Name: geometrytype(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometrytype(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_getTYPE';


ALTER FUNCTION public.geometrytype(geometry) OWNER TO postgres;

--
-- TOC entry 499 (class 1255 OID 30023)
-- Name: geomfromewkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromewkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOMFromWKB';


ALTER FUNCTION public.geomfromewkb(bytea) OWNER TO postgres;

--
-- TOC entry 501 (class 1255 OID 30025)
-- Name: geomfromewkt(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromewkt(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'parse_WKT_lwgeom';


ALTER FUNCTION public.geomfromewkt(text) OWNER TO postgres;

--
-- TOC entry 542 (class 1255 OID 30079)
-- Name: get_proj4_from_srid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;


ALTER FUNCTION public.get_proj4_from_srid(integer) OWNER TO postgres;

--
-- TOC entry 775 (class 1255 OID 30339)
-- Name: gettransactionid(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gettransactionid() RETURNS xid
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'getTransactionID';


ALTER FUNCTION public.gettransactionid() OWNER TO postgres;

--
-- TOC entry 396 (class 1255 OID 29866)
-- Name: gserialized_gist_joinsel_2d(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gserialized_gist_joinsel_2d(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_joinsel_2d';


ALTER FUNCTION public.gserialized_gist_joinsel_2d(internal, oid, internal, smallint) OWNER TO postgres;

--
-- TOC entry 397 (class 1255 OID 29867)
-- Name: gserialized_gist_joinsel_nd(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gserialized_gist_joinsel_nd(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_joinsel_nd';


ALTER FUNCTION public.gserialized_gist_joinsel_nd(internal, oid, internal, smallint) OWNER TO postgres;

--
-- TOC entry 394 (class 1255 OID 29864)
-- Name: gserialized_gist_sel_2d(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gserialized_gist_sel_2d(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_sel_2d';


ALTER FUNCTION public.gserialized_gist_sel_2d(internal, oid, internal, integer) OWNER TO postgres;

--
-- TOC entry 395 (class 1255 OID 29865)
-- Name: gserialized_gist_sel_nd(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gserialized_gist_sel_nd(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'gserialized_gist_sel_nd';


ALTER FUNCTION public.gserialized_gist_sel_nd(internal, oid, internal, integer) OWNER TO postgres;

--
-- TOC entry 331 (class 1255 OID 29751)
-- Name: install_rcmd(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION install_rcmd(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/plr', 'install_rcmd';


ALTER FUNCTION public.install_rcmd(text) OWNER TO postgres;

--
-- TOC entry 337 (class 1255 OID 29763)
-- Name: load_r_typenames(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION load_r_typenames() RETURNS text
    LANGUAGE plr
    AS $$
  sql <- "select upper(typname::text) || 'OID' as typename, oid from pg_catalog.pg_type where typtype = 'b' order by typname"
  rs <- pg.spi.exec(sql)
  for(i in 1:nrow(rs))
  {
    typobj <- rs[i,1]
    typval <- rs[i,2]
    if (substr(typobj,1,1) == "_")
      typobj <- paste("ARRAYOF", substr(typobj,2,nchar(typobj)), sep="")
    assign(typobj, typval, .GlobalEnv)
  }
  return("OK")
$$;


ALTER FUNCTION public.load_r_typenames() OWNER TO postgres;

--
-- TOC entry 769 (class 1255 OID 30333)
-- Name: lockrow(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $_$;


ALTER FUNCTION public.lockrow(text, text, text) OWNER TO postgres;

--
-- TOC entry 768 (class 1255 OID 30332)
-- Name: lockrow(text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $_$;


ALTER FUNCTION public.lockrow(text, text, text, text) OWNER TO postgres;

--
-- TOC entry 770 (class 1255 OID 30334)
-- Name: lockrow(text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $_$;


ALTER FUNCTION public.lockrow(text, text, text, timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 767 (class 1255 OID 30331)
-- Name: lockrow(text, text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;
	
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires < now()'; 

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE 
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


ALTER FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 777 (class 1255 OID 30341)
-- Name: longtransactionsenabled(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;


ALTER FUNCTION public.longtransactionsenabled() OWNER TO postgres;

--
-- TOC entry 363 (class 1255 OID 29805)
-- Name: path(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION path(geometry) RETURNS path
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_to_path';


ALTER FUNCTION public.path(geometry) OWNER TO postgres;

--
-- TOC entry 621 (class 1255 OID 30180)
-- Name: pgis_geometry_accum_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_accum_finalfn(pgis_abs) RETURNS geometry[]
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'pgis_geometry_accum_finalfn';


ALTER FUNCTION public.pgis_geometry_accum_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 620 (class 1255 OID 30179)
-- Name: pgis_geometry_accum_transfn(pgis_abs, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_accum_transfn(pgis_abs, geometry) RETURNS pgis_abs
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'pgis_geometry_accum_transfn';


ALTER FUNCTION public.pgis_geometry_accum_transfn(pgis_abs, geometry) OWNER TO postgres;

--
-- TOC entry 623 (class 1255 OID 30182)
-- Name: pgis_geometry_collect_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_collect_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'pgis_geometry_collect_finalfn';


ALTER FUNCTION public.pgis_geometry_collect_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 625 (class 1255 OID 30184)
-- Name: pgis_geometry_makeline_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_makeline_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'pgis_geometry_makeline_finalfn';


ALTER FUNCTION public.pgis_geometry_makeline_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 624 (class 1255 OID 30183)
-- Name: pgis_geometry_polygonize_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_polygonize_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'pgis_geometry_polygonize_finalfn';


ALTER FUNCTION public.pgis_geometry_polygonize_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 622 (class 1255 OID 30181)
-- Name: pgis_geometry_union_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_union_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'pgis_geometry_union_finalfn';


ALTER FUNCTION public.pgis_geometry_union_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 334 (class 1255 OID 29754)
-- Name: plr_array_accum(double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_array_accum(double precision[], double precision) RETURNS double precision[]
    LANGUAGE c
    AS '$libdir/plr', 'plr_array_accum';


ALTER FUNCTION public.plr_array_accum(double precision[], double precision) OWNER TO postgres;

--
-- TOC entry 333 (class 1255 OID 29753)
-- Name: plr_array_push(double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_array_push(double precision[], double precision) RETURNS double precision[]
    LANGUAGE c STRICT
    AS '$libdir/plr', 'plr_array_push';


ALTER FUNCTION public.plr_array_push(double precision[], double precision) OWNER TO postgres;

--
-- TOC entry 335 (class 1255 OID 29758)
-- Name: plr_environ(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_environ() RETURNS SETOF plr_environ_type
    LANGUAGE c
    AS '$libdir/plr', 'plr_environ';


ALTER FUNCTION public.plr_environ() OWNER TO postgres;

--
-- TOC entry 342 (class 1255 OID 29771)
-- Name: plr_get_raw(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_get_raw(bytea) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/plr', 'plr_get_raw';


ALTER FUNCTION public.plr_get_raw(bytea) OWNER TO postgres;

--
-- TOC entry 341 (class 1255 OID 29770)
-- Name: plr_set_display(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_set_display(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/plr', 'plr_set_display';


ALTER FUNCTION public.plr_set_display(text) OWNER TO postgres;

--
-- TOC entry 339 (class 1255 OID 29768)
-- Name: plr_set_rhome(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_set_rhome(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/plr', 'plr_set_rhome';


ALTER FUNCTION public.plr_set_rhome(text) OWNER TO postgres;

--
-- TOC entry 332 (class 1255 OID 29752)
-- Name: plr_singleton_array(double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_singleton_array(double precision) RETURNS double precision[]
    LANGUAGE c STRICT
    AS '$libdir/plr', 'plr_array';


ALTER FUNCTION public.plr_singleton_array(double precision) OWNER TO postgres;

--
-- TOC entry 340 (class 1255 OID 29769)
-- Name: plr_unset_rhome(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_unset_rhome() RETURNS text
    LANGUAGE c
    AS '$libdir/plr', 'plr_unset_rhome';


ALTER FUNCTION public.plr_unset_rhome() OWNER TO postgres;

--
-- TOC entry 323 (class 1255 OID 29749)
-- Name: plr_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plr_version() RETURNS text
    LANGUAGE c
    AS '$libdir/plr', 'plr_version';


ALTER FUNCTION public.plr_version() OWNER TO postgres;

--
-- TOC entry 361 (class 1255 OID 29803)
-- Name: point(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION point(geometry) RETURNS point
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_to_point';


ALTER FUNCTION public.point(geometry) OWNER TO postgres;

--
-- TOC entry 365 (class 1255 OID 29807)
-- Name: polygon(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polygon(geometry) RETURNS polygon
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_to_polygon';


ALTER FUNCTION public.polygon(geometry) OWNER TO postgres;

--
-- TOC entry 526 (class 1255 OID 30062)
-- Name: populate_geometry_columns(boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION populate_geometry_columns(use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM geometry_columns;
	inserted := 0;

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE (c.relkind = 'r' OR c.relkind = 'v')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' ;

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' 
	LOOP

		inserted := inserted + populate_geometry_columns(gcs.oid, use_typmod);
	END LOOP;

	IF oldcount > inserted THEN
	    stale = oldcount-inserted;
	ELSE
	    stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted;
END

$$;


ALTER FUNCTION public.populate_geometry_columns(use_typmod boolean) OWNER TO postgres;

--
-- TOC entry 527 (class 1255 OID 30063)
-- Name: populate_geometry_columns(oid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION populate_geometry_columns(tbl_oid oid, use_typmod boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	gcs         RECORD;
	gc          RECORD;
	gc_old      RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;
	inserted    integer;
	constraint_successful boolean := false;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

        RAISE DEBUG 'Processing column %.%.%', gcs.nspname, gcs.relname, gcs.attname;
    
        gc_is_valid := true;
        -- Find the srid, coord_dimension, and type of current geometry
        -- in geometry_columns -- which is now a view
        
        SELECT type, srid, coord_dimension INTO gc_old 
            FROM geometry_columns 
            WHERE f_table_schema = gcs.nspname AND f_table_name = gcs.relname AND f_geometry_column = gcs.attname; 
            
        IF upper(gc_old.type) = 'GEOMETRY' THEN
        -- This is an unconstrained geometry we need to do something
        -- We need to figure out what to set the type by inspecting the data
            EXECUTE 'SELECT st_srid(' || quote_ident(gcs.attname) || ') As srid, GeometryType(' || quote_ident(gcs.attname) || ') As type, ST_NDims(' || quote_ident(gcs.attname) || ') As dims ' ||
                     ' FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || 
                     ' WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1;'
                INTO gc;
            IF gc IS NULL THEN -- there is no data so we can not determine geometry type
            	RAISE WARNING 'No data in table %.%, so no information to determine geometry type and srid', gcs.nspname, gcs.relname;
            	RETURN 0;
            END IF;
            gsrid := gc.srid; gtype := gc.type; gndims := gc.dims;
            	
            IF use_typmod THEN
                BEGIN
                    EXECUTE 'ALTER TABLE ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || ' ALTER COLUMN ' || quote_ident(gcs.attname) || 
                        ' TYPE geometry(' || postgis_type_name(gtype, gndims, true) || ', ' || gsrid::text  || ') ';
                    inserted := inserted + 1;
                EXCEPTION
                        WHEN invalid_parameter_value OR feature_not_supported THEN
                        RAISE WARNING 'Could not convert ''%'' in ''%.%'' to use typmod with srid %, type %: %', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), gsrid, postgis_type_name(gtype, gndims, true), SQLERRM;
                            gc_is_valid := false;
                END;
                
            ELSE
                -- Try to apply srid check to column
            	constraint_successful = false;
                IF (gsrid > 0 AND postgis_constraint_srid(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
                    BEGIN
                        EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || 
                                 ' ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) || 
                                 ' CHECK (st_srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
                        constraint_successful := true;
                    EXCEPTION
                        WHEN check_violation THEN
                            RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
                            gc_is_valid := false;
                    END;
                END IF;
                
                -- Try to apply ndims check to column
                IF (gndims IS NOT NULL AND postgis_constraint_dims(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
                    BEGIN
                        EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
                                 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
                                 CHECK (st_ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
                        constraint_successful := true;
                    EXCEPTION
                        WHEN check_violation THEN
                            RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
                            gc_is_valid := false;
                    END;
                END IF;
    
                -- Try to apply geometrytype check to column
                IF (gtype IS NOT NULL AND postgis_constraint_type(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
                    BEGIN
                        EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
                        ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
                        CHECK ((geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ') OR (' || quote_ident(gcs.attname) || ' IS NULL))';
                        constraint_successful := true;
                    EXCEPTION
                        WHEN check_violation THEN
                            -- No geometry check can be applied. This column contains a number of geometry types.
                            RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
                    END;
                END IF;
                 --only count if we were successful in applying at least one constraint
                IF constraint_successful THEN
                	inserted := inserted + 1;
                END IF;
            END IF;	        
	    END IF;

	END LOOP;

	RETURN inserted;
END

$$;


ALTER FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean) OWNER TO postgres;

--
-- TOC entry 446 (class 1255 OID 29969)
-- Name: postgis_addbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_addbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_addBBOX';


ALTER FUNCTION public.postgis_addbbox(geometry) OWNER TO postgres;

--
-- TOC entry 503 (class 1255 OID 30027)
-- Name: postgis_cache_bbox(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_cache_bbox() RETURNS trigger
    LANGUAGE c
    AS '$libdir/postgis-2.1', 'cache_bbox';


ALTER FUNCTION public.postgis_cache_bbox() OWNER TO postgres;

--
-- TOC entry 875 (class 1255 OID 30475)
-- Name: postgis_constraint_dims(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
SELECT  replace(split_part(s.consrc, ' = ', 2), ')', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %';
$_$;


ALTER FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) OWNER TO postgres;

--
-- TOC entry 874 (class 1255 OID 30474)
-- Name: postgis_constraint_srid(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %';
$_$;


ALTER FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) OWNER TO postgres;

--
-- TOC entry 876 (class 1255 OID 30476)
-- Name: postgis_constraint_type(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) RETURNS character varying
    LANGUAGE sql STABLE STRICT
    AS $_$
SELECT  replace(split_part(s.consrc, '''', 2), ')', '')::varchar		
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %';
$_$;


ALTER FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) OWNER TO postgres;

--
-- TOC entry 447 (class 1255 OID 29970)
-- Name: postgis_dropbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_dropbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_dropBBOX';


ALTER FUNCTION public.postgis_dropbbox(geometry) OWNER TO postgres;

--
-- TOC entry 554 (class 1255 OID 30092)
-- Name: postgis_full_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	svnver text;
	projver text;
	geosver text;
	sfcgalver text;
	cgalver text;
	gdalver text;
	libxmlver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text;
	rast_scr_ver text;
	topo_scr_ver text;
	json_lib_ver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libjson_version() INTO json_lib_ver;
	BEGIN
		SELECT postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			gdalver := NULL;
			RAISE NOTICE 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	BEGIN
		SELECT postgis_sfcgal_version() INTO sfcgalver;
	EXCEPTION
		WHEN undefined_function THEN
			sfcgalver := NULL;
	END;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;
	select postgis_svn_version() INTO svnver;
	BEGIN
		SELECT topology.postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function OR invalid_schema_name THEN
			topo_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
		WHEN insufficient_privilege THEN
			RAISE NOTICE 'Topology support cannot be inspected. Is current user granted USAGE on schema "topology" ?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_topology_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_lib_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	fullver = 'POSTGIS="' || libver;

	IF  svnver IS NOT NULL THEN
		fullver = fullver || ' r' || svnver;
	END IF;

	fullver = fullver || '"';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
	END IF;

	IF  sfcgalver IS NOT NULL THEN
		fullver = fullver || ' SFCGAL="' || sfcgalver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL="' || gdalver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON="' || json_lib_ver || '"';
	END IF;

	-- fullver = fullver || ' DBPROC="' || dbproc || '"';
	-- fullver = fullver || ' RELPROC="' || relproc || '"';

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from "' || dbproc || '" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from "' || topo_scr_ver || '" need upgrade)';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from "' || rast_lib_ver || '" need upgrade)';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from "' || rast_scr_ver || '" need upgrade)';
	END IF;

	RETURN fullver;
END
$$;


ALTER FUNCTION public.postgis_full_version() OWNER TO postgres;

--
-- TOC entry 913 (class 1255 OID 30531)
-- Name: postgis_gdal_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_gdal_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_gdal_version';


ALTER FUNCTION public.postgis_gdal_version() OWNER TO postgres;

--
-- TOC entry 549 (class 1255 OID 30087)
-- Name: postgis_geos_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_geos_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_geos_version';


ALTER FUNCTION public.postgis_geos_version() OWNER TO postgres;

--
-- TOC entry 436 (class 1255 OID 29960)
-- Name: postgis_getbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_getbbox(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_BOX2D';


ALTER FUNCTION public.postgis_getbbox(geometry) OWNER TO postgres;

--
-- TOC entry 448 (class 1255 OID 29971)
-- Name: postgis_hasbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_hasbbox(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_hasBBOX';


ALTER FUNCTION public.postgis_hasbbox(geometry) OWNER TO postgres;

--
-- TOC entry 553 (class 1255 OID 30091)
-- Name: postgis_lib_build_date(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_lib_build_date() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_lib_build_date';


ALTER FUNCTION public.postgis_lib_build_date() OWNER TO postgres;

--
-- TOC entry 548 (class 1255 OID 30085)
-- Name: postgis_lib_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_lib_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_lib_version';


ALTER FUNCTION public.postgis_lib_version() OWNER TO postgres;

--
-- TOC entry 667 (class 1255 OID 30231)
-- Name: postgis_libjson_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_libjson_version() RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'postgis_libjson_version';


ALTER FUNCTION public.postgis_libjson_version() OWNER TO postgres;

--
-- TOC entry 551 (class 1255 OID 30089)
-- Name: postgis_libxml_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_libxml_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_libxml_version';


ALTER FUNCTION public.postgis_libxml_version() OWNER TO postgres;

--
-- TOC entry 489 (class 1255 OID 30013)
-- Name: postgis_noop(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_noop(geometry) RETURNS geometry
    LANGUAGE c STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_noop';


ALTER FUNCTION public.postgis_noop(geometry) OWNER TO postgres;

--
-- TOC entry 546 (class 1255 OID 30083)
-- Name: postgis_proj_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_proj_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_proj_version';


ALTER FUNCTION public.postgis_proj_version() OWNER TO postgres;

--
-- TOC entry 912 (class 1255 OID 30530)
-- Name: postgis_raster_lib_build_date(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_raster_lib_build_date() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_lib_build_date';


ALTER FUNCTION public.postgis_raster_lib_build_date() OWNER TO postgres;

--
-- TOC entry 910 (class 1255 OID 30528)
-- Name: postgis_raster_lib_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_raster_lib_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_lib_version';


ALTER FUNCTION public.postgis_raster_lib_version() OWNER TO postgres;

--
-- TOC entry 911 (class 1255 OID 30529)
-- Name: postgis_raster_scripts_installed(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_raster_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT '2.1.8'::text || ' r' || 13780::text AS version $$;


ALTER FUNCTION public.postgis_raster_scripts_installed() OWNER TO postgres;

--
-- TOC entry 552 (class 1255 OID 30090)
-- Name: postgis_scripts_build_date(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_scripts_build_date() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$SELECT '2015-07-11 13:37:31'::text AS version$$;


ALTER FUNCTION public.postgis_scripts_build_date() OWNER TO postgres;

--
-- TOC entry 547 (class 1255 OID 30084)
-- Name: postgis_scripts_installed(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT '2.1.8'::text || ' r' || 13780::text AS version $$;


ALTER FUNCTION public.postgis_scripts_installed() OWNER TO postgres;

--
-- TOC entry 531 (class 1255 OID 30086)
-- Name: postgis_scripts_released(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_scripts_released() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_scripts_released';


ALTER FUNCTION public.postgis_scripts_released() OWNER TO postgres;

--
-- TOC entry 550 (class 1255 OID 30088)
-- Name: postgis_svn_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_svn_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_svn_version';


ALTER FUNCTION public.postgis_svn_version() OWNER TO postgres;

--
-- TOC entry 543 (class 1255 OID 30080)
-- Name: postgis_transform_geometry(geometry, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_transform_geometry(geometry, text, text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'transform_geom';


ALTER FUNCTION public.postgis_transform_geometry(geometry, text, text, integer) OWNER TO postgres;

--
-- TOC entry 873 (class 1255 OID 30473)
-- Name: postgis_type_name(character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true) RETURNS character varying
    LANGUAGE sql IMMUTABLE STRICT COST 200
    AS $_$
 SELECT CASE WHEN $3 THEN new_name ELSE old_name END As geomname
 	FROM 
 	( VALUES
 		 ('GEOMETRY', 'Geometry', 2) ,
 		 	('GEOMETRY', 'GeometryZ', 3) ,
 		 	('GEOMETRY', 'GeometryZM', 4) ,
			('GEOMETRYCOLLECTION', 'GeometryCollection', 2) ,
			('GEOMETRYCOLLECTION', 'GeometryCollectionZ', 3) ,
			('GEOMETRYCOLLECTIONM', 'GeometryCollectionM', 3) ,
			('GEOMETRYCOLLECTION', 'GeometryCollectionZM', 4) ,
			
			('POINT', 'Point',2) ,
			('POINTM','PointM',3) ,
			('POINT', 'PointZ',3) ,
			('POINT', 'PointZM',4) ,
			
			('MULTIPOINT','MultiPoint',2) ,
			('MULTIPOINT','MultiPointZ',3) ,
			('MULTIPOINTM','MultiPointM',3) ,
			('MULTIPOINT','MultiPointZM',4) ,
			
			('POLYGON', 'Polygon',2) ,
			('POLYGON', 'PolygonZ',3) ,
			('POLYGONM', 'PolygonM',3) ,
			('POLYGON', 'PolygonZM',4) ,
			
			('MULTIPOLYGON', 'MultiPolygon',2) ,
			('MULTIPOLYGON', 'MultiPolygonZ',3) ,
			('MULTIPOLYGONM', 'MultiPolygonM',3) ,
			('MULTIPOLYGON', 'MultiPolygonZM',4) ,
			
			('MULTILINESTRING', 'MultiLineString',2) ,
			('MULTILINESTRING', 'MultiLineStringZ',3) ,
			('MULTILINESTRINGM', 'MultiLineStringM',3) ,
			('MULTILINESTRING', 'MultiLineStringZM',4) ,
			
			('LINESTRING', 'LineString',2) ,
			('LINESTRING', 'LineStringZ',3) ,
			('LINESTRINGM', 'LineStringM',3) ,
			('LINESTRING', 'LineStringZM',4) ,
			
			('CIRCULARSTRING', 'CircularString',2) ,
			('CIRCULARSTRING', 'CircularStringZ',3) ,
			('CIRCULARSTRINGM', 'CircularStringM',3) ,
			('CIRCULARSTRING', 'CircularStringZM',4) ,
			
			('COMPOUNDCURVE', 'CompoundCurve',2) ,
			('COMPOUNDCURVE', 'CompoundCurveZ',3) ,
			('COMPOUNDCURVEM', 'CompoundCurveM',3) ,
			('COMPOUNDCURVE', 'CompoundCurveZM',4) ,
			
			('CURVEPOLYGON', 'CurvePolygon',2) ,
			('CURVEPOLYGON', 'CurvePolygonZ',3) ,
			('CURVEPOLYGONM', 'CurvePolygonM',3) ,
			('CURVEPOLYGON', 'CurvePolygonZM',4) ,
			
			('MULTICURVE', 'MultiCurve',2 ) ,
			('MULTICURVE', 'MultiCurveZ',3 ) ,
			('MULTICURVEM', 'MultiCurveM',3 ) ,
			('MULTICURVE', 'MultiCurveZM',4 ) ,
			
			('MULTISURFACE', 'MultiSurface', 2) ,
			('MULTISURFACE', 'MultiSurfaceZ', 3) ,
			('MULTISURFACEM', 'MultiSurfaceM', 3) ,
			('MULTISURFACE', 'MultiSurfaceZM', 4) ,
			
			('POLYHEDRALSURFACE', 'PolyhedralSurface',2) ,
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZ',3) ,
			('POLYHEDRALSURFACEM', 'PolyhedralSurfaceM',3) ,
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZM',4) ,
			
			('TRIANGLE', 'Triangle',2) ,
			('TRIANGLE', 'TriangleZ',3) ,
			('TRIANGLEM', 'TriangleM',3) ,
			('TRIANGLE', 'TriangleZM',4) ,

			('TIN', 'Tin', 2),
			('TIN', 'TinZ', 3),
			('TIN', 'TinM', 3),
			('TIN', 'TinZM', 4) )
			 As g(old_name, new_name, coord_dimension)
		WHERE (upper(old_name) = upper($1) OR upper(new_name) = upper($1))
			AND coord_dimension = $2;
$_$;


ALTER FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean) OWNER TO postgres;

--
-- TOC entry 794 (class 1255 OID 30363)
-- Name: postgis_typmod_dims(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_typmod_dims(integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'postgis_typmod_dims';


ALTER FUNCTION public.postgis_typmod_dims(integer) OWNER TO postgres;

--
-- TOC entry 795 (class 1255 OID 30364)
-- Name: postgis_typmod_srid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_typmod_srid(integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'postgis_typmod_srid';


ALTER FUNCTION public.postgis_typmod_srid(integer) OWNER TO postgres;

--
-- TOC entry 796 (class 1255 OID 30365)
-- Name: postgis_typmod_type(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_typmod_type(integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'postgis_typmod_type';


ALTER FUNCTION public.postgis_typmod_type(integer) OWNER TO postgres;

--
-- TOC entry 545 (class 1255 OID 30082)
-- Name: postgis_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'postgis_version';


ALTER FUNCTION public.postgis_version() OWNER TO postgres;

--
-- TOC entry 1487 (class 1255 OID 31242)
-- Name: r_plotpie_stab(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION r_plotpie_stab() RETURNS text
    LANGUAGE plr
    AS $_$
require(rgdal)
require(mapplots)


dsn="PG:host=localhost dbname=iris_base"
stab<-readOGR(dsn, "ri0307.v_stabilimenti_pivot")

centroids<-coordinates(stab)
#Numero di poligoni:
n_polygons <- length(stab@polygons)
j=1
while (j<=n_polygons) {
#estensione <- bbox(stab@polygons[[j]])
#Di ogni poligono correggo il centroide spostandolo piu in basso:
#correzione_y <- (bbox(stab@polygons[[j]])[2,2]-bbox(stab@polygons[[j]])[2,1])*0.1
#centroids[j,2] <- centroids[j,2] - correzione_y
if (as.character(stab@data$provincia[j]) == 'VC') { #sposto solo il pie di VC che rompe le palle
centroids[j,2] <- 5020000
centroids[j,1] <- 445000
}
j <- j + 1
}

#Trasformiamo i valori da Levels a numerico:
#stab@data$cod_a=as.numeric(levels(stab@data$cod_a))[stab@data$cod_a]
#stab@data$cod_b=as.numeric(levels(stab@data$cod_b))[stab@data$cod_b]
#Creo un altro campo per le etichette sui grafici a torta, toglieno gli ZERI:
stab@data$label_a = stab@data$cod_a
stab@data$label_a[stab@data$label_a==0] = NA
stab@data$label_b = stab@data$cod_b
stab@data$label_b[stab@data$label_b==0] = NA

#Ora definiamo una matrice colori in base al numero di stabilimenti totali per provincia:
min=c(1,6,11,21)
max=c(5,10,20,29)
colori=c('#FFFFDD', '#20B2AA', 'orange', 'brown')
labels=paste(min[], "-", max[], sep="")
palette_stab = data.frame(min, max, colori, labels)

#Creiamo un campo COLOUR nel dataframe con un valore di default:
stab@data$COLOUR <- "#FFFFFF"
stab@data$COLOUR[(stab@data$cod_a+stab@data$cod_b) > palette_stab[1,2]] <- as.character(palette_stab[2,3])
stab@data$COLOUR[(stab@data$cod_a+stab@data$cod_b) > palette_stab[2,2]] <- as.character(palette_stab[3,3])
stab@data$COLOUR[(stab@data$cod_a+stab@data$cod_b) > palette_stab[3,2]] <- as.character(palette_stab[4,3])

#Palette per i grafici a torta:
codici = c("Art. 6", "Art. 8")
col_pie = c("cyan", "purple")
pal_pie = data.frame(codici, col_pie)

#Esporto il risultato in un file immagine:
png("/var/www/html/common/DATA/rir/plot_pie-rir.png", 1152, 1638)
#pdf_name <- "/var/www/html/common/DATA/rir/plot_pie-rir.pdf"
#pdf(file=pdf_name, paper="a4", width=8, height=11)
plot(stab, col=stab@data$COLOUR)
i=1
while (i<=length(stab)) {
#per PDF devi mettere cex=1
add.pie(z=c(stab@data$cod_a[i], stab@data$cod_b[i]), x=centroids[i,][1], y=centroids[i,][2], radius=7000
, col=as.character(pal_pie[,2]), labels=c(stab@data$label_a[i], stab@data$cod_b[i]), label.dist = 1.2, cex=2) #label.dist: piazza le etichette ad una distanza dal pie, ma anche se interne fa casini comunque
i <- i + 1
}

#Per cambiare impostazione in italiano:
Sys.setlocale("LC_TIME", "it_IT.UTF-8")
mese <- format(Sys.time(), "%B %Y")
dati_agg <- paste("- dati ", mese, " -", sep="")
#per PDF:
#title(main="Stabilimenti a rischio di incidente rilevante", cex.main=2, font.main=4)
#mtext(dati_agg, cex=1.5)
#per PNG:
title(main="Stabilimenti a rischio di incidente rilevante", cex.main=2.5, font.main=4)
mtext(dati_agg, cex=2, line=-2)

#originariamente X=275000 per plot diretto; X=350000 per plot in PNG 800x1160; X=300000 per pdf a4 8x11
#legend(310000, 5110000, inset=.1, title="Numero stabilimenti", as.character(palette_stab[,4]), fill=as.character(palette_stab[,3]), bty="n", cex=1.4)
#legend(310000, 5150000, title="Adempimenti ex \nD.Lgs 334/99 e s.m.i.", as.character(pal_pie[,1]), fill=as.character(pal_pie[,2]), bty="n", cex=1.4)
#per PNG:
legend(340000, 5110000, inset=.1, title="Numero stabilimenti", as.character(palette_stab[,4]), fill=as.character(palette_stab[,3]), bty="n", cex=2)
legend(340000, 5150000, title="Adempimenti ex \nD.Lgs 334/99 e s.m.i.", as.character(pal_pie[,1]), fill=as.character(pal_pie[,2]), bty="n", cex=2)

dev.off() 
print("done")
$_$;


ALTER FUNCTION public.r_plotpie_stab() OWNER TO postgres;

--
-- TOC entry 1482 (class 1255 OID 31244)
-- Name: r_quantile(double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION r_quantile(double precision[]) RETURNS double precision
    LANGUAGE plr
    AS $$
    quantile(arg1, probs = 0.9, names = FALSE)
$$;


ALTER FUNCTION public.r_quantile(double precision[]) OWNER TO postgres;

--
-- TOC entry 336 (class 1255 OID 29762)
-- Name: r_typenames(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION r_typenames() RETURNS SETOF r_typename
    LANGUAGE plr
    AS $$
  x <- ls(name = .GlobalEnv, pat = "OID")
  y <- vector()
  for (i in 1:length(x)) {y[i] <- eval(parse(text = x[i]))}
  data.frame(typename = x, typeoid = y)
$$;


ALTER FUNCTION public.r_typenames() OWNER TO postgres;

--
-- TOC entry 338 (class 1255 OID 29767)
-- Name: r_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION r_version() RETURNS SETOF r_version_type
    LANGUAGE plr
    AS $$
  cbind(names(version),unlist(version))
$$;


ALTER FUNCTION public.r_version() OWNER TO postgres;

--
-- TOC entry 1260 (class 1255 OID 30889)
-- Name: raster_above(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_above(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry |>> $2::geometry$_$;


ALTER FUNCTION public.raster_above(raster, raster) OWNER TO postgres;

--
-- TOC entry 1261 (class 1255 OID 30890)
-- Name: raster_below(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_below(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry <<| $2::geometry$_$;


ALTER FUNCTION public.raster_below(raster, raster) OWNER TO postgres;

--
-- TOC entry 1264 (class 1255 OID 30893)
-- Name: raster_contain(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_contain(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry ~ $2::geometry$_$;


ALTER FUNCTION public.raster_contain(raster, raster) OWNER TO postgres;

--
-- TOC entry 1263 (class 1255 OID 30892)
-- Name: raster_contained(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_contained(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry @ $2::geometry$_$;


ALTER FUNCTION public.raster_contained(raster, raster) OWNER TO postgres;

--
-- TOC entry 883 (class 1255 OID 30896)
-- Name: raster_contained_by_geometry(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_contained_by_geometry(raster, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry @ $2$_$;


ALTER FUNCTION public.raster_contained_by_geometry(raster, geometry) OWNER TO postgres;

--
-- TOC entry 1253 (class 1255 OID 30877)
-- Name: raster_eq(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_eq(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT raster_hash($1) = raster_hash($2) $_$;


ALTER FUNCTION public.raster_eq(raster, raster) OWNER TO postgres;

--
-- TOC entry 1266 (class 1255 OID 30895)
-- Name: raster_geometry_contain(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_geometry_contain(raster, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry ~ $2$_$;


ALTER FUNCTION public.raster_geometry_contain(raster, geometry) OWNER TO postgres;

--
-- TOC entry 1034 (class 1255 OID 30897)
-- Name: raster_geometry_overlap(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_geometry_overlap(raster, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry && $2$_$;


ALTER FUNCTION public.raster_geometry_overlap(raster, geometry) OWNER TO postgres;

--
-- TOC entry 1252 (class 1255 OID 30876)
-- Name: raster_hash(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_hash(raster) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashvarlena$$;


ALTER FUNCTION public.raster_hash(raster) OWNER TO postgres;

--
-- TOC entry 1256 (class 1255 OID 30885)
-- Name: raster_left(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_left(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry << $2::geometry$_$;


ALTER FUNCTION public.raster_left(raster, raster) OWNER TO postgres;

--
-- TOC entry 1258 (class 1255 OID 30887)
-- Name: raster_overabove(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_overabove(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry |&> $2::geometry$_$;


ALTER FUNCTION public.raster_overabove(raster, raster) OWNER TO postgres;

--
-- TOC entry 1259 (class 1255 OID 30888)
-- Name: raster_overbelow(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_overbelow(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry &<| $2::geometry$_$;


ALTER FUNCTION public.raster_overbelow(raster, raster) OWNER TO postgres;

--
-- TOC entry 1265 (class 1255 OID 30894)
-- Name: raster_overlap(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_overlap(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry && $2::geometry$_$;


ALTER FUNCTION public.raster_overlap(raster, raster) OWNER TO postgres;

--
-- TOC entry 1254 (class 1255 OID 30883)
-- Name: raster_overleft(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_overleft(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry &< $2::geometry$_$;


ALTER FUNCTION public.raster_overleft(raster, raster) OWNER TO postgres;

--
-- TOC entry 1255 (class 1255 OID 30884)
-- Name: raster_overright(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_overright(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry &> $2::geometry$_$;


ALTER FUNCTION public.raster_overright(raster, raster) OWNER TO postgres;

--
-- TOC entry 1257 (class 1255 OID 30886)
-- Name: raster_right(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_right(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry >> $2::geometry$_$;


ALTER FUNCTION public.raster_right(raster, raster) OWNER TO postgres;

--
-- TOC entry 1262 (class 1255 OID 30891)
-- Name: raster_same(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION raster_same(raster, raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select $1::geometry ~= $2::geometry$_$;


ALTER FUNCTION public.raster_same(raster, raster) OWNER TO postgres;

--
-- TOC entry 330 (class 1255 OID 29750)
-- Name: reload_plr_modules(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION reload_plr_modules() RETURNS text
    LANGUAGE c
    AS '$libdir/plr', 'reload_plr_modules';


ALTER FUNCTION public.reload_plr_modules() OWNER TO postgres;

--
-- TOC entry 879 (class 1255 OID 30487)
-- Name: st_3dclosestpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dclosestpoint(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_closestpoint3d';


ALTER FUNCTION public.st_3dclosestpoint(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 886 (class 1255 OID 30493)
-- Name: st_3ddfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_3DDFullyWithin($1, $2, $3)$_$;


ALTER FUNCTION public.st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 877 (class 1255 OID 30485)
-- Name: st_3ddistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3ddistance(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'distance3d';


ALTER FUNCTION public.st_3ddistance(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 884 (class 1255 OID 30491)
-- Name: st_3ddwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3ddwithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_3DDWithin($1, $2, $3)$_$;


ALTER FUNCTION public.st_3ddwithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 888 (class 1255 OID 30495)
-- Name: st_3dintersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dintersects(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_3DIntersects($1, $2)$_$;


ALTER FUNCTION public.st_3dintersects(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 453 (class 1255 OID 29976)
-- Name: st_3dlength(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dlength(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_length_linestring';


ALTER FUNCTION public.st_3dlength(geometry) OWNER TO postgres;

--
-- TOC entry 456 (class 1255 OID 29979)
-- Name: st_3dlength_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dlength_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_length_ellipsoid_linestring';


ALTER FUNCTION public.st_3dlength_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 881 (class 1255 OID 30489)
-- Name: st_3dlongestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dlongestline(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_longestline3d';


ALTER FUNCTION public.st_3dlongestline(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 508 (class 1255 OID 30032)
-- Name: st_3dmakebox(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dmakebox(geom1 geometry, geom2 geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_construct';


ALTER FUNCTION public.st_3dmakebox(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 878 (class 1255 OID 30486)
-- Name: st_3dmaxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dmaxdistance(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_maxdistance3d';


ALTER FUNCTION public.st_3dmaxdistance(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 459 (class 1255 OID 29982)
-- Name: st_3dperimeter(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dperimeter(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_perimeter_poly';


ALTER FUNCTION public.st_3dperimeter(geometry) OWNER TO postgres;

--
-- TOC entry 880 (class 1255 OID 30488)
-- Name: st_3dshortestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_3dshortestline(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_shortestline3d';


ALTER FUNCTION public.st_3dshortestline(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 937 (class 1255 OID 30564)
-- Name: st_addband(raster, addbandarg[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(rast raster, addbandargset addbandarg[]) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_addBand';


ALTER FUNCTION public.st_addband(rast raster, addbandargset addbandarg[]) OWNER TO postgres;

--
-- TOC entry 939 (class 1255 OID 30566)
-- Name: st_addband(raster, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(rast raster, pixeltype text, initialvalue double precision DEFAULT 0::numeric, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_addband($1, ARRAY[ROW(NULL, $2, $3, $4)]::addbandarg[]) $_$;


ALTER FUNCTION public.st_addband(rast raster, pixeltype text, initialvalue double precision, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 941 (class 1255 OID 30568)
-- Name: st_addband(raster, raster[], integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(torast raster, fromrasts raster[], fromband integer DEFAULT 1, torastindex integer DEFAULT NULL::integer) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_addBandRasterArray';


ALTER FUNCTION public.st_addband(torast raster, fromrasts raster[], fromband integer, torastindex integer) OWNER TO postgres;

--
-- TOC entry 940 (class 1255 OID 30567)
-- Name: st_addband(raster, raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(torast raster, fromrast raster, fromband integer DEFAULT 1, torastindex integer DEFAULT NULL::integer) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_copyBand';


ALTER FUNCTION public.st_addband(torast raster, fromrast raster, fromband integer, torastindex integer) OWNER TO postgres;

--
-- TOC entry 942 (class 1255 OID 30569)
-- Name: st_addband(raster, integer, text, integer[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(rast raster, index integer, outdbfile text, outdbindex integer[], nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_addBandOutDB';


ALTER FUNCTION public.st_addband(rast raster, index integer, outdbfile text, outdbindex integer[], nodataval double precision) OWNER TO postgres;

--
-- TOC entry 938 (class 1255 OID 30565)
-- Name: st_addband(raster, integer, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(rast raster, index integer, pixeltype text, initialvalue double precision DEFAULT 0::numeric, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_addband($1, ARRAY[ROW($2, $3, $4, $5)]::addbandarg[]) $_$;


ALTER FUNCTION public.st_addband(rast raster, index integer, pixeltype text, initialvalue double precision, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 943 (class 1255 OID 30570)
-- Name: st_addband(raster, text, integer[], integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addband(rast raster, outdbfile text, outdbindex integer[], index integer DEFAULT NULL::integer, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_AddBand($1, $4, $2, $3, $5) $_$;


ALTER FUNCTION public.st_addband(rast raster, outdbfile text, outdbindex integer[], index integer, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 582 (class 1255 OID 30132)
-- Name: st_addmeasure(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addmeasure(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_AddMeasure';


ALTER FUNCTION public.st_addmeasure(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 512 (class 1255 OID 30036)
-- Name: st_addpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addpoint(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_addpoint';


ALTER FUNCTION public.st_addpoint(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 513 (class 1255 OID 30037)
-- Name: st_addpoint(geometry, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addpoint(geom1 geometry, geom2 geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_addpoint';


ALTER FUNCTION public.st_addpoint(geom1 geometry, geom2 geometry, integer) OWNER TO postgres;

--
-- TOC entry 416 (class 1255 OID 29940)
-- Name: st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$_$;


ALTER FUNCTION public.st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 415 (class 1255 OID 29939)
-- Name: st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_affine';


ALTER FUNCTION public.st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 968 (class 1255 OID 30594)
-- Name: st_approxcount(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rast raster, sample_percent double precision) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_count($1, 1, TRUE, $2) $_$;


ALTER FUNCTION public.st_approxcount(rast raster, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 976 (class 1255 OID 30601)
-- Name: st_approxcount(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, sample_percent double precision) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, 1, TRUE, $3) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 967 (class 1255 OID 30593)
-- Name: st_approxcount(raster, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rast raster, exclude_nodata_value boolean, sample_percent double precision DEFAULT 0.1) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_count($1, 1, $2, $3) $_$;


ALTER FUNCTION public.st_approxcount(rast raster, exclude_nodata_value boolean, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 966 (class 1255 OID 30592)
-- Name: st_approxcount(raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rast raster, nband integer, sample_percent double precision) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_count($1, $2, TRUE, $3) $_$;


ALTER FUNCTION public.st_approxcount(rast raster, nband integer, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 975 (class 1255 OID 30600)
-- Name: st_approxcount(text, text, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, exclude_nodata_value boolean, sample_percent double precision DEFAULT 0.1) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, 1, $3, $4) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, exclude_nodata_value boolean, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 974 (class 1255 OID 30599)
-- Name: st_approxcount(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, nband integer, sample_percent double precision) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, TRUE, $4) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, nband integer, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 965 (class 1255 OID 30591)
-- Name: st_approxcount(raster, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, $4) $_$;


ALTER FUNCTION public.st_approxcount(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 973 (class 1255 OID 30598)
-- Name: st_approxcount(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision) OWNER TO postgres;

--
-- TOC entry 987 (class 1255 OID 30610)
-- Name: st_approxhistogram(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rast raster, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, 1, TRUE, $2, 0, NULL, FALSE) $_$;


ALTER FUNCTION public.st_approxhistogram(rast raster, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 997 (class 1255 OID 30621)
-- Name: st_approxhistogram(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, 1, TRUE, $3, 0, NULL, FALSE) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 986 (class 1255 OID 30609)
-- Name: st_approxhistogram(raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rast raster, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, TRUE, $3, 0, NULL, FALSE) $_$;


ALTER FUNCTION public.st_approxhistogram(rast raster, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 996 (class 1255 OID 30620)
-- Name: st_approxhistogram(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, $4, 0, NULL, FALSE) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 989 (class 1255 OID 30612)
-- Name: st_approxhistogram(raster, integer, double precision, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rast raster, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, TRUE, $3, $4, NULL, $5) $_$;


ALTER FUNCTION public.st_approxhistogram(rast raster, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 999 (class 1255 OID 30623)
-- Name: st_approxhistogram(text, text, integer, double precision, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, $4, $5, NULL, $6) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 985 (class 1255 OID 30608)
-- Name: st_approxhistogram(raster, integer, boolean, double precision, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, $3, $4, $5, NULL, $6) $_$;


ALTER FUNCTION public.st_approxhistogram(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 988 (class 1255 OID 30611)
-- Name: st_approxhistogram(raster, integer, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rast raster, nband integer, sample_percent double precision, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, TRUE, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_approxhistogram(rast raster, nband integer, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 995 (class 1255 OID 30619)
-- Name: st_approxhistogram(text, text, integer, boolean, double precision, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, $5, $6, NULL, $7) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 998 (class 1255 OID 30622)
-- Name: st_approxhistogram(text, text, integer, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, $4, $5, $6, $7) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 984 (class 1255 OID 30607)
-- Name: st_approxhistogram(raster, integer, boolean, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, $3, $4, $5, $6, $7) $_$;


ALTER FUNCTION public.st_approxhistogram(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 994 (class 1255 OID 30618)
-- Name: st_approxhistogram(text, text, integer, boolean, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, $5, $6, $7, $8) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1010 (class 1255 OID 30635)
-- Name: st_approxquantile(raster, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_quantile($1, 1, TRUE, 0.1, $2) $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1015 (class 1255 OID 30640)
-- Name: st_approxquantile(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT (_st_quantile($1, 1, TRUE, 0.1, ARRAY[$2]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1025 (class 1255 OID 30652)
-- Name: st_approxquantile(text, text, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, 1, TRUE, 0.1, $3) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1030 (class 1255 OID 30657)
-- Name: st_approxquantile(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE
    AS $_$ SELECT (_st_quantile($1, $2, 1, TRUE, 0.1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1014 (class 1255 OID 30639)
-- Name: st_approxquantile(raster, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT (_st_quantile($1, 1, $2, 0.1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, exclude_nodata_value boolean, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1009 (class 1255 OID 30634)
-- Name: st_approxquantile(raster, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_quantile($1, 1, TRUE, $2, $3) $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1013 (class 1255 OID 30638)
-- Name: st_approxquantile(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_quantile($1, 1, TRUE, $2, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, sample_percent double precision, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1029 (class 1255 OID 30656)
-- Name: st_approxquantile(text, text, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) RETURNS double precision
    LANGUAGE sql STABLE
    AS $_$ SELECT (_st_quantile($1, $2, 1, $3, 0.1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1024 (class 1255 OID 30651)
-- Name: st_approxquantile(text, text, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, 1, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1028 (class 1255 OID 30655)
-- Name: st_approxquantile(text, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, 1, TRUE, $3, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1008 (class 1255 OID 30633)
-- Name: st_approxquantile(raster, integer, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, nband integer, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_quantile($1, $2, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, nband integer, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1012 (class 1255 OID 30637)
-- Name: st_approxquantile(raster, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, nband integer, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, TRUE, $3, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, nband integer, sample_percent double precision, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1023 (class 1255 OID 30650)
-- Name: st_approxquantile(text, text, integer, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, TRUE, $4, $5) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1027 (class 1255 OID 30654)
-- Name: st_approxquantile(text, text, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, TRUE, $4, ARRAY[$5]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1007 (class 1255 OID 30632)
-- Name: st_approxquantile(raster, integer, boolean, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1011 (class 1255 OID 30636)
-- Name: st_approxquantile(raster, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, $4, ARRAY[$5]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1022 (class 1255 OID 30649)
-- Name: st_approxquantile(text, text, integer, boolean, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1026 (class 1255 OID 30653)
-- Name: st_approxquantile(text, text, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, $4, $5, ARRAY[$6]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) OWNER TO postgres;

--
-- TOC entry 953 (class 1255 OID 30580)
-- Name: st_approxsummarystats(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rast raster, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_summarystats($1, 1, TRUE, $2) $_$;


ALTER FUNCTION public.st_approxsummarystats(rast raster, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 960 (class 1255 OID 30586)
-- Name: st_approxsummarystats(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, 1, $3, 0.1) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 961 (class 1255 OID 30587)
-- Name: st_approxsummarystats(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, 1, TRUE, $3) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 952 (class 1255 OID 30579)
-- Name: st_approxsummarystats(raster, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rast raster, exclude_nodata_value boolean, sample_percent double precision DEFAULT 0.1, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_summarystats($1, 1, $2, $3) $_$;


ALTER FUNCTION public.st_approxsummarystats(rast raster, exclude_nodata_value boolean, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 951 (class 1255 OID 30578)
-- Name: st_approxsummarystats(raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rast raster, nband integer, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, TRUE, $3) $_$;


ALTER FUNCTION public.st_approxsummarystats(rast raster, nband integer, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 958 (class 1255 OID 30585)
-- Name: st_approxsummarystats(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, TRUE, $4) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 950 (class 1255 OID 30577)
-- Name: st_approxsummarystats(raster, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, $4) $_$;


ALTER FUNCTION public.st_approxsummarystats(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 957 (class 1255 OID 30584)
-- Name: st_approxsummarystats(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 844 (class 1255 OID 30444)
-- Name: st_area(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Area($1::geometry);  $_$;


ALTER FUNCTION public.st_area(text) OWNER TO postgres;

--
-- TOC entry 463 (class 1255 OID 29986)
-- Name: st_area(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'area';


ALTER FUNCTION public.st_area(geometry) OWNER TO postgres;

--
-- TOC entry 843 (class 1255 OID 30443)
-- Name: st_area(geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(geog geography, use_spheroid boolean DEFAULT true) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_area';


ALTER FUNCTION public.st_area(geog geography, use_spheroid boolean) OWNER TO postgres;

--
-- TOC entry 462 (class 1255 OID 29985)
-- Name: st_area2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_area_polygon';


ALTER FUNCTION public.st_area2d(geometry) OWNER TO postgres;

--
-- TOC entry 865 (class 1255 OID 30465)
-- Name: st_asbinary(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geography) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asBinary';


ALTER FUNCTION public.st_asbinary(geography) OWNER TO postgres;

--
-- TOC entry 702 (class 1255 OID 30266)
-- Name: st_asbinary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asBinary';


ALTER FUNCTION public.st_asbinary(geometry) OWNER TO postgres;

--
-- TOC entry 866 (class 1255 OID 30466)
-- Name: st_asbinary(geography, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geography, text) RETURNS bytea
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsBinary($1::geometry, $2);  $_$;


ALTER FUNCTION public.st_asbinary(geography, text) OWNER TO postgres;

--
-- TOC entry 701 (class 1255 OID 30265)
-- Name: st_asbinary(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asBinary';


ALTER FUNCTION public.st_asbinary(geometry, text) OWNER TO postgres;

--
-- TOC entry 1250 (class 1255 OID 30871)
-- Name: st_asbinary(raster, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(raster, outasin boolean DEFAULT false) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_to_binary';


ALTER FUNCTION public.st_asbinary(raster, outasin boolean) OWNER TO postgres;

--
-- TOC entry 493 (class 1255 OID 30017)
-- Name: st_asewkb(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkb(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'WKBFromLWGEOM';


ALTER FUNCTION public.st_asewkb(geometry) OWNER TO postgres;

--
-- TOC entry 496 (class 1255 OID 30020)
-- Name: st_asewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkb(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'WKBFromLWGEOM';


ALTER FUNCTION public.st_asewkb(geometry, text) OWNER TO postgres;

--
-- TOC entry 868 (class 1255 OID 30468)
-- Name: st_asewkt(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkt(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsEWKT($1::geometry);  $_$;


ALTER FUNCTION public.st_asewkt(text) OWNER TO postgres;

--
-- TOC entry 867 (class 1255 OID 30467)
-- Name: st_asewkt(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkt(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asEWKT';


ALTER FUNCTION public.st_asewkt(geography) OWNER TO postgres;

--
-- TOC entry 492 (class 1255 OID 30016)
-- Name: st_asewkt(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkt(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asEWKT';


ALTER FUNCTION public.st_asewkt(geometry) OWNER TO postgres;

--
-- TOC entry 1069 (class 1255 OID 30696)
-- Name: st_asgdalraster(raster, text, text[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgdalraster(rast raster, format text, options text[] DEFAULT NULL::text[], srid integer DEFAULT NULL::integer) RETURNS bytea
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_asGDALRaster';


ALTER FUNCTION public.st_asgdalraster(rast raster, format text, options text[], srid integer) OWNER TO postgres;

--
-- TOC entry 824 (class 1255 OID 30424)
-- Name: st_asgeojson(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGeoJson(1, $1::geometry,15,0);  $_$;


ALTER FUNCTION public.st_asgeojson(text) OWNER TO postgres;

--
-- TOC entry 825 (class 1255 OID 30425)
-- Name: st_asgeojson(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGeoJson(1, $1, $2, $3); $_$;


ALTER FUNCTION public.st_asgeojson(geog geography, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 676 (class 1255 OID 30240)
-- Name: st_asgeojson(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGeoJson(1, $1, $2, $3); $_$;


ALTER FUNCTION public.st_asgeojson(geom geometry, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 826 (class 1255 OID 30426)
-- Name: st_asgeojson(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(gj_version integer, geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGeoJson($1, $2, $3, $4); $_$;


ALTER FUNCTION public.st_asgeojson(gj_version integer, geog geography, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 677 (class 1255 OID 30241)
-- Name: st_asgeojson(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(gj_version integer, geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGeoJson($1, $2, $3, $4); $_$;


ALTER FUNCTION public.st_asgeojson(gj_version integer, geom geometry, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 816 (class 1255 OID 30416)
-- Name: st_asgml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGML(2,$1::geometry,15,0, NULL, NULL);  $_$;


ALTER FUNCTION public.st_asgml(text) OWNER TO postgres;

--
-- TOC entry 817 (class 1255 OID 30417)
-- Name: st_asgml(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, $3, null, null)$_$;


ALTER FUNCTION public.st_asgml(geog geography, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 670 (class 1255 OID 30234)
-- Name: st_asgml(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGML(2, $1, $2, $3, null, null); $_$;


ALTER FUNCTION public.st_asgml(geom geometry, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 818 (class 1255 OID 30418)
-- Name: st_asgml(integer, geography, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(version integer, geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT NULL::text, id text DEFAULT NULL::text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _ST_AsGML($1, $2, $3, $4, $5, $6);$_$;


ALTER FUNCTION public.st_asgml(version integer, geog geography, maxdecimaldigits integer, options integer, nprefix text, id text) OWNER TO postgres;

--
-- TOC entry 671 (class 1255 OID 30235)
-- Name: st_asgml(integer, geometry, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(version integer, geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT NULL::text, id text DEFAULT NULL::text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _ST_AsGML($1, $2, $3, $4, $5, $6); $_$;


ALTER FUNCTION public.st_asgml(version integer, geom geometry, maxdecimaldigits integer, options integer, nprefix text, id text) OWNER TO postgres;

--
-- TOC entry 494 (class 1255 OID 30018)
-- Name: st_ashexewkb(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ashexewkb(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asHEXEWKB';


ALTER FUNCTION public.st_ashexewkb(geometry) OWNER TO postgres;

--
-- TOC entry 495 (class 1255 OID 30019)
-- Name: st_ashexewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ashexewkb(geometry, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asHEXEWKB';


ALTER FUNCTION public.st_ashexewkb(geometry, text) OWNER TO postgres;

--
-- TOC entry 1075 (class 1255 OID 30701)
-- Name: st_asjpeg(raster, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asjpeg(rast raster, options text[] DEFAULT NULL::text[]) RETURNS bytea
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE
		rast2 raster;
		num_bands int;
		i int;
	BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
		END IF;

		num_bands := st_numbands($1);

		-- JPEG allows 1 or 3 bands
		IF num_bands <> 1 AND num_bands <> 3 THEN
			RAISE NOTICE 'The JPEG format only permits one or three bands.  The first band will be used.';
			rast2 := st_band(rast, ARRAY[1]);
			num_bands := st_numbands(rast);
		ELSE
			rast2 := rast;
		END IF;

		-- JPEG only supports 8BUI pixeltype
		FOR i IN 1..num_bands LOOP
			IF st_bandpixeltype(rast, i) != '8BUI' THEN
				RAISE EXCEPTION 'The pixel type of band % in the raster is not 8BUI.  The JPEG format can only be used with the 8BUI pixel type.', i;
			END IF;
		END LOOP;

		RETURN st_asgdalraster(rast2, 'JPEG', $2, NULL);
	END;
	$_$;


ALTER FUNCTION public.st_asjpeg(rast raster, options text[]) OWNER TO postgres;

--
-- TOC entry 1076 (class 1255 OID 30702)
-- Name: st_asjpeg(raster, integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asjpeg(rast raster, nbands integer[], options text[] DEFAULT NULL::text[]) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_asjpeg(st_band($1, $2), $3) $_$;


ALTER FUNCTION public.st_asjpeg(rast raster, nbands integer[], options text[]) OWNER TO postgres;

--
-- TOC entry 1077 (class 1255 OID 30703)
-- Name: st_asjpeg(raster, integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asjpeg(rast raster, nbands integer[], quality integer) RETURNS bytea
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		quality2 int;
		options text[];
	BEGIN
		IF quality IS NOT NULL THEN
			IF quality > 100 THEN
				quality2 := 100;
			ELSEIF quality < 10 THEN
				quality2 := 10;
			ELSE
				quality2 := quality;
			END IF;

			options := array_append(options, 'QUALITY=' || quality2);
		END IF;

		RETURN st_asjpeg(st_band($1, $2), options);
	END;
	$_$;


ALTER FUNCTION public.st_asjpeg(rast raster, nbands integer[], quality integer) OWNER TO postgres;

--
-- TOC entry 1078 (class 1255 OID 30704)
-- Name: st_asjpeg(raster, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asjpeg(rast raster, nband integer, options text[] DEFAULT NULL::text[]) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_asjpeg(st_band($1, $2), $3) $_$;


ALTER FUNCTION public.st_asjpeg(rast raster, nband integer, options text[]) OWNER TO postgres;

--
-- TOC entry 1079 (class 1255 OID 30705)
-- Name: st_asjpeg(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asjpeg(rast raster, nband integer, quality integer) RETURNS bytea
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_asjpeg($1, ARRAY[$2], $3) $_$;


ALTER FUNCTION public.st_asjpeg(rast raster, nband integer, quality integer) OWNER TO postgres;

--
-- TOC entry 821 (class 1255 OID 30421)
-- Name: st_askml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsKML(2, $1::geometry, 15, null);  $_$;


ALTER FUNCTION public.st_askml(text) OWNER TO postgres;

--
-- TOC entry 820 (class 1255 OID 30420)
-- Name: st_askml(geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(geog geography, maxdecimaldigits integer DEFAULT 15) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, $1, $2, null)$_$;


ALTER FUNCTION public.st_askml(geog geography, maxdecimaldigits integer) OWNER TO postgres;

--
-- TOC entry 673 (class 1255 OID 30237)
-- Name: st_askml(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(geom geometry, maxdecimaldigits integer DEFAULT 15) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsKML(2, ST_Transform($1,4326), $2, null); $_$;


ALTER FUNCTION public.st_askml(geom geometry, maxdecimaldigits integer) OWNER TO postgres;

--
-- TOC entry 822 (class 1255 OID 30422)
-- Name: st_askml(integer, geography, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(version integer, geog geography, maxdecimaldigits integer DEFAULT 15, nprefix text DEFAULT NULL::text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT _ST_AsKML($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_askml(version integer, geog geography, maxdecimaldigits integer, nprefix text) OWNER TO postgres;

--
-- TOC entry 674 (class 1255 OID 30238)
-- Name: st_askml(integer, geometry, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(version integer, geom geometry, maxdecimaldigits integer DEFAULT 15, nprefix text DEFAULT NULL::text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _ST_AsKML($1, ST_Transform($2,4326), $3, $4); $_$;


ALTER FUNCTION public.st_askml(version integer, geom geometry, maxdecimaldigits integer, nprefix text) OWNER TO postgres;

--
-- TOC entry 498 (class 1255 OID 30022)
-- Name: st_aslatlontext(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aslatlontext(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsLatLonText($1, '') $_$;


ALTER FUNCTION public.st_aslatlontext(geometry) OWNER TO postgres;

--
-- TOC entry 497 (class 1255 OID 30021)
-- Name: st_aslatlontext(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aslatlontext(geometry, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_latlon';


ALTER FUNCTION public.st_aslatlontext(geometry, text) OWNER TO postgres;

--
-- TOC entry 1168 (class 1255 OID 30789)
-- Name: st_aspect(raster, integer, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspect(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_aspect($1, $2, NULL::raster, $3, $4, $5) $_$;


ALTER FUNCTION public.st_aspect(rast raster, nband integer, pixeltype text, units text, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 1167 (class 1255 OID 30788)
-- Name: st_aspect(raster, integer, raster, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspect(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_rast raster;
		_nband integer;
		_pixtype text;
		_width integer;
		_height integer;
		_customextent raster;
		_extenttype text;
	BEGIN
		_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
		ELSE
			_extenttype := 'CUSTOM';
		END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
			_nband := 1;
			_pixtype := NULL;
		ELSE
			_rast := rast;
			_nband := nband;
			_pixtype := pixeltype;
		END IF;

		-- get properties
		SELECT width, height INTO _width, _height FROM ST_Metadata(_rast);

		RETURN ST_MapAlgebra(
			ARRAY[ROW(_rast, _nband)]::rastbandarg[],
			'_st_aspect4ma(double precision[][][], integer[][], text[])'::regprocedure,
			_pixtype,
			_extenttype, _customextent,
			1, 1,
			_width::text, _height::text,
			units::text
		);
	END;
	$$;


ALTER FUNCTION public.st_aspect(rast raster, nband integer, customextent raster, pixeltype text, units text, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 1080 (class 1255 OID 30706)
-- Name: st_aspng(raster, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspng(rast raster, options text[] DEFAULT NULL::text[]) RETURNS bytea
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE
		rast2 raster;
		num_bands int;
		i int;
		pt text;
	BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
		END IF;

		num_bands := st_numbands($1);

		-- PNG allows 1, 3 or 4 bands
		IF num_bands <> 1 AND num_bands <> 3 AND num_bands <> 4 THEN
			RAISE NOTICE 'The PNG format only permits one, three or four bands.  The first band will be used.';
			rast2 := st_band($1, ARRAY[1]);
			num_bands := st_numbands(rast2);
		ELSE
			rast2 := rast;
		END IF;

		-- PNG only supports 8BUI and 16BUI pixeltype
		FOR i IN 1..num_bands LOOP
			pt = st_bandpixeltype(rast, i);
			IF pt != '8BUI' AND pt != '16BUI' THEN
				RAISE EXCEPTION 'The pixel type of band % in the raster is not 8BUI or 16BUI.  The PNG format can only be used with 8BUI and 16BUI pixel types.', i;
			END IF;
		END LOOP;

		RETURN st_asgdalraster(rast2, 'PNG', $2, NULL);
	END;
	$_$;


ALTER FUNCTION public.st_aspng(rast raster, options text[]) OWNER TO postgres;

--
-- TOC entry 1081 (class 1255 OID 30707)
-- Name: st_aspng(raster, integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspng(rast raster, nbands integer[], options text[] DEFAULT NULL::text[]) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_aspng(st_band($1, $2), $3) $_$;


ALTER FUNCTION public.st_aspng(rast raster, nbands integer[], options text[]) OWNER TO postgres;

--
-- TOC entry 1083 (class 1255 OID 30708)
-- Name: st_aspng(raster, integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspng(rast raster, nbands integer[], compression integer) RETURNS bytea
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		compression2 int;
		options text[];
	BEGIN
		IF compression IS NOT NULL THEN
			IF compression > 9 THEN
				compression2 := 9;
			ELSEIF compression < 1 THEN
				compression2 := 1;
			ELSE
				compression2 := compression;
			END IF;

			options := array_append(options, 'ZLEVEL=' || compression2);
		END IF;

		RETURN st_aspng(st_band($1, $2), options);
	END;
	$_$;


ALTER FUNCTION public.st_aspng(rast raster, nbands integer[], compression integer) OWNER TO postgres;

--
-- TOC entry 1084 (class 1255 OID 30709)
-- Name: st_aspng(raster, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspng(rast raster, nband integer, options text[] DEFAULT NULL::text[]) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_aspng(st_band($1, $2), $3) $_$;


ALTER FUNCTION public.st_aspng(rast raster, nband integer, options text[]) OWNER TO postgres;

--
-- TOC entry 1085 (class 1255 OID 30710)
-- Name: st_aspng(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_aspng(rast raster, nband integer, compression integer) RETURNS bytea
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_aspng($1, ARRAY[$2], $3) $_$;


ALTER FUNCTION public.st_aspng(rast raster, nband integer, compression integer) OWNER TO postgres;

--
-- TOC entry 1096 (class 1255 OID 30720)
-- Name: st_asraster(geometry, raster, text[], double precision[], double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, ref raster, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], touched boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql STABLE
    AS $_$
	DECLARE
		g geometry;
		g_srid integer;

		ul_x double precision;
		ul_y double precision;
		scale_x double precision;
		scale_y double precision;
		skew_x double precision;
		skew_y double precision;
		sr_id integer;
	BEGIN
		SELECT upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid INTO ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id FROM ST_Metadata(ref);
		--RAISE NOTICE '%, %, %, %, %, %, %', ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id;

		-- geometry and raster has different SRID
		g_srid := ST_SRID(geom);
		IF g_srid != sr_id THEN
			RAISE NOTICE 'The geometry''s SRID (%) is not the same as the raster''s SRID (%).  The geometry will be transformed to the raster''s projection', g_srid, sr_id;
			g := ST_Transform(geom, sr_id);
		ELSE
			g := geom;
		END IF;

		RETURN _st_asraster(g, scale_x, scale_y, NULL, NULL, $3, $4, $5, NULL, NULL, ul_x, ul_y, skew_x, skew_y, $6);
	END;
	$_$;


ALTER FUNCTION public.st_asraster(geom geometry, ref raster, pixeltype text[], value double precision[], nodataval double precision[], touched boolean) OWNER TO postgres;

--
-- TOC entry 1097 (class 1255 OID 30721)
-- Name: st_asraster(geometry, raster, text, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, ref raster, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_asraster($1, $2, ARRAY[$3]::text[], ARRAY[$4]::double precision[], ARRAY[$5]::double precision[], $6) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, ref raster, pixeltype text, value double precision, nodataval double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1088 (class 1255 OID 30713)
-- Name: st_asraster(geometry, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, scalex double precision, scaley double precision, pixeltype text[], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, $2, $3, NULL, NULL, $4, $5, $6, $7, $8, NULL, NULL,	$9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, scalex double precision, scaley double precision, pixeltype text[], value double precision[], nodataval double precision[], upperleftx double precision, upperlefty double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1087 (class 1255 OID 30712)
-- Name: st_asraster(geometry, double precision, double precision, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, scalex double precision, scaley double precision, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, $2, $3, NULL, NULL, $6, $7, $8, NULL, NULL, $4, $5, $9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, scalex double precision, scaley double precision, gridx double precision, gridy double precision, pixeltype text[], value double precision[], nodataval double precision[], skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1091 (class 1255 OID 30716)
-- Name: st_asraster(geometry, double precision, double precision, double precision, double precision, text, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, scalex double precision, scaley double precision, gridx double precision, gridy double precision, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, $2, $3, NULL, NULL, ARRAY[$6]::text[], ARRAY[$7]::double precision[], ARRAY[$8]::double precision[], NULL, NULL, $4, $5, $9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, scalex double precision, scaley double precision, gridx double precision, gridy double precision, pixeltype text, value double precision, nodataval double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1093 (class 1255 OID 30717)
-- Name: st_asraster(geometry, double precision, double precision, text, double precision, double precision, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, scalex double precision, scaley double precision, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, $2, $3, NULL, NULL, ARRAY[$4]::text[], ARRAY[$5]::double precision[], ARRAY[$6]::double precision[], $7, $8, NULL, NULL, $9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, scalex double precision, scaley double precision, pixeltype text, value double precision, nodataval double precision, upperleftx double precision, upperlefty double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1090 (class 1255 OID 30715)
-- Name: st_asraster(geometry, integer, integer, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, width integer, height integer, pixeltype text[], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, NULL, NULL, $2, $3, $4, $5, $6, $7, $8, NULL, NULL,	$9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, width integer, height integer, pixeltype text[], value double precision[], nodataval double precision[], upperleftx double precision, upperlefty double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1089 (class 1255 OID 30714)
-- Name: st_asraster(geometry, integer, integer, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, width integer, height integer, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, NULL, NULL, $2, $3, $6, $7, $8, NULL, NULL, $4, $5, $9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, width integer, height integer, gridx double precision, gridy double precision, pixeltype text[], value double precision[], nodataval double precision[], skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1094 (class 1255 OID 30718)
-- Name: st_asraster(geometry, integer, integer, double precision, double precision, text, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, width integer, height integer, gridx double precision, gridy double precision, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, NULL, NULL, $2, $3, ARRAY[$6]::text[], ARRAY[$7]::double precision[], ARRAY[$8]::double precision[], NULL, NULL, $4, $5, $9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, width integer, height integer, gridx double precision, gridy double precision, pixeltype text, value double precision, nodataval double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 1095 (class 1255 OID 30719)
-- Name: st_asraster(geometry, integer, integer, text, double precision, double precision, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asraster(geom geometry, width integer, height integer, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_asraster($1, NULL, NULL, $2, $3, ARRAY[$4]::text[], ARRAY[$5]::double precision[], ARRAY[$6]::double precision[], $7, $8, NULL, NULL,$9, $10, $11) $_$;


ALTER FUNCTION public.st_asraster(geom geometry, width integer, height integer, pixeltype text, value double precision, nodataval double precision, upperleftx double precision, upperlefty double precision, skewx double precision, skewy double precision, touched boolean) OWNER TO postgres;

--
-- TOC entry 814 (class 1255 OID 30414)
-- Name: st_assvg(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsSVG($1::geometry,0,15);  $_$;


ALTER FUNCTION public.st_assvg(text) OWNER TO postgres;

--
-- TOC entry 813 (class 1255 OID 30413)
-- Name: st_assvg(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geog geography, rel integer DEFAULT 0, maxdecimaldigits integer DEFAULT 15) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_as_svg';


ALTER FUNCTION public.st_assvg(geog geography, rel integer, maxdecimaldigits integer) OWNER TO postgres;

--
-- TOC entry 668 (class 1255 OID 30232)
-- Name: st_assvg(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geom geometry, rel integer DEFAULT 0, maxdecimaldigits integer DEFAULT 15) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asSVG';


ALTER FUNCTION public.st_assvg(geom geometry, rel integer, maxdecimaldigits integer) OWNER TO postgres;

--
-- TOC entry 790 (class 1255 OID 30359)
-- Name: st_astext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astext(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsText($1::geometry);  $_$;


ALTER FUNCTION public.st_astext(text) OWNER TO postgres;

--
-- TOC entry 789 (class 1255 OID 30358)
-- Name: st_astext(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astext(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asText';


ALTER FUNCTION public.st_astext(geography) OWNER TO postgres;

--
-- TOC entry 703 (class 1255 OID 30267)
-- Name: st_astext(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astext(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_asText';


ALTER FUNCTION public.st_astext(geometry) OWNER TO postgres;

--
-- TOC entry 1071 (class 1255 OID 30697)
-- Name: st_astiff(raster, text[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astiff(rast raster, options text[] DEFAULT NULL::text[], srid integer DEFAULT NULL::integer) RETURNS bytea
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE
		i int;
		num_bands int;
		nodata double precision;
		last_nodata double precision;
	BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
		END IF;

		num_bands := st_numbands($1);

		-- TIFF only allows one NODATA value for ALL bands
		FOR i IN 1..num_bands LOOP
			nodata := st_bandnodatavalue($1, i);
			IF last_nodata IS NULL THEN
				last_nodata := nodata;
			ELSEIF nodata != last_nodata THEN
				RAISE NOTICE 'The TIFF format only permits one NODATA value for all bands.  The value used will be the last band with a NODATA value.';
			END IF;
		END LOOP;

		RETURN st_asgdalraster($1, 'GTiff', $2, $3);
	END;
	$_$;


ALTER FUNCTION public.st_astiff(rast raster, options text[], srid integer) OWNER TO postgres;

--
-- TOC entry 1073 (class 1255 OID 30699)
-- Name: st_astiff(raster, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astiff(rast raster, compression text, srid integer DEFAULT NULL::integer) RETURNS bytea
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE
		compression2 text;
		c_type text;
		c_level int;
		i int;
		num_bands int;
		options text[];
	BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
		END IF;

		compression2 := trim(both from upper(compression));

		IF length(compression2) > 0 THEN
			-- JPEG
			IF position('JPEG' in compression2) != 0 THEN
				c_type := 'JPEG';
				c_level := substring(compression2 from '[0-9]+$');

				IF c_level IS NOT NULL THEN
					IF c_level > 100 THEN
						c_level := 100;
					ELSEIF c_level < 1 THEN
						c_level := 1;
					END IF;

					options := array_append(options, 'JPEG_QUALITY=' || c_level);
				END IF;

				-- per band pixel type check
				num_bands := st_numbands($1);
				FOR i IN 1..num_bands LOOP
					IF st_bandpixeltype($1, i) != '8BUI' THEN
						RAISE EXCEPTION 'The pixel type of band % in the raster is not 8BUI.  JPEG compression can only be used with the 8BUI pixel type.', i;
					END IF;
				END LOOP;

			-- DEFLATE
			ELSEIF position('DEFLATE' in compression2) != 0 THEN
				c_type := 'DEFLATE';
				c_level := substring(compression2 from '[0-9]+$');

				IF c_level IS NOT NULL THEN
					IF c_level > 9 THEN
						c_level := 9;
					ELSEIF c_level < 1 THEN
						c_level := 1;
					END IF;

					options := array_append(options, 'ZLEVEL=' || c_level);
				END IF;

			ELSE
				c_type := compression2;

				-- CCITT
				IF position('CCITT' in compression2) THEN
					-- per band pixel type check
					num_bands := st_numbands($1);
					FOR i IN 1..num_bands LOOP
						IF st_bandpixeltype($1, i) != '1BB' THEN
							RAISE EXCEPTION 'The pixel type of band % in the raster is not 1BB.  CCITT compression can only be used with the 1BB pixel type.', i;
						END IF;
					END LOOP;
				END IF;

			END IF;

			-- compression type check
			IF ARRAY[c_type] <@ ARRAY['JPEG', 'LZW', 'PACKBITS', 'DEFLATE', 'CCITTRLE', 'CCITTFAX3', 'CCITTFAX4', 'NONE'] THEN
				options := array_append(options, 'COMPRESS=' || c_type);
			ELSE
				RAISE NOTICE 'Unknown compression type: %.  The outputted TIFF will not be COMPRESSED.', c_type;
			END IF;
		END IF;

		RETURN st_astiff($1, options, $3);
	END;
	$_$;


ALTER FUNCTION public.st_astiff(rast raster, compression text, srid integer) OWNER TO postgres;

--
-- TOC entry 1072 (class 1255 OID 30698)
-- Name: st_astiff(raster, integer[], text[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astiff(rast raster, nbands integer[], options text[] DEFAULT NULL::text[], srid integer DEFAULT NULL::integer) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_astiff(st_band($1, $2), $3, $4) $_$;


ALTER FUNCTION public.st_astiff(rast raster, nbands integer[], options text[], srid integer) OWNER TO postgres;

--
-- TOC entry 1074 (class 1255 OID 30700)
-- Name: st_astiff(raster, integer[], text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astiff(rast raster, nbands integer[], compression text, srid integer DEFAULT NULL::integer) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_astiff(st_band($1, $2), $3, $4) $_$;


ALTER FUNCTION public.st_astiff(rast raster, nbands integer[], compression text, srid integer) OWNER TO postgres;

--
-- TOC entry 907 (class 1255 OID 30516)
-- Name: st_asx3d(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asx3d(geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT _ST_AsX3D(3,$1,$2,$3,'');$_$;


ALTER FUNCTION public.st_asx3d(geom geometry, maxdecimaldigits integer, options integer) OWNER TO postgres;

--
-- TOC entry 848 (class 1255 OID 30448)
-- Name: st_azimuth(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_azimuth(geog1 geography, geog2 geography) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_azimuth';


ALTER FUNCTION public.st_azimuth(geog1 geography, geog2 geography) OWNER TO postgres;

--
-- TOC entry 467 (class 1255 OID 29990)
-- Name: st_azimuth(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_azimuth(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_azimuth';


ALTER FUNCTION public.st_azimuth(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 944 (class 1255 OID 30571)
-- Name: st_band(raster, integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_band(rast raster, nbands integer[] DEFAULT ARRAY[1]) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_band';


ALTER FUNCTION public.st_band(rast raster, nbands integer[]) OWNER TO postgres;

--
-- TOC entry 945 (class 1255 OID 30572)
-- Name: st_band(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_band(rast raster, nband integer) RETURNS raster
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_band($1, ARRAY[$2]) $_$;


ALTER FUNCTION public.st_band(rast raster, nband integer) OWNER TO postgres;

--
-- TOC entry 946 (class 1255 OID 30573)
-- Name: st_band(raster, text, character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_band(rast raster, nbands text, delimiter character DEFAULT ','::bpchar) RETURNS raster
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_band($1, regexp_split_to_array(regexp_replace($2, '[[:space:]]', '', 'g'), E'\\' || array_to_string(regexp_split_to_array($3, ''), E'\\'))::int[]) $_$;


ALTER FUNCTION public.st_band(rast raster, nbands text, delimiter character) OWNER TO postgres;

--
-- TOC entry 1184 (class 1255 OID 30803)
-- Name: st_bandisnodata(raster, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandisnodata(rast raster, forcechecking boolean) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_bandisnodata($1, 1, $2) $_$;


ALTER FUNCTION public.st_bandisnodata(rast raster, forcechecking boolean) OWNER TO postgres;

--
-- TOC entry 1183 (class 1255 OID 30802)
-- Name: st_bandisnodata(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandisnodata(rast raster, band integer DEFAULT 1, forcechecking boolean DEFAULT false) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_bandIsNoData';


ALTER FUNCTION public.st_bandisnodata(rast raster, band integer, forcechecking boolean) OWNER TO postgres;

--
-- TOC entry 1187 (class 1255 OID 30806)
-- Name: st_bandmetadata(raster, integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandmetadata(rast raster, band integer[], OUT bandnum integer, OUT pixeltype text, OUT nodatavalue double precision, OUT isoutdb boolean, OUT path text) RETURNS record
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_bandmetadata';


ALTER FUNCTION public.st_bandmetadata(rast raster, band integer[], OUT bandnum integer, OUT pixeltype text, OUT nodatavalue double precision, OUT isoutdb boolean, OUT path text) OWNER TO postgres;

--
-- TOC entry 1188 (class 1255 OID 30807)
-- Name: st_bandmetadata(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandmetadata(rast raster, band integer DEFAULT 1, OUT pixeltype text, OUT nodatavalue double precision, OUT isoutdb boolean, OUT path text) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT pixeltype, nodatavalue, isoutdb, path FROM st_bandmetadata($1, ARRAY[$2]::int[]) LIMIT 1 $_$;


ALTER FUNCTION public.st_bandmetadata(rast raster, band integer, OUT pixeltype text, OUT nodatavalue double precision, OUT isoutdb boolean, OUT path text) OWNER TO postgres;

--
-- TOC entry 1182 (class 1255 OID 30801)
-- Name: st_bandnodatavalue(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandnodatavalue(rast raster, band integer DEFAULT 1) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getBandNoDataValue';


ALTER FUNCTION public.st_bandnodatavalue(rast raster, band integer) OWNER TO postgres;

--
-- TOC entry 1185 (class 1255 OID 30804)
-- Name: st_bandpath(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandpath(rast raster, band integer DEFAULT 1) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getBandPath';


ALTER FUNCTION public.st_bandpath(rast raster, band integer) OWNER TO postgres;

--
-- TOC entry 1186 (class 1255 OID 30805)
-- Name: st_bandpixeltype(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bandpixeltype(rast raster, band integer DEFAULT 1) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getBandPixelTypeName';


ALTER FUNCTION public.st_bandpixeltype(rast raster, band integer) OWNER TO postgres;

--
-- TOC entry 765 (class 1255 OID 30329)
-- Name: st_bdmpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_Multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;


ALTER FUNCTION public.st_bdmpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 764 (class 1255 OID 30328)
-- Name: st_bdpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;


ALTER FUNCTION public.st_bdpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 601 (class 1255 OID 30154)
-- Name: st_boundary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_boundary(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'boundary';


ALTER FUNCTION public.st_boundary(geometry) OWNER TO postgres;

--
-- TOC entry 679 (class 1255 OID 30243)
-- Name: st_box2dfromgeohash(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box2dfromgeohash(text, integer DEFAULT NULL::integer) RETURNS box2d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'box2d_from_geohash';


ALTER FUNCTION public.st_box2dfromgeohash(text, integer) OWNER TO postgres;

--
-- TOC entry 862 (class 1255 OID 30462)
-- Name: st_buffer(text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(text, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Buffer($1::geometry, $2);  $_$;


ALTER FUNCTION public.st_buffer(text, double precision) OWNER TO postgres;

--
-- TOC entry 861 (class 1255 OID 30461)
-- Name: st_buffer(geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geography, double precision) RETURNS geography
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geography(ST_Transform(ST_Buffer(ST_Transform(geometry($1), _ST_BestSRID($1)), $2), 4326))$_$;


ALTER FUNCTION public.st_buffer(geography, double precision) OWNER TO postgres;

--
-- TOC entry 584 (class 1255 OID 30134)
-- Name: st_buffer(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'buffer';


ALTER FUNCTION public.st_buffer(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 586 (class 1255 OID 30136)
-- Name: st_buffer(geometry, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geometry, double precision, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_Buffer($1, $2,
		CAST('quad_segs='||CAST($3 AS text) as cstring))
	   $_$;


ALTER FUNCTION public.st_buffer(geometry, double precision, integer) OWNER TO postgres;

--
-- TOC entry 587 (class 1255 OID 30137)
-- Name: st_buffer(geometry, double precision, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geometry, double precision, text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_Buffer($1, $2,
		CAST( regexp_replace($3, '^[0123456789]+$',
			'quad_segs='||$3) AS cstring)
		)
	   $_$;


ALTER FUNCTION public.st_buffer(geometry, double precision, text) OWNER TO postgres;

--
-- TOC entry 519 (class 1255 OID 30043)
-- Name: st_buildarea(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buildarea(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_BuildArea';


ALTER FUNCTION public.st_buildarea(geometry) OWNER TO postgres;

--
-- TOC entry 652 (class 1255 OID 30216)
-- Name: st_centroid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_centroid(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'centroid';


ALTER FUNCTION public.st_centroid(geometry) OWNER TO postgres;

--
-- TOC entry 608 (class 1255 OID 30161)
-- Name: st_cleangeometry(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_cleangeometry(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_CleanGeometry';


ALTER FUNCTION public.st_cleangeometry(geometry) OWNER TO postgres;

--
-- TOC entry 1326 (class 1255 OID 30997)
-- Name: st_clip(raster, geometry, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_clip(rast raster, geom geometry, crop boolean) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Clip($1, NULL, $2, null::double precision[], $3) $_$;


ALTER FUNCTION public.st_clip(rast raster, geom geometry, crop boolean) OWNER TO postgres;

--
-- TOC entry 1323 (class 1255 OID 30994)
-- Name: st_clip(raster, integer, geometry, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_clip(rast raster, nband integer, geom geometry, crop boolean) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Clip($1, ARRAY[$2]::integer[], $3, null::double precision[], $4) $_$;


ALTER FUNCTION public.st_clip(rast raster, nband integer, geom geometry, crop boolean) OWNER TO postgres;

--
-- TOC entry 1324 (class 1255 OID 30995)
-- Name: st_clip(raster, geometry, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_clip(rast raster, geom geometry, nodataval double precision[] DEFAULT NULL::double precision[], crop boolean DEFAULT true) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Clip($1, NULL, $2, $3, $4) $_$;


ALTER FUNCTION public.st_clip(rast raster, geom geometry, nodataval double precision[], crop boolean) OWNER TO postgres;

--
-- TOC entry 1325 (class 1255 OID 30996)
-- Name: st_clip(raster, geometry, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_clip(rast raster, geom geometry, nodataval double precision, crop boolean DEFAULT true) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Clip($1, NULL, $2, ARRAY[$3]::double precision[], $4) $_$;


ALTER FUNCTION public.st_clip(rast raster, geom geometry, nodataval double precision, crop boolean) OWNER TO postgres;

--
-- TOC entry 1321 (class 1255 OID 30992)
-- Name: st_clip(raster, integer[], geometry, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_clip(rast raster, nband integer[], geom geometry, nodataval double precision[] DEFAULT NULL::double precision[], crop boolean DEFAULT true) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
  BEGIN
		-- short-cut if geometry's extent fully contains raster's extent
		IF (nodataval IS NULL OR array_length(nodataval, 1) < 1) AND geom ~ ST_Envelope(rast) THEN
			RETURN rast;
		END IF;

		RETURN _ST_Clip($1, $2, $3, $4, $5);
	END;
	$_$;


ALTER FUNCTION public.st_clip(rast raster, nband integer[], geom geometry, nodataval double precision[], crop boolean) OWNER TO postgres;

--
-- TOC entry 1322 (class 1255 OID 30993)
-- Name: st_clip(raster, integer, geometry, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_clip(rast raster, nband integer, geom geometry, nodataval double precision, crop boolean DEFAULT true) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Clip($1, ARRAY[$2]::integer[], $3, ARRAY[$4]::double precision[], $5) $_$;


ALTER FUNCTION public.st_clip(rast raster, nband integer, geom geometry, nodataval double precision, crop boolean) OWNER TO postgres;

--
-- TOC entry 757 (class 1255 OID 30321)
-- Name: st_closestpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_closestpoint(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_closestpoint';


ALTER FUNCTION public.st_closestpoint(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 617 (class 1255 OID 30173)
-- Name: st_collect(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collect(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_collect_garray';


ALTER FUNCTION public.st_collect(geometry[]) OWNER TO postgres;

--
-- TOC entry 616 (class 1255 OID 30171)
-- Name: st_collect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collect(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'LWGEOM_collect';


ALTER FUNCTION public.st_collect(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 479 (class 1255 OID 30003)
-- Name: st_collectionextract(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collectionextract(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_CollectionExtract';


ALTER FUNCTION public.st_collectionextract(geometry, integer) OWNER TO postgres;

--
-- TOC entry 480 (class 1255 OID 30004)
-- Name: st_collectionhomogenize(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collectionhomogenize(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_CollectionHomogenize';


ALTER FUNCTION public.st_collectionhomogenize(geometry) OWNER TO postgres;

--
-- TOC entry 1066 (class 1255 OID 30693)
-- Name: st_colormap(raster, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_colormap(rast raster, colormap text, method text DEFAULT 'INTERPOLATE'::text) RETURNS raster
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_ColorMap($1, 1, $2, $3) $_$;


ALTER FUNCTION public.st_colormap(rast raster, colormap text, method text) OWNER TO postgres;

--
-- TOC entry 1065 (class 1255 OID 30692)
-- Name: st_colormap(raster, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_colormap(rast raster, nband integer DEFAULT 1, colormap text DEFAULT 'grayscale'::text, method text DEFAULT 'INTERPOLATE'::text) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		_ismap boolean;
		_colormap text;
		_element text[];
	BEGIN
		_ismap := TRUE;

		-- clean colormap to see what it is
		_colormap := split_part(colormap, E'\n', 1);
		_colormap := regexp_replace(_colormap, E':+', ' ', 'g');
		_colormap := regexp_replace(_colormap, E',+', ' ', 'g');
		_colormap := regexp_replace(_colormap, E'\\t+', ' ', 'g');
		_colormap := regexp_replace(_colormap, E' +', ' ', 'g');
		_element := regexp_split_to_array(_colormap, ' ');

		-- treat as colormap
		IF (array_length(_element, 1) > 1) THEN
			_colormap := colormap;
		-- treat as keyword
		ELSE
			method := 'INTERPOLATE';
			CASE lower(trim(both from _colormap))
				WHEN 'grayscale', 'greyscale' THEN
					_colormap := '
100%   0
  0% 254
  nv 255 
					';
				WHEN 'pseudocolor' THEN
					_colormap := '
100% 255   0   0 255
 50%   0 255   0 255
  0%   0   0 255 255
  nv   0   0   0   0
					';
				WHEN 'fire' THEN
					_colormap := '
  100% 243 255 221 255
93.75% 242 255 178 255
 87.5% 255 255 135 255
81.25% 255 228  96 255
   75% 255 187  53 255
68.75% 255 131   7 255
 62.5% 255  84   0 255
56.25% 255  42   0 255
   50% 255   0   0 255
43.75% 255  42   0 255
 37.5% 224  74   0 255
31.25% 183  91   0 255
   25% 140  93   0 255
18.75%  99  82   0 255
 12.5%  58  58   1 255
 6.25%  12  15   0 255
    0%   0   0   0 255
    nv   0   0   0   0
					';
				WHEN 'bluered' THEN
					_colormap := '
100.00% 165   0  33 255
 94.12% 216  21  47 255
 88.24% 247  39  53 255
 82.35% 255  61  61 255
 76.47% 255 120  86 255
 70.59% 255 172 117 255
 64.71% 255 214 153 255
 58.82% 255 241 188 255
 52.94% 255 255 234 255
 47.06% 234 255 255 255
 41.18% 188 249 255 255
 35.29% 153 234 255 255
 29.41% 117 211 255 255
 23.53%  86 176 255 255
 17.65%  61 135 255 255
 11.76%  40  87 255 255
  5.88%  24  28 247 255
  0.00%  36   0 216 255
     nv   0   0   0   0
					';
				ELSE
					RAISE EXCEPTION 'Unknown colormap keyword: %', colormap;
			END CASE;
		END IF;

		RETURN _st_colormap($1, $2, _colormap, $4);
	END;
	$_$;


ALTER FUNCTION public.st_colormap(rast raster, nband integer, colormap text, method text) OWNER TO postgres;

--
-- TOC entry 438 (class 1255 OID 29962)
-- Name: st_combine_bbox(box2d, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_combine_bbox(box2d, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'BOX2D_combine';


ALTER FUNCTION public.st_combine_bbox(box2d, geometry) OWNER TO postgres;

--
-- TOC entry 615 (class 1255 OID 30168)
-- Name: st_combine_bbox(box3d, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_combine_bbox(box3d, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'BOX3D_combine';


ALTER FUNCTION public.st_combine_bbox(box3d, geometry) OWNER TO postgres;

--
-- TOC entry 905 (class 1255 OID 30513)
-- Name: st_concavehull(geometry, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_concavehull(param_geom geometry, param_pctconvex double precision, param_allow_holes boolean DEFAULT false) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE
		var_convhull geometry := ST_ConvexHull(param_geom);
		var_param_geom geometry := param_geom;
		var_initarea float := ST_Area(var_convhull);
		var_newarea float := var_initarea;
		var_div integer := 6; 
		var_tempgeom geometry;
		var_tempgeom2 geometry;
		var_cent geometry;
		var_geoms geometry[4]; 
		var_enline geometry;
		var_resultgeom geometry;
		var_atempgeoms geometry[];
		var_buf float := 1; 
	BEGIN
		-- We start with convex hull as our base
		var_resultgeom := var_convhull;
		
		IF param_pctconvex = 1 THEN
			return var_resultgeom;
		ELSIF ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN -- it is as concave as it is going to get
			IF param_allow_holes THEN -- leave the holes
				RETURN var_param_geom;
			ELSE -- remove the holes
				var_resultgeom := ST_MakePolygon(ST_ExteriorRing(var_param_geom));
				RETURN var_resultgeom;
			END IF;
		END IF;
		IF ST_Dimension(var_resultgeom) > 1 AND param_pctconvex BETWEEN 0 and 0.98 THEN
		-- get linestring that forms envelope of geometry
			var_enline := ST_Boundary(ST_Envelope(var_param_geom));
			var_buf := ST_Length(var_enline)/1000.0;
			IF ST_GeometryType(var_param_geom) = 'ST_MultiPoint' AND ST_NumGeometries(var_param_geom) BETWEEN 4 and 200 THEN
			-- we make polygons out of points since they are easier to cave in. 
			-- Note we limit to between 4 and 200 points because this process is slow and gets quadratically slow
				var_buf := sqrt(ST_Area(var_convhull)*0.8/(ST_NumGeometries(var_param_geom)*ST_NumGeometries(var_param_geom)));
				var_atempgeoms := ARRAY(SELECT geom FROM ST_DumpPoints(var_param_geom));
				-- 5 and 10 and just fudge factors
				var_tempgeom := ST_Union(ARRAY(SELECT geom
						FROM (
						-- fuse near neighbors together
						SELECT DISTINCT ON (i) i,  ST_Distance(var_atempgeoms[i],var_atempgeoms[j]), ST_Buffer(ST_MakeLine(var_atempgeoms[i], var_atempgeoms[j]) , var_buf*5, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									INNER JOIN generate_series(1,array_upper(var_atempgeoms, 1)) As j 
										ON (
								 NOT ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
								UNION ALL
						-- catch the ones with no near neighbors
								SELECT i, 0, ST_Buffer(var_atempgeoms[i] , var_buf*10, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									LEFT JOIN generate_series(ceiling(array_upper(var_atempgeoms,1)/2)::integer,array_upper(var_atempgeoms, 1)) As j 
										ON (
								 NOT ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10) 
									)
									WHERE j IS NULL
								ORDER BY 1, 2
							) As foo	) );
				IF ST_IsValid(var_tempgeom) AND ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
					var_tempgeom := ST_ForceSFS(ST_Intersection(var_tempgeom, var_convhull));
					IF param_allow_holes THEN
						var_param_geom := var_tempgeom;
					ELSE
						var_param_geom := ST_MakePolygon(ST_ExteriorRing(var_tempgeom));
					END IF;
					return var_param_geom;
				ELSIF ST_IsValid(var_tempgeom) THEN
					var_param_geom := ST_ForceSFS(ST_Intersection(var_tempgeom, var_convhull));	
				END IF;
			END IF;

			IF ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN
				IF NOT param_allow_holes THEN
					var_param_geom := ST_MakePolygon(ST_ExteriorRing(var_param_geom));
				END IF;
				return var_param_geom;
			END IF;
            var_cent := ST_Centroid(var_param_geom);
            IF (ST_XMax(var_enline) - ST_XMin(var_enline) ) > var_buf AND (ST_YMax(var_enline) - ST_YMin(var_enline) ) > var_buf THEN
                    IF ST_Dwithin(ST_Centroid(var_convhull) , ST_Centroid(ST_Envelope(var_param_geom)), var_buf/2) THEN
                -- If the geometric dimension is > 1 and the object is symettric (cutting at centroid will not work -- offset a bit)
                        var_cent := ST_Translate(var_cent, (ST_XMax(var_enline) - ST_XMin(var_enline))/1000,  (ST_YMAX(var_enline) - ST_YMin(var_enline))/1000);
                    ELSE
                        -- uses closest point on geometry to centroid. I can't explain why we are doing this
                        var_cent := ST_ClosestPoint(var_param_geom,var_cent);
                    END IF;
                    IF ST_DWithin(var_cent, var_enline,var_buf) THEN
                        var_cent := ST_centroid(ST_Envelope(var_param_geom));
                    END IF;
                    -- break envelope into 4 triangles about the centroid of the geometry and returned the clipped geometry in each quadrant
                    FOR i in 1 .. 4 LOOP
                       var_geoms[i] := ST_MakePolygon(ST_MakeLine(ARRAY[ST_PointN(var_enline,i), ST_PointN(var_enline,i+1), var_cent, ST_PointN(var_enline,i)]));
                       var_geoms[i] := ST_ForceSFS(ST_Intersection(var_param_geom, ST_Buffer(var_geoms[i],var_buf)));
                       IF ST_IsValid(var_geoms[i]) THEN 
                            
                       ELSE
                            var_geoms[i] := ST_BuildArea(ST_MakeLine(ARRAY[ST_PointN(var_enline,i), ST_PointN(var_enline,i+1), var_cent, ST_PointN(var_enline,i)]));
                       END IF; 
                    END LOOP;
                    var_tempgeom := ST_Union(ARRAY[ST_ConvexHull(var_geoms[1]), ST_ConvexHull(var_geoms[2]) , ST_ConvexHull(var_geoms[3]), ST_ConvexHull(var_geoms[4])]); 
                    --RAISE NOTICE 'Curr vex % ', ST_AsText(var_tempgeom);
                    IF ST_Area(var_tempgeom) <= var_newarea AND ST_IsValid(var_tempgeom)  THEN --AND ST_GeometryType(var_tempgeom) ILIKE '%Polygon'
                        
                        var_tempgeom := ST_Buffer(ST_ConcaveHull(var_geoms[1],least(param_pctconvex + param_pctconvex/var_div),true),var_buf, 'quad_segs=2');
                        FOR i IN 1 .. 4 LOOP
                            var_geoms[i] := ST_Buffer(ST_ConcaveHull(var_geoms[i],least(param_pctconvex + param_pctconvex/var_div),true), var_buf, 'quad_segs=2');
                            IF ST_IsValid(var_geoms[i]) Then
                                var_tempgeom := ST_Union(var_tempgeom, var_geoms[i]);
                            ELSE
                                RAISE NOTICE 'Not valid % %', i, ST_AsText(var_tempgeom);
                                var_tempgeom := ST_Union(var_tempgeom, ST_ConvexHull(var_geoms[i]));
                            END IF; 
                        END LOOP;

                        --RAISE NOTICE 'Curr concave % ', ST_AsText(var_tempgeom);
                        IF ST_IsValid(var_tempgeom) THEN
                            var_resultgeom := var_tempgeom;
                        END IF;
                        var_newarea := ST_Area(var_resultgeom);
                    ELSIF ST_IsValid(var_tempgeom) THEN
                        var_resultgeom := var_tempgeom;
                    END IF;

                    IF ST_NumGeometries(var_resultgeom) > 1  THEN
                        var_tempgeom := _ST_ConcaveHull(var_resultgeom);
                        IF ST_IsValid(var_tempgeom) AND ST_GeometryType(var_tempgeom) ILIKE 'ST_Polygon' THEN
                            var_resultgeom := var_tempgeom;
                        ELSE
                            var_resultgeom := ST_Buffer(var_tempgeom,var_buf, 'quad_segs=2');
                        END IF;
                    END IF;
                    IF param_allow_holes = false THEN 
                    -- only keep exterior ring since we do not want holes
                        var_resultgeom := ST_MakePolygon(ST_ExteriorRing(var_resultgeom));
                    END IF;
                ELSE
                    var_resultgeom := ST_Buffer(var_resultgeom,var_buf);
                END IF;
                var_resultgeom := ST_ForceSFS(ST_Intersection(var_resultgeom, ST_ConvexHull(var_param_geom)));
            ELSE
                -- dimensions are too small to cut
                var_resultgeom := _ST_ConcaveHull(var_param_geom);
            END IF;
            RETURN var_resultgeom;
	END;
$$;


ALTER FUNCTION public.st_concavehull(param_geom geometry, param_pctconvex double precision, param_allow_holes boolean) OWNER TO postgres;

--
-- TOC entry 640 (class 1255 OID 30204)
-- Name: st_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_contains(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Contains($1,$2)$_$;


ALTER FUNCTION public.st_contains(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1115 (class 1255 OID 30945)
-- Name: st_contains(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_contains(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_contains($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_contains(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1092 (class 1255 OID 30944)
-- Name: st_contains(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_contains(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_contains(st_convexhull($1), st_convexhull($3)) ELSE _st_contains($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_contains(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 646 (class 1255 OID 30210)
-- Name: st_containsproperly(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_containsproperly(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_ContainsProperly($1,$2)$_$;


ALTER FUNCTION public.st_containsproperly(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1287 (class 1255 OID 30948)
-- Name: st_containsproperly(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_containsproperly(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_containsproperly($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_containsproperly(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1286 (class 1255 OID 30947)
-- Name: st_containsproperly(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_containsproperly(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_containsproperly(st_convexhull($1), st_convexhull($3)) ELSE _st_containsproperly($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_containsproperly(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 589 (class 1255 OID 30139)
-- Name: st_convexhull(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_convexhull(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'convexhull';


ALTER FUNCTION public.st_convexhull(geometry) OWNER TO postgres;

--
-- TOC entry 914 (class 1255 OID 30538)
-- Name: st_convexhull(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_convexhull(raster) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 300
    AS '$libdir/rtpostgis-2.1', 'RASTER_convex_hull';


ALTER FUNCTION public.st_convexhull(raster) OWNER TO postgres;

--
-- TOC entry 889 (class 1255 OID 30496)
-- Name: st_coorddim(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coorddim(geometry geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_ndims';


ALTER FUNCTION public.st_coorddim(geometry geometry) OWNER TO postgres;

--
-- TOC entry 964 (class 1255 OID 30590)
-- Name: st_count(raster, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_count(rast raster, exclude_nodata_value boolean) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_count($1, 1, $2, 1) $_$;


ALTER FUNCTION public.st_count(rast raster, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 971 (class 1255 OID 30597)
-- Name: st_count(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_count(rastertable text, rastercolumn text, exclude_nodata_value boolean) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, 1, $3, 1) $_$;


ALTER FUNCTION public.st_count(rastertable text, rastercolumn text, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 963 (class 1255 OID 30589)
-- Name: st_count(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_count(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, 1) $_$;


ALTER FUNCTION public.st_count(rast raster, nband integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 970 (class 1255 OID 30596)
-- Name: st_count(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_count(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, $4, 1) $_$;


ALTER FUNCTION public.st_count(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 855 (class 1255 OID 30455)
-- Name: st_coveredby(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_CoveredBy($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_coveredby(text, text) OWNER TO postgres;

--
-- TOC entry 854 (class 1255 OID 30454)
-- Name: st_coveredby(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($2, $1)$_$;


ALTER FUNCTION public.st_coveredby(geography, geography) OWNER TO postgres;

--
-- TOC entry 642 (class 1255 OID 30206)
-- Name: st_coveredby(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_CoveredBy($1,$2)$_$;


ALTER FUNCTION public.st_coveredby(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1293 (class 1255 OID 30954)
-- Name: st_coveredby(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_coveredby($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_coveredby(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1292 (class 1255 OID 30953)
-- Name: st_coveredby(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_coveredby(st_convexhull($1), st_convexhull($3)) ELSE _st_coveredby($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_coveredby(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 853 (class 1255 OID 30453)
-- Name: st_covers(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Covers($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_covers(text, text) OWNER TO postgres;

--
-- TOC entry 852 (class 1255 OID 30452)
-- Name: st_covers(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($1, $2)$_$;


ALTER FUNCTION public.st_covers(geography, geography) OWNER TO postgres;

--
-- TOC entry 644 (class 1255 OID 30208)
-- Name: st_covers(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($1,$2)$_$;


ALTER FUNCTION public.st_covers(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1290 (class 1255 OID 30951)
-- Name: st_covers(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_covers($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_covers(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1289 (class 1255 OID 30950)
-- Name: st_covers(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_covers(st_convexhull($1), st_convexhull($3)) ELSE _st_covers($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_covers(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 638 (class 1255 OID 30202)
-- Name: st_crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_crosses(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Crosses($1,$2)$_$;


ALTER FUNCTION public.st_crosses(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 891 (class 1255 OID 30498)
-- Name: st_curvetoline(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_curvetoline(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_CurveToLine($1, 32)$_$;


ALTER FUNCTION public.st_curvetoline(geometry) OWNER TO postgres;

--
-- TOC entry 890 (class 1255 OID 30497)
-- Name: st_curvetoline(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_curvetoline(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_curve_segmentize';


ALTER FUNCTION public.st_curvetoline(geometry, integer) OWNER TO postgres;

--
-- TOC entry 614 (class 1255 OID 30167)
-- Name: st_delaunaytriangles(geometry, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_delaunaytriangles(g1 geometry, tolerance double precision DEFAULT 0.0, flags integer DEFAULT 0) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_DelaunayTriangles';


ALTER FUNCTION public.st_delaunaytriangles(g1 geometry, tolerance double precision, flags integer) OWNER TO postgres;

--
-- TOC entry 762 (class 1255 OID 30326)
-- Name: st_dfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dfullywithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_DFullyWithin(ST_ConvexHull($1), ST_ConvexHull($2), $3)$_$;


ALTER FUNCTION public.st_dfullywithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 1302 (class 1255 OID 30963)
-- Name: st_dfullywithin(raster, raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dfullywithin(rast1 raster, rast2 raster, distance double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_dfullywithin($1, NULL::integer, $2, NULL::integer, $3) $_$;


ALTER FUNCTION public.st_dfullywithin(rast1 raster, rast2 raster, distance double precision) OWNER TO postgres;

--
-- TOC entry 1301 (class 1255 OID 30962)
-- Name: st_dfullywithin(raster, integer, raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dfullywithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1::geometry && ST_Expand(ST_ConvexHull($3), $5) AND $3::geometry && ST_Expand(ST_ConvexHull($1), $5) AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_dfullywithin(st_convexhull($1), st_convexhull($3), $5) ELSE _st_dfullywithin($1, $2, $3, $4, $5) END $_$;


ALTER FUNCTION public.st_dfullywithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) OWNER TO postgres;

--
-- TOC entry 600 (class 1255 OID 30153)
-- Name: st_difference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_difference(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'difference';


ALTER FUNCTION public.st_difference(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 685 (class 1255 OID 30249)
-- Name: st_dimension(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dimension(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_dimension';


ALTER FUNCTION public.st_dimension(geometry) OWNER TO postgres;

--
-- TOC entry 630 (class 1255 OID 30194)
-- Name: st_disjoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_disjoint(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'disjoint';


ALTER FUNCTION public.st_disjoint(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1304 (class 1255 OID 30965)
-- Name: st_disjoint(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_disjoint(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_disjoint($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_disjoint(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1303 (class 1255 OID 30964)
-- Name: st_disjoint(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_disjoint(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT CASE WHEN $2 IS NULL OR $4 IS NULL THEN st_disjoint(st_convexhull($1), st_convexhull($3)) ELSE NOT _st_intersects($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_disjoint(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 831 (class 1255 OID 30431)
-- Name: st_distance(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(text, text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Distance($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_distance(text, text) OWNER TO postgres;

--
-- TOC entry 830 (class 1255 OID 30430)
-- Name: st_distance(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(geography, geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_Distance($1, $2, 0.0, true)$_$;


ALTER FUNCTION public.st_distance(geography, geography) OWNER TO postgres;

--
-- TOC entry 465 (class 1255 OID 29988)
-- Name: st_distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'distance';


ALTER FUNCTION public.st_distance(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 829 (class 1255 OID 30429)
-- Name: st_distance(geography, geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(geography, geography, boolean) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_Distance($1, $2, 0.0, $3)$_$;


ALTER FUNCTION public.st_distance(geography, geography, boolean) OWNER TO postgres;

--
-- TOC entry 872 (class 1255 OID 30472)
-- Name: st_distance_sphere(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance_sphere(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT COST 300
    AS $_$
	select st_distance(geography($1),geography($2),false)
	$_$;


ALTER FUNCTION public.st_distance_sphere(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 464 (class 1255 OID 29987)
-- Name: st_distance_spheroid(geometry, geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance_spheroid(geom1 geometry, geom2 geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_distance_ellipsoid';


ALTER FUNCTION public.st_distance_spheroid(geom1 geometry, geom2 geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 1160 (class 1255 OID 30779)
-- Name: st_distinct4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distinct4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT COUNT(DISTINCT unnest)::double precision FROM unnest($1) $_$;


ALTER FUNCTION public.st_distinct4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1141 (class 1255 OID 30761)
-- Name: st_distinct4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distinct4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT COUNT(DISTINCT unnest)::float FROM unnest($1) $_$;


ALTER FUNCTION public.st_distinct4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 522 (class 1255 OID 30049)
-- Name: st_dump(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dump(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_dump';


ALTER FUNCTION public.st_dump(geometry) OWNER TO postgres;

--
-- TOC entry 1225 (class 1255 OID 30844)
-- Name: st_dumpaspolygons(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumpaspolygons(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true) RETURNS SETOF geomval
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_dumpAsPolygons';


ALTER FUNCTION public.st_dumpaspolygons(rast raster, band integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 525 (class 1255 OID 30052)
-- Name: st_dumppoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumppoints(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_dumppoints';


ALTER FUNCTION public.st_dumppoints(geometry) OWNER TO postgres;

--
-- TOC entry 523 (class 1255 OID 30050)
-- Name: st_dumprings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumprings(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_dump_rings';


ALTER FUNCTION public.st_dumprings(geometry) OWNER TO postgres;

--
-- TOC entry 1226 (class 1255 OID 30845)
-- Name: st_dumpvalues(raster, integer[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumpvalues(rast raster, nband integer[] DEFAULT NULL::integer[], exclude_nodata_value boolean DEFAULT true, OUT nband integer, OUT valarray double precision[]) RETURNS SETOF record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_dumpValues';


ALTER FUNCTION public.st_dumpvalues(rast raster, nband integer[], exclude_nodata_value boolean, OUT nband integer, OUT valarray double precision[]) OWNER TO postgres;

--
-- TOC entry 1227 (class 1255 OID 30846)
-- Name: st_dumpvalues(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumpvalues(rast raster, nband integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT valarray FROM st_dumpvalues($1, ARRAY[$2]::integer[], $3) $_$;


ALTER FUNCTION public.st_dumpvalues(rast raster, nband integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 835 (class 1255 OID 30435)
-- Name: st_dwithin(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(text, text, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_DWithin($1::geometry, $2::geometry, $3);  $_$;


ALTER FUNCTION public.st_dwithin(text, text, double precision) OWNER TO postgres;

--
-- TOC entry 834 (class 1255 OID 30434)
-- Name: st_dwithin(geography, geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(geography, geography, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, true)$_$;


ALTER FUNCTION public.st_dwithin(geography, geography, double precision) OWNER TO postgres;

--
-- TOC entry 634 (class 1255 OID 30198)
-- Name: st_dwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(geom1 geometry, geom2 geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3)$_$;


ALTER FUNCTION public.st_dwithin(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 1299 (class 1255 OID 30960)
-- Name: st_dwithin(raster, raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(rast1 raster, rast2 raster, distance double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_dwithin($1, NULL::integer, $2, NULL::integer, $3) $_$;


ALTER FUNCTION public.st_dwithin(rast1 raster, rast2 raster, distance double precision) OWNER TO postgres;

--
-- TOC entry 833 (class 1255 OID 30433)
-- Name: st_dwithin(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_dwithin(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 1298 (class 1255 OID 30959)
-- Name: st_dwithin(raster, integer, raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1::geometry && ST_Expand(ST_ConvexHull($3), $5) AND $3::geometry && ST_Expand(ST_ConvexHull($1), $5) AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_dwithin(st_convexhull($1), st_convexhull($3), $5) ELSE _st_dwithin($1, $2, $3, $4, $5) END $_$;


ALTER FUNCTION public.st_dwithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) OWNER TO postgres;

--
-- TOC entry 696 (class 1255 OID 30260)
-- Name: st_endpoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_endpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_endpoint_linestring';


ALTER FUNCTION public.st_endpoint(geometry) OWNER TO postgres;

--
-- TOC entry 486 (class 1255 OID 30010)
-- Name: st_envelope(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_envelope(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_envelope';


ALTER FUNCTION public.st_envelope(geometry) OWNER TO postgres;

--
-- TOC entry 917 (class 1255 OID 30541)
-- Name: st_envelope(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_envelope(raster) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$select st_envelope(st_convexhull($1))$_$;


ALTER FUNCTION public.st_envelope(raster) OWNER TO postgres;

--
-- TOC entry 658 (class 1255 OID 30222)
-- Name: st_equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_equals(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 ~= $2 AND _ST_Equals($1,$2)$_$;


ALTER FUNCTION public.st_equals(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 442 (class 1255 OID 29966)
-- Name: st_estimated_extent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_estimated_extent(text, text) RETURNS box2d
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Estimated_Extent', 'ST_EstimatedExtent', '2.1.0');
    -- We use security invoker instead of security definer 
    -- to prevent malicious injection of a same named different function
    -- that would be run under elevated permissions
    SELECT ST_EstimatedExtent($1, $2);
  $_$;


ALTER FUNCTION public.st_estimated_extent(text, text) OWNER TO postgres;

--
-- TOC entry 440 (class 1255 OID 29964)
-- Name: st_estimated_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_estimated_extent(text, text, text) RETURNS box2d
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Estimated_Extent', 'ST_EstimatedExtent', '2.1.0');
    -- We use security invoker instead of security definer 
    -- to prevent malicious injection of a different same named function
    SELECT ST_EstimatedExtent($1, $2, $3);
  $_$;


ALTER FUNCTION public.st_estimated_extent(text, text, text) OWNER TO postgres;

--
-- TOC entry 441 (class 1255 OID 29965)
-- Name: st_estimatedextent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_estimatedextent(text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-2.1', 'gserialized_estimated_extent';


ALTER FUNCTION public.st_estimatedextent(text, text) OWNER TO postgres;

--
-- TOC entry 439 (class 1255 OID 29963)
-- Name: st_estimatedextent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_estimatedextent(text, text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-2.1', 'gserialized_estimated_extent';


ALTER FUNCTION public.st_estimatedextent(text, text, text) OWNER TO postgres;

--
-- TOC entry 435 (class 1255 OID 29959)
-- Name: st_expand(box2d, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_expand(box2d, double precision) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX2D_expand';


ALTER FUNCTION public.st_expand(box2d, double precision) OWNER TO postgres;

--
-- TOC entry 484 (class 1255 OID 30008)
-- Name: st_expand(box3d, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_expand(box3d, double precision) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_expand';


ALTER FUNCTION public.st_expand(box3d, double precision) OWNER TO postgres;

--
-- TOC entry 485 (class 1255 OID 30009)
-- Name: st_expand(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_expand(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_expand';


ALTER FUNCTION public.st_expand(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 686 (class 1255 OID 30250)
-- Name: st_exteriorring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_exteriorring(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_exteriorring_polygon';


ALTER FUNCTION public.st_exteriorring(geometry) OWNER TO postgres;

--
-- TOC entry 445 (class 1255 OID 29968)
-- Name: st_find_extent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT ST_Extent("' || columnname || '") As extent FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


ALTER FUNCTION public.st_find_extent(text, text) OWNER TO postgres;

--
-- TOC entry 444 (class 1255 OID 29967)
-- Name: st_find_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT ST_Extent("' || columnname || '") As extent FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


ALTER FUNCTION public.st_find_extent(text, text, text) OWNER TO postgres;

--
-- TOC entry 763 (class 1255 OID 30327)
-- Name: st_flipcoordinates(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_flipcoordinates(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_FlipCoordinates';


ALTER FUNCTION public.st_flipcoordinates(geometry) OWNER TO postgres;

--
-- TOC entry 468 (class 1255 OID 29991)
-- Name: st_force2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force2d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_2d';


ALTER FUNCTION public.st_force2d(geometry) OWNER TO postgres;

--
-- TOC entry 472 (class 1255 OID 29995)
-- Name: st_force3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force3d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_3dz';


ALTER FUNCTION public.st_force3d(geometry) OWNER TO postgres;

--
-- TOC entry 474 (class 1255 OID 29997)
-- Name: st_force3dm(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force3dm(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_3dm';


ALTER FUNCTION public.st_force3dm(geometry) OWNER TO postgres;

--
-- TOC entry 470 (class 1255 OID 29993)
-- Name: st_force3dz(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force3dz(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_3dz';


ALTER FUNCTION public.st_force3dz(geometry) OWNER TO postgres;

--
-- TOC entry 476 (class 1255 OID 29999)
-- Name: st_force4d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force4d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_4d';


ALTER FUNCTION public.st_force4d(geometry) OWNER TO postgres;

--
-- TOC entry 469 (class 1255 OID 29992)
-- Name: st_force_2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_2d(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Force_2d', 'ST_Force2D', '2.1.0');
    SELECT ST_Force2D($1);
  $_$;


ALTER FUNCTION public.st_force_2d(geometry) OWNER TO postgres;

--
-- TOC entry 473 (class 1255 OID 29996)
-- Name: st_force_3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_3d(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Force_3d', 'ST_Force3D', '2.1.0');
    SELECT ST_Force3D($1);
  $_$;


ALTER FUNCTION public.st_force_3d(geometry) OWNER TO postgres;

--
-- TOC entry 475 (class 1255 OID 29998)
-- Name: st_force_3dm(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_3dm(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Force_3dm', 'ST_Force3DM', '2.1.0');
    SELECT ST_Force3DM($1);
  $_$;


ALTER FUNCTION public.st_force_3dm(geometry) OWNER TO postgres;

--
-- TOC entry 471 (class 1255 OID 29994)
-- Name: st_force_3dz(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_3dz(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Force_3dz', 'ST_Force3DZ', '2.1.0');
    SELECT ST_Force3DZ($1);
  $_$;


ALTER FUNCTION public.st_force_3dz(geometry) OWNER TO postgres;

--
-- TOC entry 443 (class 1255 OID 30000)
-- Name: st_force_4d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_4d(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Force_4d', 'ST_Force4D', '2.1.0');
    SELECT ST_Force4D($1);
  $_$;


ALTER FUNCTION public.st_force_4d(geometry) OWNER TO postgres;

--
-- TOC entry 478 (class 1255 OID 30002)
-- Name: st_force_collection(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_collection(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Force_Collection', 'ST_ForceCollection', '2.1.0');
    SELECT ST_ForceCollection($1);
  $_$;


ALTER FUNCTION public.st_force_collection(geometry) OWNER TO postgres;

--
-- TOC entry 477 (class 1255 OID 30001)
-- Name: st_forcecollection(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_forcecollection(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_collection';


ALTER FUNCTION public.st_forcecollection(geometry) OWNER TO postgres;

--
-- TOC entry 488 (class 1255 OID 30012)
-- Name: st_forcerhr(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_forcerhr(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_clockwise_poly';


ALTER FUNCTION public.st_forcerhr(geometry) OWNER TO postgres;

--
-- TOC entry 482 (class 1255 OID 30006)
-- Name: st_forcesfs(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_forcesfs(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_sfs';


ALTER FUNCTION public.st_forcesfs(geometry) OWNER TO postgres;

--
-- TOC entry 483 (class 1255 OID 30007)
-- Name: st_forcesfs(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_forcesfs(geometry, version text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_sfs';


ALTER FUNCTION public.st_forcesfs(geometry, version text) OWNER TO postgres;

--
-- TOC entry 1067 (class 1255 OID 30694)
-- Name: st_fromgdalraster(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_fromgdalraster(gdaldata bytea, srid integer DEFAULT NULL::integer) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_fromGDALRaster';


ALTER FUNCTION public.st_fromgdalraster(gdaldata bytea, srid integer) OWNER TO postgres;

--
-- TOC entry 1068 (class 1255 OID 30695)
-- Name: st_gdaldrivers(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_gdaldrivers(OUT idx integer, OUT short_name text, OUT long_name text, OUT create_options text) RETURNS SETOF record
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getGDALDrivers';


ALTER FUNCTION public.st_gdaldrivers(OUT idx integer, OUT short_name text, OUT long_name text, OUT create_options text) OWNER TO postgres;

--
-- TOC entry 792 (class 1255 OID 30361)
-- Name: st_geogfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geogfromtext(text) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_from_text';


ALTER FUNCTION public.st_geogfromtext(text) OWNER TO postgres;

--
-- TOC entry 793 (class 1255 OID 30362)
-- Name: st_geogfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geogfromwkb(bytea) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_from_binary';


ALTER FUNCTION public.st_geogfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 791 (class 1255 OID 30360)
-- Name: st_geographyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geographyfromtext(text) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geography_from_text';


ALTER FUNCTION public.st_geographyfromtext(text) OWNER TO postgres;

--
-- TOC entry 871 (class 1255 OID 30471)
-- Name: st_geohash(geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geohash(geog geography, maxchars integer DEFAULT 0) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_GeoHash';


ALTER FUNCTION public.st_geohash(geog geography, maxchars integer) OWNER TO postgres;

--
-- TOC entry 678 (class 1255 OID 30242)
-- Name: st_geohash(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geohash(geom geometry, maxchars integer DEFAULT 0) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_GeoHash';


ALTER FUNCTION public.st_geohash(geom geometry, maxchars integer) OWNER TO postgres;

--
-- TOC entry 729 (class 1255 OID 30293)
-- Name: st_geomcollfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromtext(text) OWNER TO postgres;

--
-- TOC entry 728 (class 1255 OID 30292)
-- Name: st_geomcollfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 754 (class 1255 OID 30318)
-- Name: st_geomcollfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 753 (class 1255 OID 30317)
-- Name: st_geomcollfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 704 (class 1255 OID 30268)
-- Name: st_geometryfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometryfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geometryfromtext(text) OWNER TO postgres;

--
-- TOC entry 705 (class 1255 OID 30269)
-- Name: st_geometryfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometryfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geometryfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 684 (class 1255 OID 30248)
-- Name: st_geometryn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometryn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_geometryn_collection';


ALTER FUNCTION public.st_geometryn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 691 (class 1255 OID 30255)
-- Name: st_geometrytype(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometrytype(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geometry_geometrytype';


ALTER FUNCTION public.st_geometrytype(geometry) OWNER TO postgres;

--
-- TOC entry 500 (class 1255 OID 30024)
-- Name: st_geomfromewkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromewkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOMFromWKB';


ALTER FUNCTION public.st_geomfromewkb(bytea) OWNER TO postgres;

--
-- TOC entry 502 (class 1255 OID 30026)
-- Name: st_geomfromewkt(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromewkt(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'parse_WKT_lwgeom';


ALTER FUNCTION public.st_geomfromewkt(text) OWNER TO postgres;

--
-- TOC entry 681 (class 1255 OID 30245)
-- Name: st_geomfromgeohash(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromgeohash(text, integer DEFAULT NULL::integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT CAST(ST_Box2dFromGeoHash($1, $2) AS geometry); $_$;


ALTER FUNCTION public.st_geomfromgeohash(text, integer) OWNER TO postgres;

--
-- TOC entry 666 (class 1255 OID 30230)
-- Name: st_geomfromgeojson(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromgeojson(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geom_from_geojson';


ALTER FUNCTION public.st_geomfromgeojson(text) OWNER TO postgres;

--
-- TOC entry 662 (class 1255 OID 30226)
-- Name: st_geomfromgml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromgml(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_GeomFromGML($1, 0)$_$;


ALTER FUNCTION public.st_geomfromgml(text) OWNER TO postgres;

--
-- TOC entry 661 (class 1255 OID 30225)
-- Name: st_geomfromgml(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromgml(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geom_from_gml';


ALTER FUNCTION public.st_geomfromgml(text, integer) OWNER TO postgres;

--
-- TOC entry 665 (class 1255 OID 30229)
-- Name: st_geomfromkml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromkml(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geom_from_kml';


ALTER FUNCTION public.st_geomfromkml(text) OWNER TO postgres;

--
-- TOC entry 706 (class 1255 OID 30270)
-- Name: st_geomfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geomfromtext(text) OWNER TO postgres;

--
-- TOC entry 707 (class 1255 OID 30271)
-- Name: st_geomfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geomfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 730 (class 1255 OID 30294)
-- Name: st_geomfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromwkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_WKB';


ALTER FUNCTION public.st_geomfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 731 (class 1255 OID 30295)
-- Name: st_geomfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SetSRID(ST_GeomFromWKB($1), $2)$_$;


ALTER FUNCTION public.st_geomfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 1195 (class 1255 OID 30816)
-- Name: st_georeference(raster, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_georeference(rast raster, format text DEFAULT 'GDAL'::text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
    DECLARE
				scale_x numeric;
				scale_y numeric;
				skew_x numeric;
				skew_y numeric;
				ul_x numeric;
				ul_y numeric;

        result text;
    BEGIN
			SELECT scalex::numeric, scaley::numeric, skewx::numeric, skewy::numeric, upperleftx::numeric, upperlefty::numeric
				INTO scale_x, scale_y, skew_x, skew_y, ul_x, ul_y FROM ST_Metadata(rast);

						-- scale x
            result := trunc(scale_x, 10) || E'\n';

						-- skew y
            result := result || trunc(skew_y, 10) || E'\n';

						-- skew x
            result := result || trunc(skew_x, 10) || E'\n';

						-- scale y
            result := result || trunc(scale_y, 10) || E'\n';

        IF format = 'ESRI' THEN
						-- upper left x
            result := result || trunc((ul_x + scale_x * 0.5), 10) || E'\n';

						-- upper left y
            result = result || trunc((ul_y + scale_y * 0.5), 10) || E'\n';
        ELSE -- IF format = 'GDAL' THEN
						-- upper left x
            result := result || trunc(ul_x, 10) || E'\n';

						-- upper left y
            result := result || trunc(ul_y, 10) || E'\n';
        END IF;

        RETURN result;
    END;
    $$;


ALTER FUNCTION public.st_georeference(rast raster, format text) OWNER TO postgres;

--
-- TOC entry 930 (class 1255 OID 30554)
-- Name: st_geotransform(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geotransform(raster, OUT imag double precision, OUT jmag double precision, OUT theta_i double precision, OUT theta_ij double precision, OUT xoffset double precision, OUT yoffset double precision) RETURNS record
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_getGeotransform';


ALTER FUNCTION public.st_geotransform(raster, OUT imag double precision, OUT jmag double precision, OUT theta_i double precision, OUT theta_ij double precision, OUT xoffset double precision, OUT yoffset double precision) OWNER TO postgres;

--
-- TOC entry 663 (class 1255 OID 30227)
-- Name: st_gmltosql(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_gmltosql(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_GeomFromGML($1, 0)$_$;


ALTER FUNCTION public.st_gmltosql(text) OWNER TO postgres;

--
-- TOC entry 664 (class 1255 OID 30228)
-- Name: st_gmltosql(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_gmltosql(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geom_from_gml';


ALTER FUNCTION public.st_gmltosql(text, integer) OWNER TO postgres;

--
-- TOC entry 892 (class 1255 OID 30499)
-- Name: st_hasarc(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hasarc(geometry geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_has_arc';


ALTER FUNCTION public.st_hasarc(geometry geometry) OWNER TO postgres;

--
-- TOC entry 1181 (class 1255 OID 30800)
-- Name: st_hasnoband(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hasnoband(rast raster, nband integer DEFAULT 1) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_hasNoBand';


ALTER FUNCTION public.st_hasnoband(rast raster, nband integer) OWNER TO postgres;

--
-- TOC entry 598 (class 1255 OID 30151)
-- Name: st_hausdorffdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hausdorffdistance(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'hausdorffdistance';


ALTER FUNCTION public.st_hausdorffdistance(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 599 (class 1255 OID 30152)
-- Name: st_hausdorffdistance(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hausdorffdistance(geom1 geometry, geom2 geometry, double precision) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'hausdorffdistancedensify';


ALTER FUNCTION public.st_hausdorffdistance(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 918 (class 1255 OID 30542)
-- Name: st_height(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_height(raster) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getHeight';


ALTER FUNCTION public.st_height(raster) OWNER TO postgres;

--
-- TOC entry 1171 (class 1255 OID 30792)
-- Name: st_hillshade(raster, integer, text, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hillshade(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, azimuth double precision DEFAULT 315.0, altitude double precision DEFAULT 45.0, max_bright double precision DEFAULT 255.0, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_hillshade($1, $2, NULL::raster, $3, $4, $5, $6, $7, $8) $_$;


ALTER FUNCTION public.st_hillshade(rast raster, nband integer, pixeltype text, azimuth double precision, altitude double precision, max_bright double precision, scale double precision, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 1170 (class 1255 OID 30791)
-- Name: st_hillshade(raster, integer, raster, text, double precision, double precision, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hillshade(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, azimuth double precision DEFAULT 315.0, altitude double precision DEFAULT 45.0, max_bright double precision DEFAULT 255.0, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE
		_rast raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent raster;
		_extenttype text;
	BEGIN
		_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
		ELSE
			_extenttype := 'CUSTOM';
		END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
			_nband := 1;
			_pixtype := NULL;
		ELSE
			_rast := rast;
			_nband := nband;
			_pixtype := pixeltype;
		END IF;

		-- get properties
		_pixwidth := ST_PixelWidth(_rast);
		_pixheight := ST_PixelHeight(_rast);
		SELECT width, height, scalex INTO _width, _height FROM ST_Metadata(_rast);

		RETURN ST_MapAlgebra(
			ARRAY[ROW(_rast, _nband)]::rastbandarg[],
			'_st_hillshade4ma(double precision[][][], integer[][], text[])'::regprocedure,
			_pixtype,
			_extenttype, _customextent,
			1, 1,
			_pixwidth::text, _pixheight::text,
			_width::text, _height::text,
			$5::text, $6::text,
			$7::text, $8::text
		);
	END;
	$_$;


ALTER FUNCTION public.st_hillshade(rast raster, nband integer, customextent raster, pixeltype text, azimuth double precision, altitude double precision, max_bright double precision, scale double precision, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 981 (class 1255 OID 30606)
-- Name: st_histogram(raster, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rast raster, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, TRUE, 1, $3, NULL, $4) $_$;


ALTER FUNCTION public.st_histogram(rast raster, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 993 (class 1255 OID 30617)
-- Name: st_histogram(text, text, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, 1, $4, NULL, $5) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 979 (class 1255 OID 30604)
-- Name: st_histogram(raster, integer, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rast raster, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, $3, 1, $4, NULL, $5) $_$;


ALTER FUNCTION public.st_histogram(rast raster, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 980 (class 1255 OID 30605)
-- Name: st_histogram(raster, integer, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rast raster, nband integer, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, TRUE, 1, $3, $4, $5) $_$;


ALTER FUNCTION public.st_histogram(rast raster, nband integer, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 992 (class 1255 OID 30615)
-- Name: st_histogram(text, text, integer, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, 1, $5, NULL, $6) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 982 (class 1255 OID 30616)
-- Name: st_histogram(text, text, integer, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, 1, $4, $5, $6) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 978 (class 1255 OID 30603)
-- Name: st_histogram(raster, integer, boolean, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT min, max, count, percent FROM _st_histogram($1, $2, $3, 1, $4, $5, $6) $_$;


ALTER FUNCTION public.st_histogram(rast raster, nband integer, exclude_nodata_value boolean, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 991 (class 1255 OID 30614)
-- Name: st_histogram(text, text, integer, boolean, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, 1, $5, $6, $7) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 689 (class 1255 OID 30253)
-- Name: st_interiorringn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_interiorringn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_interiorringn_polygon';


ALTER FUNCTION public.st_interiorringn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 902 (class 1255 OID 30509)
-- Name: st_interpolatepoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_interpolatepoint(line geometry, point geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_InterpolatePoint';


ALTER FUNCTION public.st_interpolatepoint(line geometry, point geometry) OWNER TO postgres;

--
-- TOC entry 864 (class 1255 OID 30464)
-- Name: st_intersection(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(text, text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Intersection($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_intersection(text, text) OWNER TO postgres;

--
-- TOC entry 863 (class 1255 OID 30463)
-- Name: st_intersection(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(geography, geography) RETURNS geography
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geography(ST_Transform(ST_Intersection(ST_Transform(geometry($1), _ST_BestSRID($1, $2)), ST_Transform(geometry($2), _ST_BestSRID($1, $2))), 4326))$_$;


ALTER FUNCTION public.st_intersection(geography, geography) OWNER TO postgres;

--
-- TOC entry 583 (class 1255 OID 30133)
-- Name: st_intersection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'intersection';


ALTER FUNCTION public.st_intersection(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1173 (class 1255 OID 30968)
-- Name: st_intersection(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast raster, geomin geometry) RETURNS SETOF geomval
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($2, $1, 1) $_$;


ALTER FUNCTION public.st_intersection(rast raster, geomin geometry) OWNER TO postgres;

--
-- TOC entry 1305 (class 1255 OID 30966)
-- Name: st_intersection(geometry, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(geomin geometry, rast raster, band integer DEFAULT 1) RETURNS SETOF geomval
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		intersects boolean := FALSE;
	BEGIN
		intersects := ST_Intersects(geomin, rast, band);
		IF intersects THEN
			-- Return the intersections of the geometry with the vectorized parts of
			-- the raster and the values associated with those parts, if really their
			-- intersection is not empty.
			RETURN QUERY
				SELECT
					intgeom,
					val
				FROM (
					SELECT
						ST_Intersection((gv).geom, geomin) AS intgeom,
						(gv).val
					FROM ST_DumpAsPolygons(rast, band) gv
					WHERE ST_Intersects((gv).geom, geomin)
				) foo
				WHERE NOT ST_IsEmpty(intgeom);
		ELSE
			-- If the geometry does not intersect with the raster, return an empty
			-- geometry and a null value
			RETURN QUERY
				SELECT
					emptygeom,
					NULL::float8
				FROM ST_GeomCollFromText('GEOMETRYCOLLECTION EMPTY', ST_SRID($1)) emptygeom;
		END IF;
	END;
	$_$;


ALTER FUNCTION public.st_intersection(geomin geometry, rast raster, band integer) OWNER TO postgres;

--
-- TOC entry 1166 (class 1255 OID 30967)
-- Name: st_intersection(raster, integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast raster, band integer, geomin geometry) RETURNS SETOF geomval
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($3, $1, $2) $_$;


ALTER FUNCTION public.st_intersection(rast raster, band integer, geomin geometry) OWNER TO postgres;

--
-- TOC entry 1312 (class 1255 OID 30975)
-- Name: st_intersection(raster, raster, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, rast2 raster, nodataval double precision[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, 1, $2, 1, 'BOTH', $3) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, rast2 raster, nodataval double precision[]) OWNER TO postgres;

--
-- TOC entry 1313 (class 1255 OID 30976)
-- Name: st_intersection(raster, raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, rast2 raster, nodataval double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, 1, $2, 1, 'BOTH', ARRAY[$3, $3]) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, rast2 raster, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1310 (class 1255 OID 30973)
-- Name: st_intersection(raster, raster, text, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, rast2 raster, returnband text DEFAULT 'BOTH'::text, nodataval double precision[] DEFAULT NULL::double precision[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, 1, $2, 1, $3, $4) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, rast2 raster, returnband text, nodataval double precision[]) OWNER TO postgres;

--
-- TOC entry 1311 (class 1255 OID 30974)
-- Name: st_intersection(raster, raster, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, rast2 raster, returnband text, nodataval double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, 1, $2, 1, $3, ARRAY[$4, $4]) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, rast2 raster, returnband text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1308 (class 1255 OID 30971)
-- Name: st_intersection(raster, integer, raster, integer, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, nodataval double precision[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, $2, $3, $4, 'BOTH', $5) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, nodataval double precision[]) OWNER TO postgres;

--
-- TOC entry 1309 (class 1255 OID 30972)
-- Name: st_intersection(raster, integer, raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, nodataval double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, $2, $3, $4, 'BOTH', ARRAY[$5, $5]) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1306 (class 1255 OID 30969)
-- Name: st_intersection(raster, integer, raster, integer, text, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, returnband text DEFAULT 'BOTH'::text, nodataval double precision[] DEFAULT NULL::double precision[]) RETURNS raster
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		rtn raster;
		_returnband text;
		newnodata1 float8;
		newnodata2 float8;
	BEGIN
		IF ST_SRID(rast1) != ST_SRID(rast2) THEN
			RAISE EXCEPTION 'The two rasters do not have the same SRID';
		END IF;

		newnodata1 := coalesce(nodataval[1], ST_BandNodataValue(rast1, band1), ST_MinPossibleValue(ST_BandPixelType(rast1, band1)));
		newnodata2 := coalesce(nodataval[2], ST_BandNodataValue(rast2, band2), ST_MinPossibleValue(ST_BandPixelType(rast2, band2)));
		
		_returnband := upper(returnband);

		rtn := NULL;
		CASE
			WHEN _returnband = 'BAND1' THEN
				rtn := ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast1.val]', ST_BandPixelType(rast1, band1), 'INTERSECTION', newnodata1::text, newnodata1::text, newnodata1);
				rtn := ST_SetBandNodataValue(rtn, 1, newnodata1);
			WHEN _returnband = 'BAND2' THEN
				rtn := ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast2.val]', ST_BandPixelType(rast2, band2), 'INTERSECTION', newnodata2::text, newnodata2::text, newnodata2);
				rtn := ST_SetBandNodataValue(rtn, 1, newnodata2);
			WHEN _returnband = 'BOTH' THEN
				rtn := ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast1.val]', ST_BandPixelType(rast1, band1), 'INTERSECTION', newnodata1::text, newnodata1::text, newnodata1);
				rtn := ST_SetBandNodataValue(rtn, 1, newnodata1);
				rtn := ST_AddBand(rtn, ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast2.val]', ST_BandPixelType(rast2, band2), 'INTERSECTION', newnodata2::text, newnodata2::text, newnodata2));
				rtn := ST_SetBandNodataValue(rtn, 2, newnodata2);
			ELSE
				RAISE EXCEPTION 'Unknown value provided for returnband: %', returnband;
				RETURN NULL;
		END CASE;

		RETURN rtn;
	END;
	$$;


ALTER FUNCTION public.st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, returnband text, nodataval double precision[]) OWNER TO postgres;

--
-- TOC entry 1307 (class 1255 OID 30970)
-- Name: st_intersection(raster, integer, raster, integer, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, returnband text, nodataval double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_intersection($1, $2, $3, $4, $5, ARRAY[$6, $6]) $_$;


ALTER FUNCTION public.st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, returnband text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 858 (class 1255 OID 30458)
-- Name: st_intersects(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Intersects($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_intersects(text, text) OWNER TO postgres;

--
-- TOC entry 857 (class 1255 OID 30457)
-- Name: st_intersects(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Distance($1, $2, 0.0, false) < 0.00001$_$;


ALTER FUNCTION public.st_intersects(geography, geography) OWNER TO postgres;

--
-- TOC entry 636 (class 1255 OID 30200)
-- Name: st_intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Intersects($1,$2)$_$;


ALTER FUNCTION public.st_intersects(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1274 (class 1255 OID 30931)
-- Name: st_intersects(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_intersects($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_intersects(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1276 (class 1255 OID 30934)
-- Name: st_intersects(geometry, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(geom geometry, rast raster, nband integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $2::geometry AND _st_intersects($1, $2, $3); $_$;


ALTER FUNCTION public.st_intersects(geom geometry, rast raster, nband integer) OWNER TO postgres;

--
-- TOC entry 1278 (class 1255 OID 30936)
-- Name: st_intersects(raster, integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(rast raster, nband integer, geom geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1::geometry && $3 AND _st_intersects($3, $1, $2) $_$;


ALTER FUNCTION public.st_intersects(rast raster, nband integer, geom geometry) OWNER TO postgres;

--
-- TOC entry 1277 (class 1255 OID 30935)
-- Name: st_intersects(raster, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(rast raster, geom geometry, nband integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1::geometry && $2 AND _st_intersects($2, $1, $3) $_$;


ALTER FUNCTION public.st_intersects(rast raster, geom geometry, nband integer) OWNER TO postgres;

--
-- TOC entry 1273 (class 1255 OID 30930)
-- Name: st_intersects(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_intersects(st_convexhull($1), st_convexhull($3)) ELSE _st_intersects($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_intersects(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 1129 (class 1255 OID 30781)
-- Name: st_invdistweight4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_invdistweight4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		ndims int;

		k double precision DEFAULT 1.;
		_k double precision DEFAULT 1.;
		z double precision[];
		d double precision[];
		_d double precision;
		z0 double precision;

		_z integer;
		x integer;
		y integer;

		cx integer;
		cy integer;
		cv double precision;
		cw double precision DEFAULT NULL;

		w integer;
		h integer;
		max_dx double precision;
		max_dy double precision;
	BEGIN
--		RAISE NOTICE 'value = %', value;
--		RAISE NOTICE 'userargs = %', userargs;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		_z := array_lower(_value, 1);

		-- width and height (0-based)
		h := array_upper(_value, 2) - array_lower(_value, 2);
		w := array_upper(_value, 3) - array_lower(_value, 3);

		-- max distance from center pixel
		max_dx := w / 2;
		max_dy := h / 2;
--		RAISE NOTICE 'max_dx, max_dy = %, %', max_dx, max_dy;

		-- correct width and height (1-based)
		w := w + 1;
		h := h + 1;
--		RAISE NOTICE 'w, h = %, %', w, h;

		-- width and height should be odd numbers
		IF w % 2. != 1 THEN
			RAISE EXCEPTION 'Width of neighborhood array does not permit for a center pixel';
		END IF;
		IF h % 2. != 1 THEN
			RAISE EXCEPTION 'Height of neighborhood array does not permit for a center pixel';
		END IF;

		-- center pixel's coordinates
		cy := max_dy + array_lower(_value, 2);
		cx := max_dx + array_lower(_value, 3);
--		RAISE NOTICE 'cx, cy = %, %', cx, cy;

		-- if userargs provided, only use the first two args
		IF userargs IS NOT NULL AND array_ndims(userargs) = 1 THEN
			-- first arg is power factor
			k := userargs[array_lower(userargs, 1)]::double precision;
			IF k IS NULL THEN
				k := _k;
			ELSEIF k < 0. THEN
				RAISE NOTICE 'Power factor (< 0) must be between 0 and 1.  Defaulting to 0';
				k := 0.;
			ELSEIF k > 1. THEN
				RAISE NOTICE 'Power factor (> 1) must be between 0 and 1.  Defaulting to 1';
				k := 1.;
			END IF;

			-- second arg is what to do if center pixel has a value
			-- this will be a weight to apply for the center pixel
			IF array_length(userargs, 1) > 1 THEN
				cw := abs(userargs[array_lower(userargs, 1) + 1]::double precision);
				IF cw IS NOT NULL THEN
					IF cw < 0. THEN
						RAISE NOTICE 'Weight (< 0) of center pixel value must be between 0 and 1.  Defaulting to 0';
						cw := 0.;
					ELSEIF cw > 1 THEN
						RAISE NOTICE 'Weight (> 1) of center pixel value must be between 0 and 1.  Defaulting to 1';
						cw := 1.;
					END IF;
				END IF;
			END IF;
		END IF;
--		RAISE NOTICE 'k = %', k;
		k = abs(k) * -1;

		-- center pixel value
		cv := _value[_z][cy][cx];

		-- check to see if center pixel has value
--		RAISE NOTICE 'cw = %', cw;
		IF cw IS NULL AND cv IS NOT NULL THEN
			RETURN cv;
		END IF;

		FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
			FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
--				RAISE NOTICE 'value[%][%][%] = %', _z, y, x, _value[_z][y][x];

				-- skip NODATA values and center pixel
				IF _value[_z][y][x] IS NULL OR (x = cx AND y = cy) THEN
					CONTINUE;
				END IF;

				z := z || _value[_z][y][x];

				-- use pythagorean theorem
				_d := sqrt(power(cx - x, 2) + power(cy - y, 2));
--				RAISE NOTICE 'distance = %', _d;

				d := d || _d;
			END LOOP;
		END LOOP;
--		RAISE NOTICE 'z = %', z;
--		RAISE NOTICE 'd = %', d;

		-- neighborhood is NODATA
		IF z IS NULL OR array_length(z, 1) < 1 THEN
			-- center pixel has value
			IF cv IS NOT NULL THEN
				RETURN cv;
			ELSE
				RETURN NULL;
			END IF;
		END IF;

		z0 := 0;
		_d := 0;
		FOR x IN array_lower(z, 1)..array_upper(z, 1) LOOP
			d[x] := power(d[x], k);
			z[x] := z[x] * d[x];
			_d := _d + d[x];
			z0 := z0 + z[x];
		END LOOP;
		z0 := z0 / _d;
--		RAISE NOTICE 'z0 = %', z0;

		-- apply weight for center pixel if center pixel has value
		IF cv IS NOT NULL THEN
			z0 := (cw * cv) + ((1 - cw) * z0);
--			RAISE NOTICE '*z0 = %', z0;
		END IF;

		RETURN z0;
	END;
	$$;


ALTER FUNCTION public.st_invdistweight4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 697 (class 1255 OID 30261)
-- Name: st_isclosed(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isclosed(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_isclosed';


ALTER FUNCTION public.st_isclosed(geometry) OWNER TO postgres;

--
-- TOC entry 656 (class 1255 OID 30220)
-- Name: st_iscollection(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_iscollection(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_IsCollection';


ALTER FUNCTION public.st_iscollection(geometry) OWNER TO postgres;

--
-- TOC entry 1271 (class 1255 OID 30928)
-- Name: st_iscoveragetile(raster, raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_iscoveragetile(rast raster, coverage raster, tilewidth integer, tileheight integer) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE
		_rastmeta record;
		_covmeta record;
		cr record;
		max integer[];
		tile integer[];
		edge integer[];
	BEGIN
		IF NOT ST_SameAlignment(rast, coverage) THEN
			RAISE NOTICE 'Raster and coverage are not aligned';
			RETURN FALSE;
		END IF;

		_rastmeta := ST_Metadata(rast);
		_covmeta := ST_Metadata(coverage);

		-- get coverage grid coordinates of upper-left of rast
		cr := ST_WorldToRasterCoord(coverage, _rastmeta.upperleftx, _rastmeta.upperlefty);

		-- rast is not part of coverage
		IF
			(cr.columnx < 1 OR cr.columnx > _covmeta.width) OR
			(cr.rowy < 1 OR cr.rowy > _covmeta.height)
		THEN
			RAISE NOTICE 'Raster is not in the coverage';
			RETURN FALSE;
		END IF;

		-- rast isn't on the coverage's grid
		IF
			((cr.columnx - 1) % tilewidth != 0) OR
			((cr.rowy - 1) % tileheight != 0)
		THEN
			RAISE NOTICE 'Raster is not aligned to tile grid of coverage';
			RETURN FALSE;
		END IF;

		-- max # of tiles on X and Y for coverage
		max[0] := ceil(_covmeta.width::double precision / tilewidth::double precision)::integer;
		max[1] := ceil(_covmeta.height::double precision / tileheight::double precision)::integer;

		-- tile # of rast in coverge
		tile[0] := (cr.columnx / tilewidth) + 1;
		tile[1] := (cr.rowy / tileheight) + 1;

		-- inner tile
		IF tile[0] < max[0] AND tile[1] < max[1] THEN
			IF
				(_rastmeta.width != tilewidth) OR
				(_rastmeta.height != tileheight)
			THEN
				RAISE NOTICE 'Raster width/height is invalid for interior tile of coverage';
				RETURN FALSE;
			ELSE
				RETURN TRUE;
			END IF;
		END IF;

		-- edge tile

		-- edge tile may have same size as inner tile
		IF 
			(_rastmeta.width = tilewidth) AND
			(_rastmeta.height = tileheight)
		THEN
			RETURN TRUE;
		END IF;

		-- get edge tile width and height
		edge[0] := _covmeta.width - ((max[0] - 1) * tilewidth);
		edge[1] := _covmeta.height - ((max[1] - 1) * tileheight);

		-- edge tile not of expected tile size
		-- right and bottom
		IF tile[0] = max[0] AND tile[1] = max[1] THEN
			IF
				_rastmeta.width != edge[0] OR
				_rastmeta.height != edge[1]
			THEN
				RAISE NOTICE 'Raster width/height is invalid for right-most AND bottom-most tile of coverage';
				RETURN FALSE;
			END IF;
		ELSEIF tile[0] = max[0] THEN
			IF
				_rastmeta.width != edge[0] OR
				_rastmeta.height != tileheight
			THEN
				RAISE NOTICE 'Raster width/height is invalid for right-most tile of coverage';
				RETURN FALSE;
			END IF;
		ELSE
			IF
				_rastmeta.width != tilewidth OR
				_rastmeta.height != edge[1]
			THEN
				RAISE NOTICE 'Raster width/height is invalid for bottom-most tile of coverage';
				RETURN FALSE;
			END IF;
		END IF;

		RETURN TRUE;
	END;
	$$;


ALTER FUNCTION public.st_iscoveragetile(rast raster, coverage raster, tilewidth integer, tileheight integer) OWNER TO postgres;

--
-- TOC entry 698 (class 1255 OID 30262)
-- Name: st_isempty(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isempty(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_isempty';


ALTER FUNCTION public.st_isempty(geometry) OWNER TO postgres;

--
-- TOC entry 1180 (class 1255 OID 30799)
-- Name: st_isempty(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isempty(rast raster) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_isEmpty';


ALTER FUNCTION public.st_isempty(rast raster) OWNER TO postgres;

--
-- TOC entry 653 (class 1255 OID 30217)
-- Name: st_isring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isring(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'isring';


ALTER FUNCTION public.st_isring(geometry) OWNER TO postgres;

--
-- TOC entry 655 (class 1255 OID 30219)
-- Name: st_issimple(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_issimple(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'issimple';


ALTER FUNCTION public.st_issimple(geometry) OWNER TO postgres;

--
-- TOC entry 651 (class 1255 OID 30215)
-- Name: st_isvalid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvalid(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'isvalid';


ALTER FUNCTION public.st_isvalid(geometry) OWNER TO postgres;

--
-- TOC entry 597 (class 1255 OID 30150)
-- Name: st_isvalid(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvalid(geometry, integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT (ST_isValidDetail($1, $2)).valid$_$;


ALTER FUNCTION public.st_isvalid(geometry, integer) OWNER TO postgres;

--
-- TOC entry 594 (class 1255 OID 30147)
-- Name: st_isvaliddetail(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvaliddetail(geometry) RETURNS valid_detail
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'isvaliddetail';


ALTER FUNCTION public.st_isvaliddetail(geometry) OWNER TO postgres;

--
-- TOC entry 595 (class 1255 OID 30148)
-- Name: st_isvaliddetail(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvaliddetail(geometry, integer) RETURNS valid_detail
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'isvaliddetail';


ALTER FUNCTION public.st_isvaliddetail(geometry, integer) OWNER TO postgres;

--
-- TOC entry 593 (class 1255 OID 30143)
-- Name: st_isvalidreason(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvalidreason(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'isvalidreason';


ALTER FUNCTION public.st_isvalidreason(geometry) OWNER TO postgres;

--
-- TOC entry 596 (class 1255 OID 30149)
-- Name: st_isvalidreason(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvalidreason(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT CASE WHEN valid THEN 'Valid Geometry' ELSE reason END FROM (
	SELECT (ST_isValidDetail($1, $2)).*
) foo
	$_$;


ALTER FUNCTION public.st_isvalidreason(geometry, integer) OWNER TO postgres;

--
-- TOC entry 846 (class 1255 OID 30446)
-- Name: st_length(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Length($1::geometry);  $_$;


ALTER FUNCTION public.st_length(text) OWNER TO postgres;

--
-- TOC entry 455 (class 1255 OID 29978)
-- Name: st_length(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_length2d_linestring';


ALTER FUNCTION public.st_length(geometry) OWNER TO postgres;

--
-- TOC entry 845 (class 1255 OID 30445)
-- Name: st_length(geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(geog geography, use_spheroid boolean DEFAULT true) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_length';


ALTER FUNCTION public.st_length(geog geography, use_spheroid boolean) OWNER TO postgres;

--
-- TOC entry 454 (class 1255 OID 29977)
-- Name: st_length2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_length2d_linestring';


ALTER FUNCTION public.st_length2d(geometry) OWNER TO postgres;

--
-- TOC entry 458 (class 1255 OID 29981)
-- Name: st_length2d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length2d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_length2d_ellipsoid';


ALTER FUNCTION public.st_length2d_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 457 (class 1255 OID 29980)
-- Name: st_length_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'LWGEOM_length_ellipsoid_linestring';


ALTER FUNCTION public.st_length_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 575 (class 1255 OID 30125)
-- Name: st_line_interpolate_point(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_line_interpolate_point(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Line_Interpolate_Point', 'ST_LineInterpolatePoint', '2.1.0');
    SELECT ST_LineInterpolatePoint($1, $2);
  $_$;


ALTER FUNCTION public.st_line_interpolate_point(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 579 (class 1255 OID 30129)
-- Name: st_line_locate_point(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_line_locate_point(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Line_Locate_Point', 'ST_LineLocatePoint', '2.1.0');
     SELECT ST_LineLocatePoint($1, $2);
  $_$;


ALTER FUNCTION public.st_line_locate_point(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 577 (class 1255 OID 30127)
-- Name: st_line_substring(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_line_substring(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _postgis_deprecate('ST_Line_Substring', 'ST_LineSubstring', '2.1.0');
     SELECT ST_LineSubstring($1, $2, $3);
  $_$;


ALTER FUNCTION public.st_line_substring(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 591 (class 1255 OID 30141)
-- Name: st_linecrossingdirection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linecrossingdirection(geom1 geometry, geom2 geometry) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT CASE WHEN NOT $1 && $2 THEN 0 ELSE _ST_LineCrossingDirection($1,$2) END $_$;


ALTER FUNCTION public.st_linecrossingdirection(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 510 (class 1255 OID 30034)
-- Name: st_linefrommultipoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefrommultipoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_line_from_mpoint';


ALTER FUNCTION public.st_linefrommultipoint(geometry) OWNER TO postgres;

--
-- TOC entry 711 (class 1255 OID 30275)
-- Name: st_linefromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'LINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromtext(text) OWNER TO postgres;

--
-- TOC entry 712 (class 1255 OID 30276)
-- Name: st_linefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 735 (class 1255 OID 30299)
-- Name: st_linefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 734 (class 1255 OID 30298)
-- Name: st_linefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 574 (class 1255 OID 30124)
-- Name: st_lineinterpolatepoint(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_lineinterpolatepoint(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_line_interpolate_point';


ALTER FUNCTION public.st_lineinterpolatepoint(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 578 (class 1255 OID 30128)
-- Name: st_linelocatepoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linelocatepoint(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_line_locate_point';


ALTER FUNCTION public.st_linelocatepoint(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 521 (class 1255 OID 30045)
-- Name: st_linemerge(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linemerge(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'linemerge';


ALTER FUNCTION public.st_linemerge(geometry) OWNER TO postgres;

--
-- TOC entry 737 (class 1255 OID 30301)
-- Name: st_linestringfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linestringfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linestringfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 736 (class 1255 OID 30300)
-- Name: st_linestringfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linestringfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linestringfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 576 (class 1255 OID 30126)
-- Name: st_linesubstring(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linesubstring(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_line_substring';


ALTER FUNCTION public.st_linesubstring(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 893 (class 1255 OID 30500)
-- Name: st_linetocurve(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linetocurve(geometry geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_line_desegmentize';


ALTER FUNCTION public.st_linetocurve(geometry geometry) OWNER TO postgres;

--
-- TOC entry 581 (class 1255 OID 30131)
-- Name: st_locate_along_measure(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locate_along_measure(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_locate_between_measures($1, $2, $2) $_$;


ALTER FUNCTION public.st_locate_along_measure(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 580 (class 1255 OID 30130)
-- Name: st_locate_between_measures(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locate_between_measures(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_locate_between_m';


ALTER FUNCTION public.st_locate_between_measures(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 900 (class 1255 OID 30507)
-- Name: st_locatealong(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locatealong(geometry geometry, measure double precision, leftrightoffset double precision DEFAULT 0.0) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_LocateAlong';


ALTER FUNCTION public.st_locatealong(geometry geometry, measure double precision, leftrightoffset double precision) OWNER TO postgres;

--
-- TOC entry 899 (class 1255 OID 30506)
-- Name: st_locatebetween(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locatebetween(geometry geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision DEFAULT 0.0) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_LocateBetween';


ALTER FUNCTION public.st_locatebetween(geometry geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision) OWNER TO postgres;

--
-- TOC entry 901 (class 1255 OID 30508)
-- Name: st_locatebetweenelevations(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locatebetweenelevations(geometry geometry, fromelevation double precision, toelevation double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_LocateBetweenElevations';


ALTER FUNCTION public.st_locatebetweenelevations(geometry geometry, fromelevation double precision, toelevation double precision) OWNER TO postgres;

--
-- TOC entry 760 (class 1255 OID 30324)
-- Name: st_longestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_longestline(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_LongestLine(ST_ConvexHull($1), ST_ConvexHull($2))$_$;


ALTER FUNCTION public.st_longestline(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 369 (class 1255 OID 29817)
-- Name: st_m(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_m_point';


ALTER FUNCTION public.st_m(geometry) OWNER TO postgres;

--
-- TOC entry 437 (class 1255 OID 29961)
-- Name: st_makebox2d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makebox2d(geom1 geometry, geom2 geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX2D_construct';


ALTER FUNCTION public.st_makebox2d(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 936 (class 1255 OID 30560)
-- Name: st_makeemptyraster(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeemptyraster(rast raster) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
		DECLARE
			w int;
			h int;
			ul_x double precision;
			ul_y double precision;
			scale_x double precision;
			scale_y double precision;
			skew_x double precision;
			skew_y double precision;
			sr_id int;
		BEGIN
			SELECT width, height, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid INTO w, h, ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id FROM ST_Metadata(rast);
			RETURN st_makeemptyraster(w, h, ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id);
		END;
    $$;


ALTER FUNCTION public.st_makeemptyraster(rast raster) OWNER TO postgres;

--
-- TOC entry 935 (class 1255 OID 30559)
-- Name: st_makeemptyraster(integer, integer, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeemptyraster(width integer, height integer, upperleftx double precision, upperlefty double precision, pixelsize double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_makeemptyraster($1, $2, $3, $4, $5, -($5), 0, 0, ST_SRID('POINT(0 0)'::geometry)) $_$;


ALTER FUNCTION public.st_makeemptyraster(width integer, height integer, upperleftx double precision, upperlefty double precision, pixelsize double precision) OWNER TO postgres;

--
-- TOC entry 934 (class 1255 OID 30558)
-- Name: st_makeemptyraster(integer, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeemptyraster(width integer, height integer, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision, srid integer DEFAULT 0) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_makeEmpty';


ALTER FUNCTION public.st_makeemptyraster(width integer, height integer, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision, srid integer) OWNER TO postgres;

--
-- TOC entry 516 (class 1255 OID 30040)
-- Name: st_makeenvelope(double precision, double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeenvelope(double precision, double precision, double precision, double precision, integer DEFAULT 0) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_MakeEnvelope';


ALTER FUNCTION public.st_makeenvelope(double precision, double precision, double precision, double precision, integer) OWNER TO postgres;

--
-- TOC entry 509 (class 1255 OID 30033)
-- Name: st_makeline(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeline(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makeline_garray';


ALTER FUNCTION public.st_makeline(geometry[]) OWNER TO postgres;

--
-- TOC entry 511 (class 1255 OID 30035)
-- Name: st_makeline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeline(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makeline';


ALTER FUNCTION public.st_makeline(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 504 (class 1255 OID 30028)
-- Name: st_makepoint(double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepoint(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_makepoint(double precision, double precision) OWNER TO postgres;

--
-- TOC entry 505 (class 1255 OID 30029)
-- Name: st_makepoint(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepoint(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_makepoint(double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 506 (class 1255 OID 30030)
-- Name: st_makepoint(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepoint(double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_makepoint(double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 507 (class 1255 OID 30031)
-- Name: st_makepointm(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepointm(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoint3dm';


ALTER FUNCTION public.st_makepointm(double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 518 (class 1255 OID 30042)
-- Name: st_makepolygon(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepolygon(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoly';


ALTER FUNCTION public.st_makepolygon(geometry) OWNER TO postgres;

--
-- TOC entry 517 (class 1255 OID 30041)
-- Name: st_makepolygon(geometry, geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepolygon(geometry, geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoly';


ALTER FUNCTION public.st_makepolygon(geometry, geometry[]) OWNER TO postgres;

--
-- TOC entry 607 (class 1255 OID 30160)
-- Name: st_makevalid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makevalid(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_MakeValid';


ALTER FUNCTION public.st_makevalid(geometry) OWNER TO postgres;

--
-- TOC entry 1151 (class 1255 OID 30770)
-- Name: st_mapalgebra(raster, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast raster, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_mapalgebra($1, 1, $2, $3, $4) $_$;


ALTER FUNCTION public.st_mapalgebra(rast raster, pixeltype text, expression text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1150 (class 1255 OID 30769)
-- Name: st_mapalgebra(raster, integer, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast raster, nband integer, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_mapalgebra(ARRAY[ROW($1, $2)]::rastbandarg[], $4, $3, 'FIRST', $5::text) $_$;


ALTER FUNCTION public.st_mapalgebra(rast raster, nband integer, pixeltype text, expression text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1144 (class 1255 OID 30764)
-- Name: st_mapalgebra(rastbandarg[], regprocedure, text, text, raster, integer, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rastbandargset rastbandarg[], callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _ST_MapAlgebra($1, $2, $3, $6, $7, $4, $5, VARIADIC $8) $_$;


ALTER FUNCTION public.st_mapalgebra(rastbandargset rastbandarg[], callbackfunc regprocedure, pixeltype text, extenttype text, customextent raster, distancex integer, distancey integer, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1153 (class 1255 OID 30772)
-- Name: st_mapalgebra(raster, raster, text, text, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast1 raster, rast2 raster, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_mapalgebra($1, 1, $2, 1, $3, $4, $5, $6, $7, $8) $_$;


ALTER FUNCTION public.st_mapalgebra(rast1 raster, rast2 raster, expression text, pixeltype text, extenttype text, nodata1expr text, nodata2expr text, nodatanodataval double precision) OWNER TO postgres;

--
-- TOC entry 1145 (class 1255 OID 30765)
-- Name: st_mapalgebra(raster, integer[], regprocedure, text, text, raster, integer, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast raster, nband integer[], callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'FIRST'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE plpgsql STABLE
    AS $_$
	DECLARE
		x int;
		argset rastbandarg[];
	BEGIN
		IF $2 IS NULL OR array_ndims($2) < 1 OR array_length($2, 1) < 1 THEN
			RAISE EXCEPTION 'Populated 1D array must be provided for nband';
			RETURN NULL;
		END IF;

		FOR x IN array_lower($2, 1)..array_upper($2, 1) LOOP
			IF $2[x] IS NULL THEN
				CONTINUE;
			END IF;

			argset := argset || ROW($1, $2[x])::rastbandarg;
		END LOOP;

		IF array_length(argset, 1) < 1 THEN
			RAISE EXCEPTION 'Populated 1D array must be provided for nband';
			RETURN NULL;
		END IF;

		RETURN _ST_MapAlgebra(argset, $3, $4, $7, $8, $5, $6, VARIADIC $9);
	END;
	$_$;


ALTER FUNCTION public.st_mapalgebra(rast raster, nband integer[], callbackfunc regprocedure, pixeltype text, extenttype text, customextent raster, distancex integer, distancey integer, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1147 (class 1255 OID 30766)
-- Name: st_mapalgebra(raster, integer, regprocedure, text, text, raster, integer, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast raster, nband integer, callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'FIRST'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _ST_MapAlgebra(ARRAY[ROW($1, $2)]::rastbandarg[], $3, $4, $7, $8, $5, $6, VARIADIC $9) $_$;


ALTER FUNCTION public.st_mapalgebra(rast raster, nband integer, callbackfunc regprocedure, pixeltype text, extenttype text, customextent raster, distancex integer, distancey integer, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1152 (class 1255 OID 30771)
-- Name: st_mapalgebra(raster, integer, raster, integer, text, text, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast1 raster, band1 integer, rast2 raster, band2 integer, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_mapalgebra(ARRAY[ROW($1, $2), ROW($3, $4)]::rastbandarg[], $5, $6, $7, $8, $9, $10) $_$;


ALTER FUNCTION public.st_mapalgebra(rast1 raster, band1 integer, rast2 raster, band2 integer, expression text, pixeltype text, extenttype text, nodata1expr text, nodata2expr text, nodatanodataval double precision) OWNER TO postgres;

--
-- TOC entry 1148 (class 1255 OID 30767)
-- Name: st_mapalgebra(raster, integer, raster, integer, regprocedure, text, text, raster, integer, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebra(rast1 raster, nband1 integer, rast2 raster, nband2 integer, callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _ST_MapAlgebra(ARRAY[ROW($1, $2), ROW($3, $4)]::rastbandarg[], $5, $6, $9, $10, $7, $8, VARIADIC $11) $_$;


ALTER FUNCTION public.st_mapalgebra(rast1 raster, nband1 integer, rast2 raster, nband2 integer, callbackfunc regprocedure, pixeltype text, extenttype text, customextent raster, distancex integer, distancey integer, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1120 (class 1255 OID 30742)
-- Name: st_mapalgebraexpr(raster, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebraexpr(rast raster, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebraexpr($1, 1, $2, $3, $4) $_$;


ALTER FUNCTION public.st_mapalgebraexpr(rast raster, pixeltype text, expression text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1119 (class 1255 OID 30741)
-- Name: st_mapalgebraexpr(raster, integer, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebraexpr(rast raster, band integer, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_mapAlgebraExpr';


ALTER FUNCTION public.st_mapalgebraexpr(rast raster, band integer, pixeltype text, expression text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1131 (class 1255 OID 30752)
-- Name: st_mapalgebraexpr(raster, raster, text, text, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebraexpr(rast1 raster, rast2 raster, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_mapalgebraexpr($1, 1, $2, 1, $3, $4, $5, $6, $7, $8) $_$;


ALTER FUNCTION public.st_mapalgebraexpr(rast1 raster, rast2 raster, expression text, pixeltype text, extenttype text, nodata1expr text, nodata2expr text, nodatanodataval double precision) OWNER TO postgres;

--
-- TOC entry 1130 (class 1255 OID 30751)
-- Name: st_mapalgebraexpr(raster, integer, raster, integer, text, text, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebraexpr(rast1 raster, band1 integer, rast2 raster, band2 integer, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_mapAlgebra2';


ALTER FUNCTION public.st_mapalgebraexpr(rast1 raster, band1 integer, rast2 raster, band2 integer, expression text, pixeltype text, extenttype text, nodata1expr text, nodata2expr text, nodatanodataval double precision) OWNER TO postgres;

--
-- TOC entry 1128 (class 1255 OID 30750)
-- Name: st_mapalgebrafct(raster, regprocedure); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, onerastuserfunc regprocedure) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, 1, NULL, $2, NULL) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, onerastuserfunc regprocedure) OWNER TO postgres;

--
-- TOC entry 1124 (class 1255 OID 30746)
-- Name: st_mapalgebrafct(raster, integer, regprocedure); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, band integer, onerastuserfunc regprocedure) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, $2, NULL, $3, NULL) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, band integer, onerastuserfunc regprocedure) OWNER TO postgres;

--
-- TOC entry 1127 (class 1255 OID 30749)
-- Name: st_mapalgebrafct(raster, regprocedure, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, onerastuserfunc regprocedure, VARIADIC args text[]) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, 1, NULL, $2, VARIADIC $3) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, onerastuserfunc regprocedure, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1126 (class 1255 OID 30748)
-- Name: st_mapalgebrafct(raster, text, regprocedure); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, pixeltype text, onerastuserfunc regprocedure) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, 1, $2, $3, NULL) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, pixeltype text, onerastuserfunc regprocedure) OWNER TO postgres;

--
-- TOC entry 1123 (class 1255 OID 30745)
-- Name: st_mapalgebrafct(raster, integer, regprocedure, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, band integer, onerastuserfunc regprocedure, VARIADIC args text[]) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, $2, NULL, $3, VARIADIC $4) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, band integer, onerastuserfunc regprocedure, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1122 (class 1255 OID 30744)
-- Name: st_mapalgebrafct(raster, integer, text, regprocedure); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, band integer, pixeltype text, onerastuserfunc regprocedure) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, $2, $3, $4, NULL) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, band integer, pixeltype text, onerastuserfunc regprocedure) OWNER TO postgres;

--
-- TOC entry 1125 (class 1255 OID 30747)
-- Name: st_mapalgebrafct(raster, text, regprocedure, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, pixeltype text, onerastuserfunc regprocedure, VARIADIC args text[]) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_mapalgebrafct($1, 1, $2, $3, VARIADIC $4) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast raster, pixeltype text, onerastuserfunc regprocedure, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1121 (class 1255 OID 30743)
-- Name: st_mapalgebrafct(raster, integer, text, regprocedure, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast raster, band integer, pixeltype text, onerastuserfunc regprocedure, VARIADIC args text[]) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_mapAlgebraFct';


ALTER FUNCTION public.st_mapalgebrafct(rast raster, band integer, pixeltype text, onerastuserfunc regprocedure, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1133 (class 1255 OID 30754)
-- Name: st_mapalgebrafct(raster, raster, regprocedure, text, text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast1 raster, rast2 raster, tworastuserfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT st_mapalgebrafct($1, 1, $2, 1, $3, $4, $5, VARIADIC $6) $_$;


ALTER FUNCTION public.st_mapalgebrafct(rast1 raster, rast2 raster, tworastuserfunc regprocedure, pixeltype text, extenttype text, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1132 (class 1255 OID 30753)
-- Name: st_mapalgebrafct(raster, integer, raster, integer, regprocedure, text, text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafct(rast1 raster, band1 integer, rast2 raster, band2 integer, tworastuserfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS raster
    LANGUAGE c STABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_mapAlgebra2';


ALTER FUNCTION public.st_mapalgebrafct(rast1 raster, band1 integer, rast2 raster, band2 integer, tworastuserfunc regprocedure, pixeltype text, extenttype text, VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1134 (class 1255 OID 30755)
-- Name: st_mapalgebrafctngb(raster, integer, text, integer, integer, regprocedure, text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mapalgebrafctngb(rast raster, band integer, pixeltype text, ngbwidth integer, ngbheight integer, onerastngbuserfunc regprocedure, nodatamode text, VARIADIC args text[]) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_mapAlgebraFctNgb';


ALTER FUNCTION public.st_mapalgebrafctngb(rast raster, band integer, pixeltype text, ngbwidth integer, ngbheight integer, onerastngbuserfunc regprocedure, nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1155 (class 1255 OID 30774)
-- Name: st_max4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_max4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		max double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		max := '-Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					IF _value[z][y][x] > max THEN
						max := _value[z][y][x];
					END IF;
				END LOOP;
			END LOOP;
		END LOOP;

		IF max = '-Infinity'::double precision THEN
			RETURN NULL;
		END IF;

		RETURN max;
	END;
	$$;


ALTER FUNCTION public.st_max4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1135 (class 1255 OID 30756)
-- Name: st_max4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;


ALTER FUNCTION public.st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 756 (class 1255 OID 30320)
-- Name: st_maxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_maxdistance(geom1 geometry, geom2 geometry) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_MaxDistance(ST_ConvexHull($1), ST_ConvexHull($2))$_$;


ALTER FUNCTION public.st_maxdistance(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1158 (class 1255 OID 30777)
-- Name: st_mean4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mean4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		sum double precision;
		count int;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		sum := 0;
		count := 0;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					sum := sum + _value[z][y][x];
					count := count + 1;
				END LOOP;
			END LOOP;
		END LOOP;

		IF count < 1 THEN
			RETURN NULL;
		END IF;

		RETURN sum / count::double precision;
	END;
	$$;


ALTER FUNCTION public.st_mean4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1139 (class 1255 OID 30759)
-- Name: st_mean4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;


ALTER FUNCTION public.st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 449 (class 1255 OID 29972)
-- Name: st_mem_size(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mem_size(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_mem_size';


ALTER FUNCTION public.st_mem_size(geometry) OWNER TO postgres;

--
-- TOC entry 932 (class 1255 OID 30556)
-- Name: st_metadata(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_metadata(rast raster, OUT upperleftx double precision, OUT upperlefty double precision, OUT width integer, OUT height integer, OUT scalex double precision, OUT scaley double precision, OUT skewx double precision, OUT skewy double precision, OUT srid integer, OUT numbands integer) RETURNS record
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_metadata';


ALTER FUNCTION public.st_metadata(rast raster, OUT upperleftx double precision, OUT upperlefty double precision, OUT width integer, OUT height integer, OUT scalex double precision, OUT scaley double precision, OUT skewx double precision, OUT skewy double precision, OUT srid integer, OUT numbands integer) OWNER TO postgres;

--
-- TOC entry 1156 (class 1255 OID 30775)
-- Name: st_min4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_min4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		min double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		min := 'Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					IF _value[z][y][x] < min THEN
						min := _value[z][y][x];
					END IF;
				END LOOP;
			END LOOP;
		END LOOP;

		IF min = 'Infinity'::double precision THEN
			RETURN NULL;
		END IF;

		RETURN min;
	END;
	$$;


ALTER FUNCTION public.st_min4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1136 (class 1255 OID 30757)
-- Name: st_min4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;


ALTER FUNCTION public.st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 915 (class 1255 OID 30539)
-- Name: st_minconvexhull(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_minconvexhull(rast raster, nband integer DEFAULT NULL::integer) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_convex_hull';


ALTER FUNCTION public.st_minconvexhull(rast raster, nband integer) OWNER TO postgres;

--
-- TOC entry 1161 (class 1255 OID 30783)
-- Name: st_mindist4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mindist4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		ndims int;

		d double precision DEFAULT NULL;
		_d double precision;

		z integer;
		x integer;
		y integer;

		cx integer;
		cy integer;
		cv double precision;

		w integer;
		h integer;
		max_dx double precision;
		max_dy double precision;
	BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		-- width and height (0-based)
		h := array_upper(_value, 2) - array_lower(_value, 2);
		w := array_upper(_value, 3) - array_lower(_value, 3);

		-- max distance from center pixel
		max_dx := w / 2;
		max_dy := h / 2;

		-- correct width and height (1-based)
		w := w + 1;
		h := h + 1;

		-- width and height should be odd numbers
		IF w % 2. != 1 THEN
			RAISE EXCEPTION 'Width of neighborhood array does not permit for a center pixel';
		END IF;
		IF h % 2. != 1 THEN
			RAISE EXCEPTION 'Height of neighborhood array does not permit for a center pixel';
		END IF;

		-- center pixel's coordinates
		cy := max_dy + array_lower(_value, 2);
		cx := max_dx + array_lower(_value, 3);

		-- center pixel value
		cv := _value[z][cy][cx];

		-- check to see if center pixel has value
		IF cv IS NOT NULL THEN
			RETURN 0.;
		END IF;

		FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
			FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP

				-- skip NODATA values and center pixel
				IF _value[z][y][x] IS NULL OR (x = cx AND y = cy) THEN
					CONTINUE;
				END IF;

				-- use pythagorean theorem
				_d := sqrt(power(cx - x, 2) + power(cy - y, 2));
--				RAISE NOTICE 'distance = %', _d;

				IF d IS NULL OR _d < d THEN
					d := _d;
				END IF;
			END LOOP;
		END LOOP;
--		RAISE NOTICE 'd = %', d;

		RETURN d;
	END;
	$$;


ALTER FUNCTION public.st_mindist4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 903 (class 1255 OID 30510)
-- Name: st_minimumboundingcircle(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer DEFAULT 48) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE
	hull GEOMETRY;
	ring GEOMETRY;
	center GEOMETRY;
	radius DOUBLE PRECISION;
	dist DOUBLE PRECISION;
	d DOUBLE PRECISION;
	idx1 integer;
	idx2 integer;
	l1 GEOMETRY;
	l2 GEOMETRY;
	p1 GEOMETRY;
	p2 GEOMETRY;
	a1 DOUBLE PRECISION;
	a2 DOUBLE PRECISION;


	BEGIN

	-- First compute the ConvexHull of the geometry
	hull = ST_ConvexHull(inputgeom);
	--A point really has no MBC
	IF ST_GeometryType(hull) = 'ST_Point' THEN
		RETURN hull;
	END IF;
	-- convert the hull perimeter to a linestring so we can manipulate individual points
	--If its already a linestring force it to a closed linestring
	ring = CASE WHEN ST_GeometryType(hull) = 'ST_LineString' THEN ST_AddPoint(hull, ST_StartPoint(hull)) ELSE ST_ExteriorRing(hull) END;

	dist = 0;
	-- Brute Force - check every pair
	FOR i in 1 .. (ST_NumPoints(ring)-2)
		LOOP
			FOR j in i .. (ST_NumPoints(ring)-1)
				LOOP
				d = ST_Distance(ST_PointN(ring,i),ST_PointN(ring,j));
				-- Check the distance and update if larger
				IF (d > dist) THEN
					dist = d;
					idx1 = i;
					idx2 = j;
				END IF;
			END LOOP;
		END LOOP;

	-- We now have the diameter of the convex hull.  The following line returns it if desired.
	-- RETURN ST_MakeLine(ST_PointN(ring,idx1),ST_PointN(ring,idx2));

	-- Now for the Minimum Bounding Circle.  Since we know the two points furthest from each
	-- other, the MBC must go through those two points. Start with those points as a diameter of a circle.

	-- The radius is half the distance between them and the center is midway between them
	radius = ST_Distance(ST_PointN(ring,idx1),ST_PointN(ring,idx2)) / 2.0;
	center = ST_LineInterpolatePoint(ST_MakeLine(ST_PointN(ring,idx1),ST_PointN(ring,idx2)),0.5);

	-- Loop through each vertex and check if the distance from the center to the point
	-- is greater than the current radius.
	FOR k in 1 .. (ST_NumPoints(ring)-1)
		LOOP
		IF(k <> idx1 and k <> idx2) THEN
			dist = ST_Distance(center,ST_PointN(ring,k));
			IF (dist > radius) THEN
				-- We have to expand the circle.  The new circle must pass trhough
				-- three points - the two original diameters and this point.

				-- Draw a line from the first diameter to this point
				l1 = ST_Makeline(ST_PointN(ring,idx1),ST_PointN(ring,k));
				-- Compute the midpoint
				p1 = ST_LineInterpolatePoint(l1,0.5);
				-- Rotate the line 90 degrees around the midpoint (perpendicular bisector)
				l1 = ST_Rotate(l1,pi()/2,p1);
				--  Compute the azimuth of the bisector
				a1 = ST_Azimuth(ST_PointN(l1,1),ST_PointN(l1,2));
				--  Extend the line in each direction the new computed distance to insure they will intersect
				l1 = ST_AddPoint(l1,ST_Makepoint(ST_X(ST_PointN(l1,2))+sin(a1)*dist,ST_Y(ST_PointN(l1,2))+cos(a1)*dist),-1);
				l1 = ST_AddPoint(l1,ST_Makepoint(ST_X(ST_PointN(l1,1))-sin(a1)*dist,ST_Y(ST_PointN(l1,1))-cos(a1)*dist),0);

				-- Repeat for the line from the point to the other diameter point
				l2 = ST_Makeline(ST_PointN(ring,idx2),ST_PointN(ring,k));
				p2 = ST_LineInterpolatePoint(l2,0.5);
				l2 = ST_Rotate(l2,pi()/2,p2);
				a2 = ST_Azimuth(ST_PointN(l2,1),ST_PointN(l2,2));
				l2 = ST_AddPoint(l2,ST_Makepoint(ST_X(ST_PointN(l2,2))+sin(a2)*dist,ST_Y(ST_PointN(l2,2))+cos(a2)*dist),-1);
				l2 = ST_AddPoint(l2,ST_Makepoint(ST_X(ST_PointN(l2,1))-sin(a2)*dist,ST_Y(ST_PointN(l2,1))-cos(a2)*dist),0);

				-- The new center is the intersection of the two bisectors
				center = ST_Intersection(l1,l2);
				-- The new radius is the distance to any of the three points
				radius = ST_Distance(center,ST_PointN(ring,idx1));
			END IF;
		END IF;
		END LOOP;
	--DONE!!  Return the MBC via the buffer command
	RETURN ST_Buffer(center,radius,segs_per_quarter);

	END;
$$;


ALTER FUNCTION public.st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer) OWNER TO postgres;

--
-- TOC entry 1249 (class 1255 OID 30870)
-- Name: st_minpossiblevalue(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_minpossiblevalue(pixeltype text) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_minPossibleValue';


ALTER FUNCTION public.st_minpossiblevalue(pixeltype text) OWNER TO postgres;

--
-- TOC entry 718 (class 1255 OID 30282)
-- Name: st_mlinefromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromtext(text) OWNER TO postgres;

--
-- TOC entry 717 (class 1255 OID 30281)
-- Name: st_mlinefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 748 (class 1255 OID 30312)
-- Name: st_mlinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 747 (class 1255 OID 30311)
-- Name: st_mlinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 722 (class 1255 OID 30286)
-- Name: st_mpointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromtext(text) OWNER TO postgres;

--
-- TOC entry 721 (class 1255 OID 30285)
-- Name: st_mpointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 743 (class 1255 OID 30307)
-- Name: st_mpointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 742 (class 1255 OID 30306)
-- Name: st_mpointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 725 (class 1255 OID 30289)
-- Name: st_mpolyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromtext(text) OWNER TO postgres;

--
-- TOC entry 724 (class 1255 OID 30288)
-- Name: st_mpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 750 (class 1255 OID 30314)
-- Name: st_mpolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 749 (class 1255 OID 30313)
-- Name: st_mpolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 481 (class 1255 OID 30005)
-- Name: st_multi(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multi(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_force_multi';


ALTER FUNCTION public.st_multi(geometry) OWNER TO postgres;

--
-- TOC entry 746 (class 1255 OID 30310)
-- Name: st_multilinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multilinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multilinefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 719 (class 1255 OID 30283)
-- Name: st_multilinestringfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multilinestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MLineFromText($1)$_$;


ALTER FUNCTION public.st_multilinestringfromtext(text) OWNER TO postgres;

--
-- TOC entry 720 (class 1255 OID 30284)
-- Name: st_multilinestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multilinestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MLineFromText($1, $2)$_$;


ALTER FUNCTION public.st_multilinestringfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 723 (class 1255 OID 30287)
-- Name: st_multipointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MPointFromText($1)$_$;


ALTER FUNCTION public.st_multipointfromtext(text) OWNER TO postgres;

--
-- TOC entry 745 (class 1255 OID 30309)
-- Name: st_multipointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 744 (class 1255 OID 30308)
-- Name: st_multipointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 752 (class 1255 OID 30316)
-- Name: st_multipolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipolyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 751 (class 1255 OID 30315)
-- Name: st_multipolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipolyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 727 (class 1255 OID 30291)
-- Name: st_multipolygonfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MPolyFromText($1)$_$;


ALTER FUNCTION public.st_multipolygonfromtext(text) OWNER TO postgres;

--
-- TOC entry 726 (class 1255 OID 30290)
-- Name: st_multipolygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MPolyFromText($1, $2)$_$;


ALTER FUNCTION public.st_multipolygonfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 491 (class 1255 OID 30015)
-- Name: st_ndims(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ndims(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_ndims';


ALTER FUNCTION public.st_ndims(geometry) OWNER TO postgres;

--
-- TOC entry 1328 (class 1255 OID 30999)
-- Name: st_nearestvalue(raster, geometry, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_nearestvalue(rast raster, pt geometry, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_nearestvalue($1, 1, $2, $3) $_$;


ALTER FUNCTION public.st_nearestvalue(rast raster, pt geometry, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1330 (class 1255 OID 31001)
-- Name: st_nearestvalue(raster, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_nearestvalue(rast raster, columnx integer, rowy integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_nearestvalue($1, 1, st_setsrid(st_makepoint(st_rastertoworldcoordx($1, $2, $3), st_rastertoworldcoordy($1, $2, $3)), st_srid($1)), $4) $_$;


ALTER FUNCTION public.st_nearestvalue(rast raster, columnx integer, rowy integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1327 (class 1255 OID 30998)
-- Name: st_nearestvalue(raster, integer, geometry, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_nearestvalue(rast raster, band integer, pt geometry, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_nearestValue';


ALTER FUNCTION public.st_nearestvalue(rast raster, band integer, pt geometry, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1329 (class 1255 OID 31000)
-- Name: st_nearestvalue(raster, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_nearestvalue(rast raster, band integer, columnx integer, rowy integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_nearestvalue($1, $2, st_setsrid(st_makepoint(st_rastertoworldcoordx($1, $3, $4), st_rastertoworldcoordy($1, $3, $4)), st_srid($1)), $5) $_$;


ALTER FUNCTION public.st_nearestvalue(rast raster, band integer, columnx integer, rowy integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1335 (class 1255 OID 31006)
-- Name: st_neighborhood(raster, geometry, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_neighborhood(rast raster, pt geometry, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_neighborhood($1, 1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_neighborhood(rast raster, pt geometry, distancex integer, distancey integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1333 (class 1255 OID 31004)
-- Name: st_neighborhood(raster, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_neighborhood(rast raster, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_neighborhood($1, 1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_neighborhood(rast raster, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1334 (class 1255 OID 31005)
-- Name: st_neighborhood(raster, integer, geometry, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_neighborhood(rast raster, band integer, pt geometry, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		wx double precision;
		wy double precision;
		rtn double precision[][];
	BEGIN
		IF (st_geometrytype($3) != 'ST_Point') THEN
			RAISE EXCEPTION 'Attempting to get the neighbor of a pixel with a non-point geometry';
		END IF;

		IF ST_SRID(rast) != ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
		END IF;

		wx := st_x($3);
		wy := st_y($3);

		SELECT _st_neighborhood(
			$1, $2,
			st_worldtorastercoordx(rast, wx, wy),
			st_worldtorastercoordy(rast, wx, wy),
			$4, $5,
			$6
		) INTO rtn;
		RETURN rtn;
	END;
	$_$;


ALTER FUNCTION public.st_neighborhood(rast raster, band integer, pt geometry, distancex integer, distancey integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1332 (class 1255 OID 31003)
-- Name: st_neighborhood(raster, integer, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_neighborhood(rast raster, band integer, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_neighborhood($1, $2, $3, $4, $5, $6, $7) $_$;


ALTER FUNCTION public.st_neighborhood(rast raster, band integer, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 613 (class 1255 OID 30166)
-- Name: st_node(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_node(g geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_Node';


ALTER FUNCTION public.st_node(g geometry) OWNER TO postgres;

--
-- TOC entry 1270 (class 1255 OID 30927)
-- Name: st_notsamealignmentreason(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_notsamealignmentreason(rast1 raster, rast2 raster) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_notSameAlignmentReason';


ALTER FUNCTION public.st_notsamealignmentreason(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 451 (class 1255 OID 29974)
-- Name: st_npoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_npoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_npoints';


ALTER FUNCTION public.st_npoints(geometry) OWNER TO postgres;

--
-- TOC entry 452 (class 1255 OID 29975)
-- Name: st_nrings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_nrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_nrings';


ALTER FUNCTION public.st_nrings(geometry) OWNER TO postgres;

--
-- TOC entry 919 (class 1255 OID 30543)
-- Name: st_numbands(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numbands(raster) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getNumBands';


ALTER FUNCTION public.st_numbands(raster) OWNER TO postgres;

--
-- TOC entry 683 (class 1255 OID 30247)
-- Name: st_numgeometries(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numgeometries(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_numgeometries_collection';


ALTER FUNCTION public.st_numgeometries(geometry) OWNER TO postgres;

--
-- TOC entry 688 (class 1255 OID 30252)
-- Name: st_numinteriorring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numinteriorring(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_numinteriorrings_polygon';


ALTER FUNCTION public.st_numinteriorring(geometry) OWNER TO postgres;

--
-- TOC entry 687 (class 1255 OID 30251)
-- Name: st_numinteriorrings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numinteriorrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_numinteriorrings_polygon';


ALTER FUNCTION public.st_numinteriorrings(geometry) OWNER TO postgres;

--
-- TOC entry 693 (class 1255 OID 30257)
-- Name: st_numpatches(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numpatches(geometry) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN ST_GeometryType($1) = 'ST_PolyhedralSurface'
	THEN ST_NumGeometries($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_numpatches(geometry) OWNER TO postgres;

--
-- TOC entry 682 (class 1255 OID 30246)
-- Name: st_numpoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numpoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_numpoints_linestring';


ALTER FUNCTION public.st_numpoints(geometry) OWNER TO postgres;

--
-- TOC entry 588 (class 1255 OID 30138)
-- Name: st_offsetcurve(geometry, double precision, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_offsetcurve(line geometry, distance double precision, params text DEFAULT ''::text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_OffsetCurve';


ALTER FUNCTION public.st_offsetcurve(line geometry, distance double precision, params text) OWNER TO postgres;

--
-- TOC entry 895 (class 1255 OID 30502)
-- Name: st_orderingequals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_orderingequals(geometrya geometry, geometryb geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT $1 ~= $2 AND _ST_OrderingEquals($1, $2)
	$_$;


ALTER FUNCTION public.st_orderingequals(geometrya geometry, geometryb geometry) OWNER TO postgres;

--
-- TOC entry 650 (class 1255 OID 30214)
-- Name: st_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_overlaps(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Overlaps($1,$2)$_$;


ALTER FUNCTION public.st_overlaps(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1281 (class 1255 OID 30939)
-- Name: st_overlaps(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_overlaps(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_overlaps($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_overlaps(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1280 (class 1255 OID 30938)
-- Name: st_overlaps(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_overlaps(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_overlaps(st_convexhull($1), st_convexhull($3)) ELSE _st_overlaps($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_overlaps(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 694 (class 1255 OID 30258)
-- Name: st_patchn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_patchn(geometry, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN ST_GeometryType($1) = 'ST_PolyhedralSurface'
	THEN ST_GeometryN($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_patchn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 461 (class 1255 OID 29984)
-- Name: st_perimeter(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_perimeter(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_perimeter2d_poly';


ALTER FUNCTION public.st_perimeter(geometry) OWNER TO postgres;

--
-- TOC entry 849 (class 1255 OID 30449)
-- Name: st_perimeter(geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_perimeter(geog geography, use_spheroid boolean DEFAULT true) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_perimeter';


ALTER FUNCTION public.st_perimeter(geog geography, use_spheroid boolean) OWNER TO postgres;

--
-- TOC entry 460 (class 1255 OID 29983)
-- Name: st_perimeter2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_perimeter2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_perimeter2d_poly';


ALTER FUNCTION public.st_perimeter2d(geometry) OWNER TO postgres;

--
-- TOC entry 1235 (class 1255 OID 30854)
-- Name: st_pixelascentroid(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelascentroid(rast raster, x integer, y integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Centroid(geom) FROM _st_pixelaspolygons($1, NULL, $2, $3) $_$;


ALTER FUNCTION public.st_pixelascentroid(rast raster, x integer, y integer) OWNER TO postgres;

--
-- TOC entry 1234 (class 1255 OID 30853)
-- Name: st_pixelascentroids(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelascentroids(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Centroid(geom), val, x, y FROM _st_pixelaspolygons($1, $2, NULL, NULL, $3) $_$;


ALTER FUNCTION public.st_pixelascentroids(rast raster, band integer, exclude_nodata_value boolean, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 1233 (class 1255 OID 30852)
-- Name: st_pixelaspoint(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelaspoint(rast raster, x integer, y integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_PointN(ST_ExteriorRing(geom), 1) FROM _st_pixelaspolygons($1, NULL, $2, $3) $_$;


ALTER FUNCTION public.st_pixelaspoint(rast raster, x integer, y integer) OWNER TO postgres;

--
-- TOC entry 1232 (class 1255 OID 30851)
-- Name: st_pixelaspoints(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelaspoints(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_PointN(ST_ExteriorRing(geom), 1), val, x, y FROM _st_pixelaspolygons($1, $2, NULL, NULL, $3) $_$;


ALTER FUNCTION public.st_pixelaspoints(rast raster, band integer, exclude_nodata_value boolean, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 1231 (class 1255 OID 30850)
-- Name: st_pixelaspolygon(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelaspolygon(rast raster, x integer, y integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT geom FROM _st_pixelaspolygons($1, NULL, $2, $3) $_$;


ALTER FUNCTION public.st_pixelaspolygon(rast raster, x integer, y integer) OWNER TO postgres;

--
-- TOC entry 1230 (class 1255 OID 30849)
-- Name: st_pixelaspolygons(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelaspolygons(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT geom, val, x, y FROM _st_pixelaspolygons($1, $2, NULL, NULL, $3) $_$;


ALTER FUNCTION public.st_pixelaspolygons(rast raster, band integer, exclude_nodata_value boolean, OUT geom geometry, OUT val double precision, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 929 (class 1255 OID 30553)
-- Name: st_pixelheight(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelheight(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getPixelHeight';


ALTER FUNCTION public.st_pixelheight(raster) OWNER TO postgres;

--
-- TOC entry 1172 (class 1255 OID 30813)
-- Name: st_pixelofvalue(raster, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelofvalue(rast raster, search double precision[], exclude_nodata_value boolean DEFAULT true, OUT val double precision, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT val, x, y FROM st_pixelofvalue($1, 1, $2, $3) $_$;


ALTER FUNCTION public.st_pixelofvalue(rast raster, search double precision[], exclude_nodata_value boolean, OUT val double precision, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 1194 (class 1255 OID 30815)
-- Name: st_pixelofvalue(raster, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelofvalue(rast raster, search double precision, exclude_nodata_value boolean DEFAULT true, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT x, y FROM st_pixelofvalue($1, 1, ARRAY[$2], $3) $_$;


ALTER FUNCTION public.st_pixelofvalue(rast raster, search double precision, exclude_nodata_value boolean, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 1138 (class 1255 OID 30812)
-- Name: st_pixelofvalue(raster, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelofvalue(rast raster, nband integer, search double precision[], exclude_nodata_value boolean DEFAULT true, OUT val double precision, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_pixelOfValue';


ALTER FUNCTION public.st_pixelofvalue(rast raster, nband integer, search double precision[], exclude_nodata_value boolean, OUT val double precision, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 1193 (class 1255 OID 30814)
-- Name: st_pixelofvalue(raster, integer, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelofvalue(rast raster, nband integer, search double precision, exclude_nodata_value boolean DEFAULT true, OUT x integer, OUT y integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT x, y FROM st_pixelofvalue($1, $2, ARRAY[$3], $4) $_$;


ALTER FUNCTION public.st_pixelofvalue(rast raster, nband integer, search double precision, exclude_nodata_value boolean, OUT x integer, OUT y integer) OWNER TO postgres;

--
-- TOC entry 928 (class 1255 OID 30552)
-- Name: st_pixelwidth(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pixelwidth(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getPixelWidth';


ALTER FUNCTION public.st_pixelwidth(raster) OWNER TO postgres;

--
-- TOC entry 896 (class 1255 OID 30503)
-- Name: st_point(double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_point(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_point(double precision, double precision) OWNER TO postgres;

--
-- TOC entry 466 (class 1255 OID 29989)
-- Name: st_point_inside_circle(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_point_inside_circle(geometry, double precision, double precision, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_inside_circle_point';


ALTER FUNCTION public.st_point_inside_circle(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 680 (class 1255 OID 30244)
-- Name: st_pointfromgeohash(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromgeohash(text, integer DEFAULT NULL::integer) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-2.1', 'point_from_geohash';


ALTER FUNCTION public.st_pointfromgeohash(text, integer) OWNER TO postgres;

--
-- TOC entry 709 (class 1255 OID 30273)
-- Name: st_pointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromtext(text) OWNER TO postgres;

--
-- TOC entry 710 (class 1255 OID 30274)
-- Name: st_pointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 733 (class 1255 OID 30297)
-- Name: st_pointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 732 (class 1255 OID 30296)
-- Name: st_pointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 692 (class 1255 OID 30256)
-- Name: st_pointn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_pointn_linestring';


ALTER FUNCTION public.st_pointn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 654 (class 1255 OID 30218)
-- Name: st_pointonsurface(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointonsurface(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'pointonsurface';


ALTER FUNCTION public.st_pointonsurface(geometry) OWNER TO postgres;

--
-- TOC entry 713 (class 1255 OID 30277)
-- Name: st_polyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromtext(text) OWNER TO postgres;

--
-- TOC entry 714 (class 1255 OID 30278)
-- Name: st_polyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POLYGON'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 739 (class 1255 OID 30303)
-- Name: st_polyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 738 (class 1255 OID 30302)
-- Name: st_polyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 897 (class 1255 OID 30504)
-- Name: st_polygon(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygon(geometry, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT ST_SetSRID(ST_MakePolygon($1), $2)
	$_$;


ALTER FUNCTION public.st_polygon(geometry, integer) OWNER TO postgres;

--
-- TOC entry 1228 (class 1255 OID 30847)
-- Name: st_polygon(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygon(rast raster, band integer DEFAULT 1) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getPolygon';


ALTER FUNCTION public.st_polygon(rast raster, band integer) OWNER TO postgres;

--
-- TOC entry 716 (class 1255 OID 30280)
-- Name: st_polygonfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_PolyFromText($1)$_$;


ALTER FUNCTION public.st_polygonfromtext(text) OWNER TO postgres;

--
-- TOC entry 715 (class 1255 OID 30279)
-- Name: st_polygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_PolyFromText($1, $2)$_$;


ALTER FUNCTION public.st_polygonfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 741 (class 1255 OID 30305)
-- Name: st_polygonfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polygonfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 740 (class 1255 OID 30304)
-- Name: st_polygonfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polygonfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 520 (class 1255 OID 30044)
-- Name: st_polygonize(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonize(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'polygonize_garray';


ALTER FUNCTION public.st_polygonize(geometry[]) OWNER TO postgres;

--
-- TOC entry 847 (class 1255 OID 30447)
-- Name: st_project(geography, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_project(geog geography, distance double precision, azimuth double precision) RETURNS geography
    LANGUAGE c IMMUTABLE COST 100
    AS '$libdir/postgis-2.1', 'geography_project';


ALTER FUNCTION public.st_project(geog geography, distance double precision, azimuth double precision) OWNER TO postgres;

--
-- TOC entry 1003 (class 1255 OID 30627)
-- Name: st_quantile(raster, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_quantile($1, 1, TRUE, 1, $2) $_$;


ALTER FUNCTION public.st_quantile(rast raster, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 959 (class 1255 OID 30631)
-- Name: st_quantile(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_quantile($1, 1, TRUE, 1, ARRAY[$2]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rast raster, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1019 (class 1255 OID 30644)
-- Name: st_quantile(text, text, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, 1, TRUE, 1, $3) $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 983 (class 1255 OID 30648)
-- Name: st_quantile(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, 1, TRUE, 1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1006 (class 1255 OID 30630)
-- Name: st_quantile(raster, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT (_st_quantile($1, 1, $2, 1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rast raster, exclude_nodata_value boolean, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1002 (class 1255 OID 30626)
-- Name: st_quantile(raster, integer, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, TRUE, 1, $3) $_$;


ALTER FUNCTION public.st_quantile(rast raster, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1005 (class 1255 OID 30629)
-- Name: st_quantile(raster, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, nband integer, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, TRUE, 1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rast raster, nband integer, quantile double precision) OWNER TO postgres;

--
-- TOC entry 972 (class 1255 OID 30647)
-- Name: st_quantile(text, text, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) RETURNS double precision
    LANGUAGE sql STABLE
    AS $_$ SELECT (_st_quantile($1, $2, 1, $3, 1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1018 (class 1255 OID 30643)
-- Name: st_quantile(text, text, integer, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, $3, TRUE, 1, $4) $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1021 (class 1255 OID 30646)
-- Name: st_quantile(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, TRUE, 1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1001 (class 1255 OID 30625)
-- Name: st_quantile(raster, integer, boolean, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, 1, $4) $_$;


ALTER FUNCTION public.st_quantile(rast raster, nband integer, exclude_nodata_value boolean, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1004 (class 1255 OID 30628)
-- Name: st_quantile(raster, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rast raster, nband integer, exclude_nodata_value boolean, quantile double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, 1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rast raster, nband integer, exclude_nodata_value boolean, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1017 (class 1255 OID 30642)
-- Name: st_quantile(text, text, integer, boolean, double precision[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, $4, 1, $5) $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO postgres;

--
-- TOC entry 1020 (class 1255 OID 30645)
-- Name: st_quantile(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, $4, 1, ARRAY[$5]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantile double precision) OWNER TO postgres;

--
-- TOC entry 1159 (class 1255 OID 30778)
-- Name: st_range4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_range4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		min double precision;
		max double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		min := 'Infinity'::double precision;
		max := '-Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					IF _value[z][y][x] < min THEN
						min := _value[z][y][x];
					END IF;
					IF _value[z][y][x] > max THEN
						max := _value[z][y][x];
					END IF;
				END LOOP;
			END LOOP;
		END LOOP;

		IF max = '-Infinity'::double precision OR min = 'Infinity'::double precision THEN
			RETURN NULL;
		END IF;

		RETURN max - min;
	END;
	$$;


ALTER FUNCTION public.st_range4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1140 (class 1255 OID 30760)
-- Name: st_range4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;


ALTER FUNCTION public.st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1244 (class 1255 OID 30865)
-- Name: st_rastertoworldcoord(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rastertoworldcoord(rast raster, columnx integer, rowy integer, OUT longitude double precision, OUT latitude double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT longitude, latitude FROM _st_rastertoworldcoord($1, $2, $3) $_$;


ALTER FUNCTION public.st_rastertoworldcoord(rast raster, columnx integer, rowy integer, OUT longitude double precision, OUT latitude double precision) OWNER TO postgres;

--
-- TOC entry 1246 (class 1255 OID 30867)
-- Name: st_rastertoworldcoordx(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rastertoworldcoordx(rast raster, xr integer) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT longitude FROM _st_rastertoworldcoord($1, $2, NULL) $_$;


ALTER FUNCTION public.st_rastertoworldcoordx(rast raster, xr integer) OWNER TO postgres;

--
-- TOC entry 1245 (class 1255 OID 30866)
-- Name: st_rastertoworldcoordx(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rastertoworldcoordx(rast raster, xr integer, yr integer) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT longitude FROM _st_rastertoworldcoord($1, $2, $3) $_$;


ALTER FUNCTION public.st_rastertoworldcoordx(rast raster, xr integer, yr integer) OWNER TO postgres;

--
-- TOC entry 1248 (class 1255 OID 30869)
-- Name: st_rastertoworldcoordy(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rastertoworldcoordy(rast raster, yr integer) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT latitude FROM _st_rastertoworldcoord($1, NULL, $2) $_$;


ALTER FUNCTION public.st_rastertoworldcoordy(rast raster, yr integer) OWNER TO postgres;

--
-- TOC entry 1247 (class 1255 OID 30868)
-- Name: st_rastertoworldcoordy(raster, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rastertoworldcoordy(rast raster, xr integer, yr integer) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT latitude FROM _st_rastertoworldcoord($1, $2, $3) $_$;


ALTER FUNCTION public.st_rastertoworldcoordy(rast raster, xr integer, yr integer) OWNER TO postgres;

--
-- TOC entry 1061 (class 1255 OID 30688)
-- Name: st_reclass(raster, reclassarg[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reclass(rast raster, VARIADIC reclassargset reclassarg[]) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		i int;
		expr text;
	BEGIN
		-- for each reclassarg, validate elements as all except nodataval cannot be NULL
		FOR i IN SELECT * FROM generate_subscripts($2, 1) LOOP
			IF $2[i].nband IS NULL OR $2[i].reclassexpr IS NULL OR $2[i].pixeltype IS NULL THEN
				RAISE WARNING 'Values are required for the nband, reclassexpr and pixeltype attributes.';
				RETURN rast;
			END IF;
		END LOOP;

		RETURN _st_reclass($1, VARIADIC $2);
	END;
	$_$;


ALTER FUNCTION public.st_reclass(rast raster, VARIADIC reclassargset reclassarg[]) OWNER TO postgres;

--
-- TOC entry 1063 (class 1255 OID 30690)
-- Name: st_reclass(raster, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reclass(rast raster, reclassexpr text, pixeltype text) RETURNS raster
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_reclass($1, ROW(1, $2, $3, NULL)) $_$;


ALTER FUNCTION public.st_reclass(rast raster, reclassexpr text, pixeltype text) OWNER TO postgres;

--
-- TOC entry 1062 (class 1255 OID 30689)
-- Name: st_reclass(raster, integer, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reclass(rast raster, nband integer, reclassexpr text, pixeltype text, nodataval double precision DEFAULT NULL::double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_reclass($1, ROW($2, $3, $4, $5)) $_$;


ALTER FUNCTION public.st_reclass(rast raster, nband integer, reclassexpr text, pixeltype text, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 627 (class 1255 OID 30191)
-- Name: st_relate(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_relate(geom1 geometry, geom2 geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'relate_full';


ALTER FUNCTION public.st_relate(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 628 (class 1255 OID 30192)
-- Name: st_relate(geometry, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_relate(geom1 geometry, geom2 geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'relate_full';


ALTER FUNCTION public.st_relate(geom1 geometry, geom2 geometry, integer) OWNER TO postgres;

--
-- TOC entry 629 (class 1255 OID 30193)
-- Name: st_relate(geometry, geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_relate(geom1 geometry, geom2 geometry, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'relate_pattern';


ALTER FUNCTION public.st_relate(geom1 geometry, geom2 geometry, text) OWNER TO postgres;

--
-- TOC entry 612 (class 1255 OID 30165)
-- Name: st_relatematch(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_relatematch(text, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_RelateMatch';


ALTER FUNCTION public.st_relatematch(text, text) OWNER TO postgres;

--
-- TOC entry 514 (class 1255 OID 30038)
-- Name: st_removepoint(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_removepoint(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_removepoint';


ALTER FUNCTION public.st_removepoint(geometry, integer) OWNER TO postgres;

--
-- TOC entry 606 (class 1255 OID 30159)
-- Name: st_removerepeatedpoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_removerepeatedpoints(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_RemoveRepeatedPoints';


ALTER FUNCTION public.st_removerepeatedpoints(geometry) OWNER TO postgres;

--
-- TOC entry 1102 (class 1255 OID 30726)
-- Name: st_resample(raster, raster, boolean, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resample(rast raster, ref raster, usescale boolean, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT st_resample($1, $2, $4, $5, $3) $_$;


ALTER FUNCTION public.st_resample(rast raster, ref raster, usescale boolean, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1101 (class 1255 OID 30725)
-- Name: st_resample(raster, raster, text, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resample(rast raster, ref raster, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, usescale boolean DEFAULT true) RETURNS raster
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		rastsrid int;

		_srid int;
		_dimx int;
		_dimy int;
		_scalex double precision;
		_scaley double precision;
		_gridx double precision;
		_gridy double precision;
		_skewx double precision;
		_skewy double precision;
	BEGIN
		SELECT srid, width, height, scalex, scaley, upperleftx, upperlefty, skewx, skewy INTO _srid, _dimx, _dimy, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy FROM st_metadata($2);

		rastsrid := ST_SRID($1);

		-- both rasters must have the same SRID
		IF (rastsrid != _srid) THEN
			RAISE EXCEPTION 'The raster to be resampled has a different SRID from the reference raster';
			RETURN NULL;
		END IF;

		IF usescale IS TRUE THEN
			_dimx := NULL;
			_dimy := NULL;
		ELSE
			_scalex := NULL;
			_scaley := NULL;
		END IF;

		RETURN _st_gdalwarp($1, $3, $4, NULL, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy, _dimx, _dimy);
	END;
	$_$;


ALTER FUNCTION public.st_resample(rast raster, ref raster, algorithm text, maxerr double precision, usescale boolean) OWNER TO postgres;

--
-- TOC entry 1099 (class 1255 OID 30723)
-- Name: st_resample(raster, double precision, double precision, double precision, double precision, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resample(rast raster, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_gdalwarp($1, $8,	$9, NULL, $2, $3, $4, $5, $6, $7) $_$;


ALTER FUNCTION public.st_resample(rast raster, scalex double precision, scaley double precision, gridx double precision, gridy double precision, skewx double precision, skewy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1100 (class 1255 OID 30724)
-- Name: st_resample(raster, integer, integer, double precision, double precision, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resample(rast raster, width integer, height integer, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_gdalwarp($1, $8,	$9, NULL, NULL, NULL, $4, $5, $6, $7, $2, $3) $_$;


ALTER FUNCTION public.st_resample(rast raster, width integer, height integer, gridx double precision, gridy double precision, skewx double precision, skewy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1109 (class 1255 OID 30732)
-- Name: st_rescale(raster, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rescale(rast raster, scalexy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $3, $4, NULL, $2, $2) $_$;


ALTER FUNCTION public.st_rescale(rast raster, scalexy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1108 (class 1255 OID 30731)
-- Name: st_rescale(raster, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rescale(rast raster, scalex double precision, scaley double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $4, $5, NULL, $2, $3) $_$;


ALTER FUNCTION public.st_rescale(rast raster, scalex double precision, scaley double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1118 (class 1255 OID 30740)
-- Name: st_resize(raster, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resize(rast raster, percentwidth double precision, percentheight double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		_width integer;
		_height integer;
	BEGIN
		-- range check
		IF $2 <= 0. OR $2 > 1. OR $3 <= 0. OR $3 > 1. THEN
			RAISE EXCEPTION 'Percentages must be a value greater than zero and less than or equal to one, e.g. 0.5 for 50%%';
		END IF;

		SELECT width, height INTO _width, _height FROM ST_Metadata($1);

		_width := round(_width::double precision * $2)::integer;
		_height:= round(_height::double precision * $3)::integer;

		IF _width < 1 THEN
			_width := 1;
		END IF;
		IF _height < 1 THEN
			_height := 1;
		END IF;

		RETURN _st_gdalwarp(
			$1,
			$4, $5,
			NULL,
			NULL, NULL,
			NULL, NULL,
			NULL, NULL,
			_width, _height
		);
	END;
	$_$;


ALTER FUNCTION public.st_resize(rast raster, percentwidth double precision, percentheight double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1117 (class 1255 OID 30739)
-- Name: st_resize(raster, integer, integer, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resize(rast raster, width integer, height integer, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $4, $5, NULL, NULL, NULL, NULL, NULL, NULL, NULL, abs($2), abs($3)) $_$;


ALTER FUNCTION public.st_resize(rast raster, width integer, height integer, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1116 (class 1255 OID 30738)
-- Name: st_resize(raster, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_resize(rast raster, width text, height text, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		i integer;

		wh text[2];

		whi integer[2];
		whd double precision[2];

		_width integer;
		_height integer;
	BEGIN
		wh[1] := trim(both from $2);
		wh[2] := trim(both from $3);

		-- see if width and height are percentages
		FOR i IN 1..2 LOOP
			IF position('%' in wh[i]) > 0 THEN
				BEGIN
					wh[i] := (regexp_matches(wh[i], E'^(\\d*.?\\d*)%{1}$'))[1];
					IF length(wh[i]) < 1 THEN
						RAISE invalid_parameter_value;
					END IF;

					whd[i] := wh[i]::double precision * 0.01;
				EXCEPTION WHEN OTHERS THEN
					RAISE EXCEPTION 'Invalid percentage value provided for width/height';
					RETURN NULL;
				END;
			ELSE
				BEGIN
					whi[i] := abs(wh[i]::integer);
				EXCEPTION WHEN OTHERS THEN
					RAISE EXCEPTION 'Non-integer value provided for width/height';
					RETURN NULL;
				END;
			END IF;
		END LOOP;

		IF whd[1] IS NOT NULL OR whd[2] IS NOT NULL THEN
			SELECT foo.width, foo.height INTO _width, _height FROM ST_Metadata($1) AS foo;

			IF whd[1] IS NOT NULL THEN
				whi[1] := round(_width::double precision * whd[1])::integer;
			END IF;

			IF whd[2] IS NOT NULL THEN
				whi[2] := round(_height::double precision * whd[2])::integer;
			END IF;

		END IF;

		-- should NEVER be here
		IF whi[1] IS NULL OR whi[2] IS NULL THEN
			RAISE EXCEPTION 'Unable to determine appropriate width or height';
			RETURN NULL;
		END IF;

		FOR i IN 1..2 LOOP
			IF whi[i] < 1 THEN
				whi[i] = 1;
			END IF;
		END LOOP;

		RETURN _st_gdalwarp(
			$1,
			$4, $5,
			NULL,
			NULL, NULL,
			NULL, NULL,
			NULL, NULL,
			whi[1], whi[2]
		);
	END;
	$_$;


ALTER FUNCTION public.st_resize(rast raster, width text, height text, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1111 (class 1255 OID 30734)
-- Name: st_reskew(raster, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reskew(rast raster, skewxy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $3, $4, NULL, 0, 0, NULL, NULL, $2, $2) $_$;


ALTER FUNCTION public.st_reskew(rast raster, skewxy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1110 (class 1255 OID 30733)
-- Name: st_reskew(raster, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reskew(rast raster, skewx double precision, skewy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $4, $5, NULL, 0, 0, NULL, NULL, $2, $3) $_$;


ALTER FUNCTION public.st_reskew(rast raster, skewx double precision, skewy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 487 (class 1255 OID 30011)
-- Name: st_reverse(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reverse(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_reverse';


ALTER FUNCTION public.st_reverse(geometry) OWNER TO postgres;

--
-- TOC entry 417 (class 1255 OID 29941)
-- Name: st_rotate(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotate(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$_$;


ALTER FUNCTION public.st_rotate(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 419 (class 1255 OID 29943)
-- Name: st_rotate(geometry, double precision, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotate(geometry, double precision, geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  cos($2), -sin($2), 0,  sin($2),  cos($2), 0, 0, 0, 1, ST_X($3) - cos($2) * ST_X($3) + sin($2) * ST_Y($3), ST_Y($3) - sin($2) * ST_X($3) - cos($2) * ST_Y($3), 0)$_$;


ALTER FUNCTION public.st_rotate(geometry, double precision, geometry) OWNER TO postgres;

--
-- TOC entry 418 (class 1255 OID 29942)
-- Name: st_rotate(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotate(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  cos($2), -sin($2), 0,  sin($2),  cos($2), 0, 0, 0, 1,	$3 - cos($2) * $3 + sin($2) * $4, $4 - sin($2) * $3 - cos($2) * $4, 0)$_$;


ALTER FUNCTION public.st_rotate(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 421 (class 1255 OID 29945)
-- Name: st_rotatex(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotatex(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$_$;


ALTER FUNCTION public.st_rotatex(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 422 (class 1255 OID 29946)
-- Name: st_rotatey(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotatey(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$_$;


ALTER FUNCTION public.st_rotatey(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 420 (class 1255 OID 29944)
-- Name: st_rotatez(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotatez(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Rotate($1, $2)$_$;


ALTER FUNCTION public.st_rotatez(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 931 (class 1255 OID 30555)
-- Name: st_rotation(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotation(raster) RETURNS double precision
    LANGUAGE sql
    AS $_$ SELECT (ST_Geotransform($1)).theta_i $_$;


ALTER FUNCTION public.st_rotation(raster) OWNER TO postgres;

--
-- TOC entry 1177 (class 1255 OID 30796)
-- Name: st_roughness(raster, integer, raster, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_roughness(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_rast raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent raster;
		_extenttype text;
	BEGIN
		_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
		ELSE
			_extenttype := 'CUSTOM';
		END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
			_nband := 1;
			_pixtype := NULL;
		ELSE
			_rast := rast;
			_nband := nband;
			_pixtype := pixeltype;
		END IF;

		RETURN ST_MapAlgebra(
			ARRAY[ROW(_rast, _nband)]::rastbandarg[],
			'_st_roughness4ma(double precision[][][], integer[][], text[])'::regprocedure,
			_pixtype,
			_extenttype, _customextent,
			1, 1);
	END;
	$$;


ALTER FUNCTION public.st_roughness(rast raster, nband integer, customextent raster, pixeltype text, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 1082 (class 1255 OID 30919)
-- Name: st_samealignment(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_samealignment(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_sameAlignment';


ALTER FUNCTION public.st_samealignment(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1267 (class 1255 OID 30920)
-- Name: st_samealignment(double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_samealignment(st_makeemptyraster(1, 1, $1, $2, $3, $4, $5, $6), st_makeemptyraster(1, 1, $7, $8, $9, $10, $11, $12)) $_$;


ALTER FUNCTION public.st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision) OWNER TO postgres;

--
-- TOC entry 426 (class 1255 OID 29950)
-- Name: st_scale(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_scale(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Scale($1, $2, $3, 1)$_$;


ALTER FUNCTION public.st_scale(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 425 (class 1255 OID 29949)
-- Name: st_scale(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_scale(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$_$;


ALTER FUNCTION public.st_scale(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 920 (class 1255 OID 30544)
-- Name: st_scalex(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_scalex(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getXScale';


ALTER FUNCTION public.st_scalex(raster) OWNER TO postgres;

--
-- TOC entry 921 (class 1255 OID 30545)
-- Name: st_scaley(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_scaley(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getYScale';


ALTER FUNCTION public.st_scaley(raster) OWNER TO postgres;

--
-- TOC entry 856 (class 1255 OID 30456)
-- Name: st_segmentize(geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_segmentize(geog geography, max_segment_length double precision) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'geography_segmentize';


ALTER FUNCTION public.st_segmentize(geog geography, max_segment_length double precision) OWNER TO postgres;

--
-- TOC entry 573 (class 1255 OID 30123)
-- Name: st_segmentize(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_segmentize(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_segmentize2d';


ALTER FUNCTION public.st_segmentize(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 1213 (class 1255 OID 30833)
-- Name: st_setbandisnodata(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setbandisnodata(rast raster, band integer DEFAULT 1) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setBandIsNoData';


ALTER FUNCTION public.st_setbandisnodata(rast raster, band integer) OWNER TO postgres;

--
-- TOC entry 1212 (class 1255 OID 30832)
-- Name: st_setbandnodatavalue(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setbandnodatavalue(rast raster, nodatavalue double precision) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_setbandnodatavalue($1, 1, $2, FALSE) $_$;


ALTER FUNCTION public.st_setbandnodatavalue(rast raster, nodatavalue double precision) OWNER TO postgres;

--
-- TOC entry 1211 (class 1255 OID 30831)
-- Name: st_setbandnodatavalue(raster, integer, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setbandnodatavalue(rast raster, band integer, nodatavalue double precision, forcechecking boolean DEFAULT false) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_setBandNoDataValue';


ALTER FUNCTION public.st_setbandnodatavalue(rast raster, band integer, nodatavalue double precision, forcechecking boolean) OWNER TO postgres;

--
-- TOC entry 1204 (class 1255 OID 30825)
-- Name: st_setgeoreference(raster, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setgeoreference(rast raster, georef text, format text DEFAULT 'GDAL'::text) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
    DECLARE
        params text[];
        rastout raster;
    BEGIN
        IF rast IS NULL THEN
            RAISE WARNING 'Cannot set georeferencing on a null raster in st_setgeoreference.';
            RETURN rastout;
        END IF;

        SELECT regexp_matches(georef,
            E'(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)\\s' ||
            E'(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)') INTO params;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'st_setgeoreference requires a string with 6 floating point values.';
        END IF;

        IF format = 'ESRI' THEN
            -- params array is now:
            -- {scalex, skewy, skewx, scaley, upperleftx, upperlefty}
            rastout := st_setscale(rast, params[1]::float8, params[4]::float8);
            rastout := st_setskew(rastout, params[3]::float8, params[2]::float8);
            rastout := st_setupperleft(rastout,
                                   params[5]::float8 - (params[1]::float8 * 0.5),
                                   params[6]::float8 - (params[4]::float8 * 0.5));
        ELSE
            IF format != 'GDAL' THEN
                RAISE WARNING 'Format ''%'' is not recognized, defaulting to GDAL format.', format;
            END IF;
            -- params array is now:
            -- {scalex, skewy, skewx, scaley, upperleftx, upperlefty}

            rastout := st_setscale(rast, params[1]::float8, params[4]::float8);
            rastout := st_setskew( rastout, params[3]::float8, params[2]::float8);
            rastout := st_setupperleft(rastout, params[5]::float8, params[6]::float8);
        END IF;
        RETURN rastout;
    END;
    $$;


ALTER FUNCTION public.st_setgeoreference(rast raster, georef text, format text) OWNER TO postgres;

--
-- TOC entry 1205 (class 1255 OID 30826)
-- Name: st_setgeoreference(raster, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setgeoreference(rast raster, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_setgeoreference($1, array_to_string(ARRAY[$4, $7, $6, $5, $2, $3], ' ')) $_$;


ALTER FUNCTION public.st_setgeoreference(rast raster, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision) OWNER TO postgres;

--
-- TOC entry 1203 (class 1255 OID 30824)
-- Name: st_setgeotransform(raster, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setgeotransform(rast raster, imag double precision, jmag double precision, theta_i double precision, theta_ij double precision, xoffset double precision, yoffset double precision) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_setGeotransform';


ALTER FUNCTION public.st_setgeotransform(rast raster, imag double precision, jmag double precision, theta_i double precision, theta_ij double precision, xoffset double precision, yoffset double precision) OWNER TO postgres;

--
-- TOC entry 515 (class 1255 OID 30039)
-- Name: st_setpoint(geometry, integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setpoint(geometry, integer, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_setpoint_linestring';


ALTER FUNCTION public.st_setpoint(geometry, integer, geometry) OWNER TO postgres;

--
-- TOC entry 1202 (class 1255 OID 30823)
-- Name: st_setrotation(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setrotation(rast raster, rotation double precision) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setRotation';


ALTER FUNCTION public.st_setrotation(rast raster, rotation double precision) OWNER TO postgres;

--
-- TOC entry 1196 (class 1255 OID 30817)
-- Name: st_setscale(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setscale(rast raster, scale double precision) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setScale';


ALTER FUNCTION public.st_setscale(rast raster, scale double precision) OWNER TO postgres;

--
-- TOC entry 1197 (class 1255 OID 30818)
-- Name: st_setscale(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setscale(rast raster, scalex double precision, scaley double precision) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setScaleXY';


ALTER FUNCTION public.st_setscale(rast raster, scalex double precision, scaley double precision) OWNER TO postgres;

--
-- TOC entry 1198 (class 1255 OID 30819)
-- Name: st_setskew(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setskew(rast raster, skew double precision) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setSkew';


ALTER FUNCTION public.st_setskew(rast raster, skew double precision) OWNER TO postgres;

--
-- TOC entry 1199 (class 1255 OID 30820)
-- Name: st_setskew(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setskew(rast raster, skewx double precision, skewy double precision) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setSkewXY';


ALTER FUNCTION public.st_setskew(rast raster, skewx double precision, skewy double precision) OWNER TO postgres;

--
-- TOC entry 700 (class 1255 OID 30264)
-- Name: st_setsrid(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setsrid(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_set_srid';


ALTER FUNCTION public.st_setsrid(geometry, integer) OWNER TO postgres;

--
-- TOC entry 1200 (class 1255 OID 30821)
-- Name: st_setsrid(raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setsrid(rast raster, srid integer) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setSRID';


ALTER FUNCTION public.st_setsrid(rast raster, srid integer) OWNER TO postgres;

--
-- TOC entry 1201 (class 1255 OID 30822)
-- Name: st_setupperleft(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setupperleft(rast raster, upperleftx double precision, upperlefty double precision) RETURNS raster
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_setUpperLeftXY';


ALTER FUNCTION public.st_setupperleft(rast raster, upperleftx double precision, upperlefty double precision) OWNER TO postgres;

--
-- TOC entry 1223 (class 1255 OID 30843)
-- Name: st_setvalue(raster, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalue(rast raster, geom geometry, newvalue double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_setvalues($1, 1, ARRAY[ROW($2, $3)]::geomval[], FALSE) $_$;


ALTER FUNCTION public.st_setvalue(rast raster, geom geometry, newvalue double precision) OWNER TO postgres;

--
-- TOC entry 1221 (class 1255 OID 30841)
-- Name: st_setvalue(raster, integer, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalue(rast raster, x integer, y integer, newvalue double precision) RETURNS raster
    LANGUAGE sql
    AS $_$ SELECT st_setvalue($1, 1, $2, $3, $4) $_$;


ALTER FUNCTION public.st_setvalue(rast raster, x integer, y integer, newvalue double precision) OWNER TO postgres;

--
-- TOC entry 1222 (class 1255 OID 30842)
-- Name: st_setvalue(raster, integer, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalue(rast raster, nband integer, geom geometry, newvalue double precision) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_setvalues($1, $2, ARRAY[ROW($3, $4)]::geomval[], FALSE) $_$;


ALTER FUNCTION public.st_setvalue(rast raster, nband integer, geom geometry, newvalue double precision) OWNER TO postgres;

--
-- TOC entry 1220 (class 1255 OID 30840)
-- Name: st_setvalue(raster, integer, integer, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalue(rast raster, band integer, x integer, y integer, newvalue double precision) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_setPixelValue';


ALTER FUNCTION public.st_setvalue(rast raster, band integer, x integer, y integer, newvalue double precision) OWNER TO postgres;

--
-- TOC entry 1219 (class 1255 OID 30839)
-- Name: st_setvalues(raster, integer, geomval[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalues(rast raster, nband integer, geomvalset geomval[], keepnodata boolean DEFAULT false) RETURNS raster
    LANGUAGE c IMMUTABLE
    AS '$libdir/rtpostgis-2.1', 'RASTER_setPixelValuesGeomval';


ALTER FUNCTION public.st_setvalues(rast raster, nband integer, geomvalset geomval[], keepnodata boolean) OWNER TO postgres;

--
-- TOC entry 1215 (class 1255 OID 30835)
-- Name: st_setvalues(raster, integer, integer, integer, double precision[], boolean[], boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], noset boolean[] DEFAULT NULL::boolean[], keepnodata boolean DEFAULT false) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_setvalues($1, $2, $3, $4, $5, $6, FALSE, NULL, $7) $_$;


ALTER FUNCTION public.st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], noset boolean[], keepnodata boolean) OWNER TO postgres;

--
-- TOC entry 1216 (class 1255 OID 30836)
-- Name: st_setvalues(raster, integer, integer, integer, double precision[], double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], nosetvalue double precision, keepnodata boolean DEFAULT false) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_setvalues($1, $2, $3, $4, $5, NULL, TRUE, $6, $7) $_$;


ALTER FUNCTION public.st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], nosetvalue double precision, keepnodata boolean) OWNER TO postgres;

--
-- TOC entry 1218 (class 1255 OID 30838)
-- Name: st_setvalues(raster, integer, integer, integer, integer, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalues(rast raster, x integer, y integer, width integer, height integer, newvalue double precision, keepnodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	BEGIN
		IF width <= 0 OR height <= 0 THEN
			RAISE EXCEPTION 'Values for width and height must be greater than zero';
			RETURN NULL;
		END IF;
		RETURN _st_setvalues($1, 1, $2, $3, array_fill($6, ARRAY[$5, $4]::int[]), NULL, FALSE, NULL, $7);
	END;
	$_$;


ALTER FUNCTION public.st_setvalues(rast raster, x integer, y integer, width integer, height integer, newvalue double precision, keepnodata boolean) OWNER TO postgres;

--
-- TOC entry 1217 (class 1255 OID 30837)
-- Name: st_setvalues(raster, integer, integer, integer, integer, integer, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setvalues(rast raster, nband integer, x integer, y integer, width integer, height integer, newvalue double precision, keepnodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	BEGIN
		IF width <= 0 OR height <= 0 THEN
			RAISE EXCEPTION 'Values for width and height must be greater than zero';
			RETURN NULL;
		END IF;
		RETURN _st_setvalues($1, $2, $3, $4, array_fill($7, ARRAY[$6, $5]::int[]), NULL, FALSE, NULL, $8);
	END;
	$_$;


ALTER FUNCTION public.st_setvalues(rast raster, nband integer, x integer, y integer, width integer, height integer, newvalue double precision, keepnodata boolean) OWNER TO postgres;

--
-- TOC entry 610 (class 1255 OID 30163)
-- Name: st_sharedpaths(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_sharedpaths(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_SharedPaths';


ALTER FUNCTION public.st_sharedpaths(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 428 (class 1255 OID 29952)
-- Name: st_shift_longitude(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_shift_longitude(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_longitude_shift';


ALTER FUNCTION public.st_shift_longitude(geometry) OWNER TO postgres;

--
-- TOC entry 758 (class 1255 OID 30322)
-- Name: st_shortestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_shortestline(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_shortestline2d';


ALTER FUNCTION public.st_shortestline(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 568 (class 1255 OID 30118)
-- Name: st_simplify(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_simplify(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_simplify2d';


ALTER FUNCTION public.st_simplify(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 592 (class 1255 OID 30142)
-- Name: st_simplifypreservetopology(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_simplifypreservetopology(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'topologypreservesimplify';


ALTER FUNCTION public.st_simplifypreservetopology(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 922 (class 1255 OID 30546)
-- Name: st_skewx(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_skewx(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getXSkew';


ALTER FUNCTION public.st_skewx(raster) OWNER TO postgres;

--
-- TOC entry 923 (class 1255 OID 30547)
-- Name: st_skewy(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_skewy(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getYSkew';


ALTER FUNCTION public.st_skewy(raster) OWNER TO postgres;

--
-- TOC entry 1164 (class 1255 OID 30786)
-- Name: st_slope(raster, integer, text, text, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_slope(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT st_slope($1, $2, NULL::raster, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_slope(rast raster, nband integer, pixeltype text, units text, scale double precision, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 1163 (class 1255 OID 30785)
-- Name: st_slope(raster, integer, raster, text, text, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_slope(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_rast raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent raster;
		_extenttype text;
	BEGIN
		_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
		ELSE
			_extenttype := 'CUSTOM';
		END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
			_nband := 1;
			_pixtype := NULL;
		ELSE
			_rast := rast;
			_nband := nband;
			_pixtype := pixeltype;
		END IF;

		-- get properties
		_pixwidth := ST_PixelWidth(_rast);
		_pixheight := ST_PixelHeight(_rast);
		SELECT width, height INTO _width, _height FROM ST_Metadata(_rast);

		RETURN ST_MapAlgebra(
			ARRAY[ROW(_rast, _nband)]::rastbandarg[],
			'_st_slope4ma(double precision[][][], integer[][], text[])'::regprocedure,
			_pixtype,
			_extenttype, _customextent,
			1, 1,
			_pixwidth::text, _pixheight::text,
			_width::text, _height::text,
			units::text, scale::text
		);
	END;
	$$;


ALTER FUNCTION public.st_slope(rast raster, nband integer, customextent raster, pixeltype text, units text, scale double precision, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 611 (class 1255 OID 30164)
-- Name: st_snap(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snap(geom1 geometry, geom2 geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_Snap';


ALTER FUNCTION public.st_snap(geom1 geometry, geom2 geometry, double precision) OWNER TO postgres;

--
-- TOC entry 571 (class 1255 OID 30121)
-- Name: st_snaptogrid(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SnapToGrid($1, 0, 0, $2, $2)$_$;


ALTER FUNCTION public.st_snaptogrid(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 570 (class 1255 OID 30120)
-- Name: st_snaptogrid(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SnapToGrid($1, 0, 0, $2, $3)$_$;


ALTER FUNCTION public.st_snaptogrid(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 569 (class 1255 OID 30119)
-- Name: st_snaptogrid(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_snaptogrid';


ALTER FUNCTION public.st_snaptogrid(geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 572 (class 1255 OID 30122)
-- Name: st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geom1 geometry, geom2 geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_snaptogrid_pointoff';


ALTER FUNCTION public.st_snaptogrid(geom1 geometry, geom2 geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1114 (class 1255 OID 30737)
-- Name: st_snaptogrid(raster, double precision, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(rast raster, gridx double precision, gridy double precision, scalexy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $5, $6, NULL, $4, $4, $2, $3) $_$;


ALTER FUNCTION public.st_snaptogrid(rast raster, gridx double precision, gridy double precision, scalexy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1113 (class 1255 OID 30736)
-- Name: st_snaptogrid(raster, double precision, double precision, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(rast raster, gridx double precision, gridy double precision, scalex double precision, scaley double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $6, $7, NULL, $4, $5, $2, $3) $_$;


ALTER FUNCTION public.st_snaptogrid(rast raster, gridx double precision, gridy double precision, scalex double precision, scaley double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1112 (class 1255 OID 30735)
-- Name: st_snaptogrid(raster, double precision, double precision, text, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(rast raster, gridx double precision, gridy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $4, $5, NULL, $6, $7, $2, $3) $_$;


ALTER FUNCTION public.st_snaptogrid(rast raster, gridx double precision, gridy double precision, algorithm text, maxerr double precision, scalex double precision, scaley double precision) OWNER TO postgres;

--
-- TOC entry 609 (class 1255 OID 30162)
-- Name: st_split(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_split(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-2.1', 'ST_Split';


ALTER FUNCTION public.st_split(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 699 (class 1255 OID 30263)
-- Name: st_srid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_srid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_get_srid';


ALTER FUNCTION public.st_srid(geometry) OWNER TO postgres;

--
-- TOC entry 924 (class 1255 OID 30548)
-- Name: st_srid(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_srid(raster) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getSRID';


ALTER FUNCTION public.st_srid(raster) OWNER TO postgres;

--
-- TOC entry 695 (class 1255 OID 30259)
-- Name: st_startpoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_startpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_startpoint_linestring';


ALTER FUNCTION public.st_startpoint(geometry) OWNER TO postgres;

--
-- TOC entry 1106 (class 1255 OID 30780)
-- Name: st_stddev4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_stddev4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT stddev(unnest) FROM unnest($1) $_$;


ALTER FUNCTION public.st_stddev4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1142 (class 1255 OID 30762)
-- Name: st_stddev4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_stddev4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT stddev(unnest) FROM unnest($1) $_$;


ALTER FUNCTION public.st_stddev4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 1157 (class 1255 OID 30776)
-- Name: st_sum4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_sum4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		sum double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		sum := 0;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					sum := sum + _value[z][y][x];
				END LOOP;
			END LOOP;
		END LOOP;

		RETURN sum;
	END;
	$$;


ALTER FUNCTION public.st_sum4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO postgres;

--
-- TOC entry 1137 (class 1255 OID 30758)
-- Name: st_sum4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;


ALTER FUNCTION public.st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO postgres;

--
-- TOC entry 870 (class 1255 OID 30470)
-- Name: st_summary(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summary(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_summary';


ALTER FUNCTION public.st_summary(geography) OWNER TO postgres;

--
-- TOC entry 450 (class 1255 OID 29973)
-- Name: st_summary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summary(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_summary';


ALTER FUNCTION public.st_summary(geometry) OWNER TO postgres;

--
-- TOC entry 933 (class 1255 OID 30557)
-- Name: st_summary(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summary(rast raster) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
	DECLARE
		extent box2d;
		metadata record;
		bandmetadata record;
		msg text;
		msgset text[];
	BEGIN
		extent := ST_Extent(rast::geometry);
		metadata := ST_Metadata(rast);

		msg := 'Raster of ' || metadata.width || 'x' || metadata.height || ' pixels has ' || metadata.numbands || ' ';

		IF metadata.numbands = 1 THEN
			msg := msg || 'band ';
		ELSE
			msg := msg || 'bands ';
		END IF;
		msg := msg || 'and extent of ' || extent;

		IF
			metadata.skewx::numeric(16, 10) <> 0::numeric(16, 10) OR 
			metadata.skewy::numeric(16, 10) <> 0::numeric(16, 10)
		THEN
			msg := 'Skewed ' || overlay(msg placing 'r' from 1 for 1);
		END IF;

		msgset := Array[]::text[] || msg;

		FOR bandmetadata IN SELECT * FROM ST_BandMetadata(rast, ARRAY[]::int[]) LOOP
			msg := 'band ' || bandmetadata.bandnum || ' of pixtype ' || bandmetadata.pixeltype || ' is ';
			IF bandmetadata.isoutdb IS FALSE THEN
				msg := msg || 'in-db ';
			ELSE
				msg := msg || 'out-db ';
			END IF;

			msg := msg || 'with ';
			IF bandmetadata.nodatavalue IS NOT NULL THEN
				msg := msg || 'NODATA value of ' || bandmetadata.nodatavalue;
			ELSE
				msg := msg || 'no NODATA value';
			END IF;

			msgset := msgset || ('    ' || msg);
		END LOOP;

		RETURN array_to_string(msgset, E'\n');
	END;
	$$;


ALTER FUNCTION public.st_summary(rast raster) OWNER TO postgres;

--
-- TOC entry 949 (class 1255 OID 30576)
-- Name: st_summarystats(raster, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summarystats(rast raster, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_summarystats($1, 1, $2, 1) $_$;


ALTER FUNCTION public.st_summarystats(rast raster, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 956 (class 1255 OID 30583)
-- Name: st_summarystats(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, 1, $3, 1) $_$;


ALTER FUNCTION public.st_summarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 948 (class 1255 OID 30575)
-- Name: st_summarystats(raster, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summarystats(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, 1) $_$;


ALTER FUNCTION public.st_summarystats(rast raster, nband integer, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 955 (class 1255 OID 30582)
-- Name: st_summarystats(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summarystats(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, $4, 1) $_$;


ALTER FUNCTION public.st_summarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO postgres;

--
-- TOC entry 602 (class 1255 OID 30155)
-- Name: st_symdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_symdifference(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'symdifference';


ALTER FUNCTION public.st_symdifference(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 603 (class 1255 OID 30156)
-- Name: st_symmetricdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_symmetricdifference(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'symdifference';


ALTER FUNCTION public.st_symmetricdifference(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1210 (class 1255 OID 30830)
-- Name: st_tile(raster, integer, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_tile(rast raster, width integer, height integer, padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) RETURNS SETOF raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_tile($1, $2, $3, NULL::integer[], $4, $5) $_$;


ALTER FUNCTION public.st_tile(rast raster, width integer, height integer, padwithnodata boolean, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1207 (class 1255 OID 30828)
-- Name: st_tile(raster, integer[], integer, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_tile(rast raster, nband integer[], width integer, height integer, padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) RETURNS SETOF raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_tile($1, $3, $4, $2, $5, $6) $_$;


ALTER FUNCTION public.st_tile(rast raster, nband integer[], width integer, height integer, padwithnodata boolean, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 1209 (class 1255 OID 30829)
-- Name: st_tile(raster, integer, integer, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_tile(rast raster, nband integer, width integer, height integer, padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) RETURNS SETOF raster
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT _st_tile($1, $3, $4, ARRAY[$2]::integer[], $5, $6) $_$;


ALTER FUNCTION public.st_tile(rast raster, nband integer, width integer, height integer, padwithnodata boolean, nodataval double precision) OWNER TO postgres;

--
-- TOC entry 632 (class 1255 OID 30196)
-- Name: st_touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_touches(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Touches($1,$2)$_$;


ALTER FUNCTION public.st_touches(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1284 (class 1255 OID 30942)
-- Name: st_touches(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_touches(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_touches($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_touches(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1283 (class 1255 OID 30941)
-- Name: st_touches(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_touches(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_touches(st_convexhull($1), st_convexhull($3)) ELSE _st_touches($1, $2, $3, $4) END $_$;


ALTER FUNCTION public.st_touches(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 1175 (class 1255 OID 30794)
-- Name: st_tpi(raster, integer, raster, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_tpi(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_rast raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent raster;
		_extenttype text;
	BEGIN
		_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
		ELSE
			_extenttype := 'CUSTOM';
		END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
			_nband := 1;
			_pixtype := NULL;
		ELSE
			_rast := rast;
			_nband := nband;
			_pixtype := pixeltype;
		END IF;

		-- get properties
		_pixwidth := ST_PixelWidth(_rast);
		_pixheight := ST_PixelHeight(_rast);
		SELECT width, height INTO _width, _height FROM ST_Metadata(_rast);

		RETURN ST_MapAlgebra(
			ARRAY[ROW(_rast, _nband)]::rastbandarg[],
			'_st_tpi4ma(double precision[][][], integer[][], text[])'::regprocedure,
			_pixtype,
			_extenttype, _customextent,
			1, 1);
	END;
	$$;


ALTER FUNCTION public.st_tpi(rast raster, nband integer, customextent raster, pixeltype text, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 544 (class 1255 OID 30081)
-- Name: st_transform(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transform(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'transform';


ALTER FUNCTION public.st_transform(geometry, integer) OWNER TO postgres;

--
-- TOC entry 1107 (class 1255 OID 30730)
-- Name: st_transform(raster, raster, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transform(rast raster, alignto raster, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		_srid integer;
		_scalex double precision;
		_scaley double precision;
		_gridx double precision;
		_gridy double precision;
		_skewx double precision;
		_skewy double precision;
	BEGIN
		SELECT srid, scalex, scaley, upperleftx, upperlefty, skewx, skewy INTO _srid, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy FROM st_metadata($2);

		RETURN _st_gdalwarp($1, $3, $4, _srid, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy, NULL, NULL);
	END;
	$_$;


ALTER FUNCTION public.st_transform(rast raster, alignto raster, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1105 (class 1255 OID 30729)
-- Name: st_transform(raster, integer, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transform(rast raster, srid integer, scalexy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $4, $5, $2, $3, $3) $_$;


ALTER FUNCTION public.st_transform(rast raster, srid integer, scalexy double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1104 (class 1255 OID 30728)
-- Name: st_transform(raster, integer, double precision, double precision, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transform(rast raster, srid integer, scalex double precision, scaley double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $5, $6, $2, $3, $4) $_$;


ALTER FUNCTION public.st_transform(rast raster, srid integer, scalex double precision, scaley double precision, algorithm text, maxerr double precision) OWNER TO postgres;

--
-- TOC entry 1103 (class 1255 OID 30727)
-- Name: st_transform(raster, integer, text, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transform(rast raster, srid integer, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0) RETURNS raster
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_gdalwarp($1, $3, $4, $2, $5, $6) $_$;


ALTER FUNCTION public.st_transform(rast raster, srid integer, algorithm text, maxerr double precision, scalex double precision, scaley double precision) OWNER TO postgres;

--
-- TOC entry 424 (class 1255 OID 29948)
-- Name: st_translate(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_translate(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Translate($1, $2, $3, 0)$_$;


ALTER FUNCTION public.st_translate(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 423 (class 1255 OID 29947)
-- Name: st_translate(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_translate(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_translate(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 427 (class 1255 OID 29951)
-- Name: st_transscale(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transscale(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$_$;


ALTER FUNCTION public.st_transscale(geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1179 (class 1255 OID 30798)
-- Name: st_tri(raster, integer, raster, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_tri(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) RETURNS raster
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_rast raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent raster;
		_extenttype text;
	BEGIN
		_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
		ELSE
			_extenttype := 'CUSTOM';
		END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
			_nband := 1;
			_pixtype := NULL;
		ELSE
			_rast := rast;
			_nband := nband;
			_pixtype := pixeltype;
		END IF;

		-- get properties
		_pixwidth := ST_PixelWidth(_rast);
		_pixheight := ST_PixelHeight(_rast);
		SELECT width, height INTO _width, _height FROM ST_Metadata(_rast);

		RETURN ST_MapAlgebra(
			ARRAY[ROW(_rast, _nband)]::rastbandarg[],
			'_st_tri4ma(double precision[][][], integer[][], text[])'::regprocedure,
			_pixtype,
			_extenttype, _customextent,
			1, 1);
	END;
	$$;


ALTER FUNCTION public.st_tri(rast raster, nband integer, customextent raster, pixeltype text, interpolate_nodata boolean) OWNER TO postgres;

--
-- TOC entry 605 (class 1255 OID 30158)
-- Name: st_unaryunion(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_unaryunion(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'ST_UnaryUnion';


ALTER FUNCTION public.st_unaryunion(geometry) OWNER TO postgres;

--
-- TOC entry 626 (class 1255 OID 30186)
-- Name: st_union(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_union(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'pgis_union_geometry_array';


ALTER FUNCTION public.st_union(geometry[]) OWNER TO postgres;

--
-- TOC entry 604 (class 1255 OID 30157)
-- Name: st_union(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_union(geom1 geometry, geom2 geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'geomunion';


ALTER FUNCTION public.st_union(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 925 (class 1255 OID 30549)
-- Name: st_upperleftx(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_upperleftx(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getXUpperLeft';


ALTER FUNCTION public.st_upperleftx(raster) OWNER TO postgres;

--
-- TOC entry 926 (class 1255 OID 30550)
-- Name: st_upperlefty(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_upperlefty(raster) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getYUpperLeft';


ALTER FUNCTION public.st_upperlefty(raster) OWNER TO postgres;

--
-- TOC entry 1192 (class 1255 OID 30811)
-- Name: st_value(raster, geometry, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_value(rast raster, pt geometry, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_value($1, 1, $2, $3) $_$;


ALTER FUNCTION public.st_value(rast raster, pt geometry, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1190 (class 1255 OID 30809)
-- Name: st_value(raster, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_value(rast raster, x integer, y integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_value($1, 1, $2, $3, $4) $_$;


ALTER FUNCTION public.st_value(rast raster, x integer, y integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1191 (class 1255 OID 30810)
-- Name: st_value(raster, integer, geometry, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_value(rast raster, band integer, pt geometry, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
    DECLARE
        x float8;
        y float8;
        gtype text;
    BEGIN
        gtype := st_geometrytype(pt);
        IF ( gtype != 'ST_Point' ) THEN
            RAISE EXCEPTION 'Attempting to get the value of a pixel with a non-point geometry';
        END IF;

				IF ST_SRID(pt) != ST_SRID(rast) THEN
            RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
				END IF;

        x := st_x(pt);
        y := st_y(pt);
        RETURN st_value(rast,
                        band,
                        st_worldtorastercoordx(rast, x, y),
                        st_worldtorastercoordy(rast, x, y),
                        exclude_nodata_value);
    END;
    $$;


ALTER FUNCTION public.st_value(rast raster, band integer, pt geometry, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1189 (class 1255 OID 30808)
-- Name: st_value(raster, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_value(rast raster, band integer, x integer, y integer, exclude_nodata_value boolean DEFAULT true) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getPixelValue';


ALTER FUNCTION public.st_value(rast raster, band integer, x integer, y integer, exclude_nodata_value boolean) OWNER TO postgres;

--
-- TOC entry 1035 (class 1255 OID 30661)
-- Name: st_valuecount(raster, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rast raster, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, 1, TRUE, $2, $3) $_$;


ALTER FUNCTION public.st_valuecount(rast raster, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO postgres;

--
-- TOC entry 1038 (class 1255 OID 30664)
-- Name: st_valuecount(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rast raster, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, 1, TRUE, ARRAY[$2]::double precision[], $3)).count $_$;


ALTER FUNCTION public.st_valuecount(rast raster, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1050 (class 1255 OID 30674)
-- Name: st_valuecount(text, text, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, 1, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO postgres;

--
-- TOC entry 1053 (class 1255 OID 30677)
-- Name: st_valuecount(text, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, 1, TRUE, ARRAY[$3]::double precision[], $4)).count $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1033 (class 1255 OID 30660)
-- Name: st_valuecount(raster, integer, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rast raster, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_valuecount(rast raster, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO postgres;

--
-- TOC entry 1037 (class 1255 OID 30663)
-- Name: st_valuecount(raster, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rast raster, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, TRUE, ARRAY[$3]::double precision[], $4)).count $_$;


ALTER FUNCTION public.st_valuecount(rast raster, nband integer, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1049 (class 1255 OID 30673)
-- Name: st_valuecount(text, text, integer, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, $3, TRUE, $4, $5) $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO postgres;

--
-- TOC entry 1052 (class 1255 OID 30676)
-- Name: st_valuecount(text, text, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, TRUE, ARRAY[$4]::double precision[], $5)).count $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1032 (class 1255 OID 30659)
-- Name: st_valuecount(raster, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_valuecount(rast raster, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO postgres;

--
-- TOC entry 1036 (class 1255 OID 30662)
-- Name: st_valuecount(raster, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rast raster, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, ARRAY[$4]::double precision[], $5)).count $_$;


ALTER FUNCTION public.st_valuecount(rast raster, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1048 (class 1255 OID 30672)
-- Name: st_valuecount(text, text, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO postgres;

--
-- TOC entry 1051 (class 1255 OID 30675)
-- Name: st_valuecount(text, text, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, $4, ARRAY[$5]::double precision[], $6)).count $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1041 (class 1255 OID 30667)
-- Name: st_valuepercent(raster, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rast raster, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, 1, TRUE, $2, $3) $_$;


ALTER FUNCTION public.st_valuepercent(rast raster, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1044 (class 1255 OID 30670)
-- Name: st_valuepercent(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rast raster, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, 1, TRUE, ARRAY[$2]::double precision[], $3)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rast raster, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1045 (class 1255 OID 30680)
-- Name: st_valuepercent(text, text, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, 1, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1059 (class 1255 OID 30683)
-- Name: st_valuepercent(text, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, 1, TRUE, ARRAY[$3]::double precision[], $4)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1040 (class 1255 OID 30666)
-- Name: st_valuepercent(raster, integer, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rast raster, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_valuepercent(rast raster, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1043 (class 1255 OID 30669)
-- Name: st_valuepercent(raster, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rast raster, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, TRUE, ARRAY[$3]::double precision[], $4)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rast raster, nband integer, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1055 (class 1255 OID 30679)
-- Name: st_valuepercent(text, text, integer, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, $3, TRUE, $4, $5) $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1058 (class 1255 OID 30682)
-- Name: st_valuepercent(text, text, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, TRUE, ARRAY[$4]::double precision[], $5)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1039 (class 1255 OID 30665)
-- Name: st_valuepercent(raster, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_valuepercent(rast raster, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1042 (class 1255 OID 30668)
-- Name: st_valuepercent(raster, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rast raster, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, ARRAY[$4]::double precision[], $5)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rast raster, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 1054 (class 1255 OID 30678)
-- Name: st_valuepercent(text, text, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO postgres;

--
-- TOC entry 1057 (class 1255 OID 30681)
-- Name: st_valuepercent(text, text, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, $4, ARRAY[$5]::double precision[], $6)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) OWNER TO postgres;

--
-- TOC entry 927 (class 1255 OID 30551)
-- Name: st_width(raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_width(raster) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/rtpostgis-2.1', 'RASTER_getWidth';


ALTER FUNCTION public.st_width(raster) OWNER TO postgres;

--
-- TOC entry 649 (class 1255 OID 30213)
-- Name: st_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_within(geom1 geometry, geom2 geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Contains($2,$1)$_$;


ALTER FUNCTION public.st_within(geom1 geometry, geom2 geometry) OWNER TO postgres;

--
-- TOC entry 1296 (class 1255 OID 30957)
-- Name: st_within(raster, raster); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_within(rast1 raster, rast2 raster) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT st_within($1, NULL::integer, $2, NULL::integer) $_$;


ALTER FUNCTION public.st_within(rast1 raster, rast2 raster) OWNER TO postgres;

--
-- TOC entry 1295 (class 1255 OID 30956)
-- Name: st_within(raster, integer, raster, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_within(rast1 raster, nband1 integer, rast2 raster, nband2 integer) RETURNS boolean
    LANGUAGE sql IMMUTABLE COST 1000
    AS $_$ SELECT $1 && $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN _st_within(st_convexhull($1), st_convexhull($3)) ELSE _st_contains($3, $4, $1, $2) END $_$;


ALTER FUNCTION public.st_within(rast1 raster, nband1 integer, rast2 raster, nband2 integer) OWNER TO postgres;

--
-- TOC entry 898 (class 1255 OID 30505)
-- Name: st_wkbtosql(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_wkbtosql(wkb bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_WKB';


ALTER FUNCTION public.st_wkbtosql(wkb bytea) OWNER TO postgres;

--
-- TOC entry 708 (class 1255 OID 30272)
-- Name: st_wkttosql(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_wkttosql(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_from_text';


ALTER FUNCTION public.st_wkttosql(text) OWNER TO postgres;

--
-- TOC entry 1238 (class 1255 OID 30857)
-- Name: st_worldtorastercoord(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoord(rast raster, pt geometry, OUT columnx integer, OUT rowy integer) RETURNS record
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		rx integer;
		ry integer;
	BEGIN
		IF st_geometrytype(pt) != 'ST_Point' THEN
			RAISE EXCEPTION 'Attempting to compute raster coordinate with a non-point geometry';
		END IF;
		IF ST_SRID(rast) != ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
		END IF;

		SELECT rc.columnx AS x, rc.rowy AS y INTO columnx, rowy FROM _st_worldtorastercoord($1, st_x(pt), st_y(pt)) AS rc;
		RETURN;
	END;
	$_$;


ALTER FUNCTION public.st_worldtorastercoord(rast raster, pt geometry, OUT columnx integer, OUT rowy integer) OWNER TO postgres;

--
-- TOC entry 1237 (class 1255 OID 30856)
-- Name: st_worldtorastercoord(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoord(rast raster, longitude double precision, latitude double precision, OUT columnx integer, OUT rowy integer) RETURNS record
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT columnx, rowy FROM _st_worldtorastercoord($1, $2, $3) $_$;


ALTER FUNCTION public.st_worldtorastercoord(rast raster, longitude double precision, latitude double precision, OUT columnx integer, OUT rowy integer) OWNER TO postgres;

--
-- TOC entry 1224 (class 1255 OID 30859)
-- Name: st_worldtorastercoordx(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoordx(rast raster, xw double precision) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT columnx FROM _st_worldtorastercoord($1, $2, NULL) $_$;


ALTER FUNCTION public.st_worldtorastercoordx(rast raster, xw double precision) OWNER TO postgres;

--
-- TOC entry 1239 (class 1255 OID 30860)
-- Name: st_worldtorastercoordx(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoordx(rast raster, pt geometry) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		xr integer;
	BEGIN
		IF ( st_geometrytype(pt) != 'ST_Point' ) THEN
			RAISE EXCEPTION 'Attempting to compute raster coordinate with a non-point geometry';
		END IF;
		IF ST_SRID(rast) != ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
		END IF;
		SELECT columnx INTO xr FROM _st_worldtorastercoord($1, st_x(pt), st_y(pt));
		RETURN xr;
	END;
	$_$;


ALTER FUNCTION public.st_worldtorastercoordx(rast raster, pt geometry) OWNER TO postgres;

--
-- TOC entry 1208 (class 1255 OID 30858)
-- Name: st_worldtorastercoordx(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoordx(rast raster, xw double precision, yw double precision) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT columnx FROM _st_worldtorastercoord($1, $2, $3) $_$;


ALTER FUNCTION public.st_worldtorastercoordx(rast raster, xw double precision, yw double precision) OWNER TO postgres;

--
-- TOC entry 1241 (class 1255 OID 30862)
-- Name: st_worldtorastercoordy(raster, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoordy(rast raster, yw double precision) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT rowy FROM _st_worldtorastercoord($1, NULL, $2) $_$;


ALTER FUNCTION public.st_worldtorastercoordy(rast raster, yw double precision) OWNER TO postgres;

--
-- TOC entry 1242 (class 1255 OID 30863)
-- Name: st_worldtorastercoordy(raster, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoordy(rast raster, pt geometry) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	DECLARE
		yr integer;
	BEGIN
		IF ( st_geometrytype(pt) != 'ST_Point' ) THEN
			RAISE EXCEPTION 'Attempting to compute raster coordinate with a non-point geometry';
		END IF;
		IF ST_SRID(rast) != ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
		END IF;
		SELECT rowy INTO yr FROM _st_worldtorastercoord($1, st_x(pt), st_y(pt));
		RETURN yr;
	END;
	$_$;


ALTER FUNCTION public.st_worldtorastercoordy(rast raster, pt geometry) OWNER TO postgres;

--
-- TOC entry 1240 (class 1255 OID 30861)
-- Name: st_worldtorastercoordy(raster, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_worldtorastercoordy(rast raster, xw double precision, yw double precision) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT rowy FROM _st_worldtorastercoord($1, $2, $3) $_$;


ALTER FUNCTION public.st_worldtorastercoordy(rast raster, xw double precision, yw double precision) OWNER TO postgres;

--
-- TOC entry 366 (class 1255 OID 29814)
-- Name: st_x(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_x(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_x_point';


ALTER FUNCTION public.st_x(geometry) OWNER TO postgres;

--
-- TOC entry 432 (class 1255 OID 29956)
-- Name: st_xmax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_xmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_xmax';


ALTER FUNCTION public.st_xmax(box3d) OWNER TO postgres;

--
-- TOC entry 429 (class 1255 OID 29953)
-- Name: st_xmin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_xmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_xmin';


ALTER FUNCTION public.st_xmin(box3d) OWNER TO postgres;

--
-- TOC entry 367 (class 1255 OID 29815)
-- Name: st_y(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_y(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_y_point';


ALTER FUNCTION public.st_y(geometry) OWNER TO postgres;

--
-- TOC entry 433 (class 1255 OID 29957)
-- Name: st_ymax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ymax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_ymax';


ALTER FUNCTION public.st_ymax(box3d) OWNER TO postgres;

--
-- TOC entry 430 (class 1255 OID 29954)
-- Name: st_ymin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ymin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_ymin';


ALTER FUNCTION public.st_ymin(box3d) OWNER TO postgres;

--
-- TOC entry 368 (class 1255 OID 29816)
-- Name: st_z(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_z_point';


ALTER FUNCTION public.st_z(geometry) OWNER TO postgres;

--
-- TOC entry 434 (class 1255 OID 29958)
-- Name: st_zmax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_zmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_zmax';


ALTER FUNCTION public.st_zmax(box3d) OWNER TO postgres;

--
-- TOC entry 490 (class 1255 OID 30014)
-- Name: st_zmflag(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_zmflag(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_zmflag';


ALTER FUNCTION public.st_zmflag(geometry) OWNER TO postgres;

--
-- TOC entry 431 (class 1255 OID 29955)
-- Name: st_zmin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_zmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'BOX3D_zmin';


ALTER FUNCTION public.st_zmin(box3d) OWNER TO postgres;

--
-- TOC entry 561 (class 1255 OID 30099)
-- Name: text(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION text(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-2.1', 'LWGEOM_to_text';


ALTER FUNCTION public.text(geometry) OWNER TO postgres;

--
-- TOC entry 766 (class 1255 OID 30330)
-- Name: unlockrows(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unlockrows(text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


ALTER FUNCTION public.unlockrows(text) OWNER TO postgres;

--
-- TOC entry 540 (class 1255 OID 30077)
-- Name: updategeometrysrid(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('','',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, integer) OWNER TO postgres;

--
-- TOC entry 539 (class 1255 OID 30076)
-- Name: updategeometrysrid(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) OWNER TO postgres;

--
-- TOC entry 538 (class 1255 OID 30075)
-- Name: updategeometrysrid(character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;
	unknown_srid integer;
	new_srid integer := new_srid_in;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <> true ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Ensure that column_name is in geometry_columns
	okay = false;
	FOR myrec IN SELECT type, coord_dimension FROM geometry_columns WHERE f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (NOT okay) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Ensure that new_srid is valid
	IF ( new_srid > 0 ) THEN
		IF ( SELECT count(*) = 0 from spatial_ref_sys where srid = new_srid ) THEN
			RAISE EXCEPTION 'invalid SRID: % not found in spatial_ref_sys', new_srid;
			RETURN false;
		END IF;
	ELSE
		unknown_srid := ST_SRID('POINT EMPTY'::geometry);
		IF ( new_srid != unknown_srid ) THEN
			new_srid := unknown_srid;
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;

	IF postgis_constraint_srid(real_schema, table_name, column_name) IS NOT NULL THEN 
	-- srid was enforced with constraints before, keep it that way.
        -- Make up constraint name
        cname = 'enforce_srid_'  || column_name;
    
        -- Drop enforce_srid constraint
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' DROP constraint ' || quote_ident(cname);
    
        -- Update geometries SRID
        EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' SET ' || quote_ident(column_name) ||
            ' = ST_SetSRID(' || quote_ident(column_name) ||
            ', ' || new_srid::text || ')';
            
        -- Reset enforce_srid constraint
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' ADD constraint ' || quote_ident(cname) ||
            ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')';
    ELSE 
        -- We will use typmod to enforce if no srid constraints
        -- We are using postgis_type_name to lookup the new name 
        -- (in case Paul changes his mind and flips geometry_columns to return old upper case name) 
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' || quote_ident(table_name) || 
        ' ALTER COLUMN ' || quote_ident(column_name) || ' TYPE  geometry(' || postgis_type_name(myrec.type, myrec.coord_dimension, true) || ', ' || new_srid::text || ') USING ST_SetSRID(' || quote_ident(column_name) || ',' || new_srid::text || ');' ;
    END IF;

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
$$;


ALTER FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) OWNER TO postgres;

--
-- TOC entry 1394 (class 1255 OID 31075)
-- Name: updaterastersrid(name, name, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updaterastersrid(table_name name, column_name name, new_srid integer) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _UpdateRasterSRID('', $1, $2, $3) $_$;


ALTER FUNCTION public.updaterastersrid(table_name name, column_name name, new_srid integer) OWNER TO postgres;

--
-- TOC entry 1393 (class 1255 OID 31074)
-- Name: updaterastersrid(name, name, name, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _UpdateRasterSRID($1, $2, $3, $4) $_$;


ALTER FUNCTION public.updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) OWNER TO postgres;

--
-- TOC entry 1483 (class 1255 OID 31245)
-- Name: zradar_arrow(integer, real, real, real); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_arrow(integer, real, real, real) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;
		carrow ALIAs for $4;

		the_geom geometry;
BEGIN

	select into the_geom 
ST_GeomFromText('POLYGON((' || st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ',' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd - amp) * pi()/180.) * carrow * ftime  * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd - amp) * pi()/180.) * carrow * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd + amp) * pi()/180.) * carrow * ftime * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd + amp) * pi()/180.) * carrow * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || '))', 23032)
FROM
  realtime.g_dbstorm
WHERE
  g_dbstorm.gid2 = gid;

return the_geom;

END;
$_$;


ALTER FUNCTION public.zradar_arrow(integer, real, real, real) OWNER TO radar;

--
-- TOC entry 1484 (class 1255 OID 31246)
-- Name: zradar_arrow_averagespeed(integer, real, real, real, integer); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_arrow_averagespeed(integer, real, real, real, integer) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;
		carrow ALIAs for $4;
                speed ALIAS for $5;

		the_geom geometry;
BEGIN

	select into the_geom 
ST_GeomFromText('POLYGON((' || st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ',' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd - amp) * pi()/180.) * carrow * ftime  * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd - amp) * pi()/180.) * carrow * ftime * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd + amp) * pi()/180.) * carrow * ftime * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd + amp) * pi()/180.) * carrow * ftime * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || '))', 23032)
FROM
  realtime.g_dbstorm
WHERE
  g_dbstorm.gid2 = gid;

return the_geom;

END;
$_$;


ALTER FUNCTION public.zradar_arrow_averagespeed(integer, real, real, real, integer) OWNER TO radar;

--
-- TOC entry 1515 (class 1255 OID 31247)
-- Name: zradar_at(real, real, real); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_at(real, real, real) RETURNS real
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		ts    ALIAS for $1;
		vv    ALIAS for $2;
		rh    ALIAS for $3;

		es real;
		
        BEGIN
        
                es = 0.01 * rh * 6.112* exp (17.62 * ts/(243.12 + ts));

                RETURN( ts + 0.33*es - 0.70*vv - 4.00 );


		 	
        END;
$_$;


ALTER FUNCTION public.zradar_at(real, real, real) OWNER TO radar;

--
-- TOC entry 5018 (class 0 OID 0)
-- Dependencies: 1515
-- Name: FUNCTION zradar_at(real, real, real); Type: COMMENT; Schema: public; Owner: radar
--

COMMENT ON FUNCTION zradar_at(real, real, real) IS 'Apperent temperature from Australian Bureau of Met.';


--
-- TOC entry 1516 (class 1255 OID 31248)
-- Name: zradar_forecast(integer, real, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zradar_forecast(integer, real, real) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;

		the_geom geometry;
BEGIN

	select into the_geom 
ST_GeomFromText('POLYGON((' || st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ',' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd - amp) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd -amp) * pi()/180.) * ftime  * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd + amp) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd + amp) * pi()/180.) * ftime * 1000. * g_dbstorm.vv) || ' , ' ||
st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || '))', 23032)
FROM
  realtime.g_dbstorm
WHERE
  g_dbstorm.gid2 = gid;

return the_geom;

END;
$_$;


ALTER FUNCTION public.zradar_forecast(integer, real, real) OWNER TO postgres;

--
-- TOC entry 5020 (class 0 OID 0)
-- Dependencies: 1516
-- Name: FUNCTION zradar_forecast(integer, real, real); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION zradar_forecast(integer, real, real) IS 'Updated on 19th Oct 2011';


--
-- TOC entry 1490 (class 1255 OID 31249)
-- Name: zradar_forecast_app(integer, real, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zradar_forecast_app(integer, real, real) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;
		the_geom geometry;
BEGIN

SELECT INTO the_geom 
ST_GeomFromText('POLYGON((' || g_ellipse_app.utmx || ' ' || g_ellipse_app.utmy || ',' ||
g_ellipse_app.utmx + (sin((g_ellipse_app.dd - amp) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' ' || g_ellipse_app.utmy + (cos((g_ellipse_app.dd -amp) * pi()/180.) * ftime  * 1000. * g_ellipse_app.vv) || ' , ' ||
g_ellipse_app.utmx + (sin((g_ellipse_app.dd) * pi()/180.) * ftime  * 1000. * g_ellipse_app.vv) || ' ' || g_ellipse_app.utmy + (cos((g_ellipse_app.dd) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' , ' ||
g_ellipse_app.utmx + (sin((g_ellipse_app.dd + amp) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' ' || g_ellipse_app.utmy + (cos((g_ellipse_app.dd + amp) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' , ' ||
g_ellipse_app.utmx || ' ' || g_ellipse_app.utmy || '))', 23032)
FROM
  realtime.g_ellipse_app
WHERE
  g_ellipse_app.id_ellipse_gid2 = gid;

RETURN the_geom;

END;
$_$;


ALTER FUNCTION public.zradar_forecast_app(integer, real, real) OWNER TO postgres;

--
-- TOC entry 5022 (class 0 OID 0)
-- Dependencies: 1490
-- Name: FUNCTION zradar_forecast_app(integer, real, real); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION zradar_forecast_app(integer, real, real) IS 'Updated on 24th Sep 2014 - to work with StormApp debug script';


--
-- TOC entry 1488 (class 1255 OID 31250)
-- Name: zradar_forecast_app_test(integer, real, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zradar_forecast_app_test(integer, real, real) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;
		the_geom geometry;
BEGIN

SELECT INTO the_geom 
ST_GeomFromText('POLYGON((' || g_ellipse_app.utmx || ' ' || g_ellipse_app.utmy || ',' ||
g_ellipse_app.utmx + (sin((g_ellipse_app.dd - amp) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' ' || g_ellipse_app.utmy + (cos((g_ellipse_app.dd -amp) * pi()/180.) * ftime  * 1000. * g_ellipse_app.vv) || ' , ' ||
g_ellipse_app.utmx + (sin((g_ellipse_app.dd) * pi()/180.) * ftime  * 1000. * g_ellipse_app.vv) || ' ' || g_ellipse_app.utmy + (cos((g_ellipse_app.dd) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' , ' ||
g_ellipse_app.utmx + (sin((g_ellipse_app.dd + amp) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' ' || g_ellipse_app.utmy + (cos((g_ellipse_app.dd + amp) * pi()/180.) * ftime * 1000. * g_ellipse_app.vv) || ' , ' ||
g_ellipse_app.utmx || ' ' || g_ellipse_app.utmy || '))', 23032)
FROM
  realtime.g_ellipse_app
WHERE
  g_ellipse_app.id_ellipse_gid2 = gid;

RETURN the_geom;

END;
$_$;


ALTER FUNCTION public.zradar_forecast_app_test(integer, real, real) OWNER TO postgres;

--
-- TOC entry 1517 (class 1255 OID 31251)
-- Name: zradar_forecast_averagespeed(integer, real, real, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zradar_forecast_averagespeed(integer, real, real, integer) RETURNS geometry
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		gid ALIAS for $1;
		amp ALIAS for $2;
		ftime ALIAS for $3;
                speed ALIAS for $4;

		the_geom geometry;
BEGIN

	select into the_geom 
ST_GeomFromText('MULTIPOLYGON(((' || st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ',' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd - amp) * pi()/180.) * ftime * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd -amp) * pi()/180.) * ftime  * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * ftime  * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * ftime * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd + amp) * pi()/180.) * ftime * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd + amp) * pi()/180.) * ftime * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ')),(('
 || st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ',' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd - amp) * pi()/180.) * (ftime/2) * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd -amp) * pi()/180.) * (ftime/2)  * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd) * pi()/180.) * (ftime/2)  * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd) * pi()/180.) * (ftime/2) * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) + (sin((g_dbstorm.dd + amp) * pi()/180.) * (ftime/2) * 1000. * speed) || ' ' || st_y(g_dbstorm.the_geom) + (cos((g_dbstorm.dd + amp) * pi()/180.) * (ftime/2) * 1000. * speed) || ' , ' ||
st_x(g_dbstorm.the_geom) || ' ' || st_y(g_dbstorm.the_geom) || ')))'
, 23032)
FROM
  realtime.g_dbstorm
WHERE
  g_dbstorm.gid2 = gid;

return the_geom;

END;
$_$;


ALTER FUNCTION public.zradar_forecast_averagespeed(integer, real, real, integer) OWNER TO postgres;

--
-- TOC entry 5024 (class 0 OID 0)
-- Dependencies: 1517
-- Name: FUNCTION zradar_forecast_averagespeed(integer, real, real, integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION zradar_forecast_averagespeed(integer, real, real, integer) IS 'Updated on 1st July 2014';


--
-- TOC entry 1492 (class 1255 OID 31252)
-- Name: zradar_humidex(real, real); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_humidex(real, real) RETURNS real
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		tt    ALIAS for $1;
		rh    ALIAS for $2;

		humidex real;
		es real;
		e real;
		
        BEGIN
        case
            when rh > 0 then
		es = 6.1078 * 10^((7.5 * tt)/(237.3 + tt));
		e = es * rh / 100.;
		humidex = tt + 0.55556 * (e - 10.);
            else 
		humidex = null;
        end case;

                RETURN( humidex );


		 	
        END;
$_$;


ALTER FUNCTION public.zradar_humidex(real, real) OWNER TO radar;

--
-- TOC entry 5026 (class 0 OID 0)
-- Dependencies: 1492
-- Name: FUNCTION zradar_humidex(real, real); Type: COMMENT; Schema: public; Owner: radar
--

COMMENT ON FUNCTION zradar_humidex(real, real) IS 'Humidex from TT and RH';


--
-- TOC entry 1489 (class 1255 OID 31253)
-- Name: zradar_mslp(real, real, real, real); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_mslp(real, real, real, real) RETURNS real
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		ps    ALIAS for $1;
		ts    ALIAS for $2;
		rh    ALIAS for $3;
		H0    ALIAS for $4;

                K  real;
                a  real;
                Ch real;

		es real;
		
        BEGIN
        
                K = 0.0148275;
                a = 0.0065;
                Ch = 0.12;
                
                es = 0.01 * rh * 6.112* exp (17.62 * ts/(243.12 + ts));

                RETURN(ps * 10^( (K * H0) / (273.15 + ts + a * H0 / 2 + es * Ch)) );


		 	
        END;
$_$;


ALTER FUNCTION public.zradar_mslp(real, real, real, real) OWNER TO radar;

--
-- TOC entry 5028 (class 0 OID 0)
-- Dependencies: 1489
-- Name: FUNCTION zradar_mslp(real, real, real, real); Type: COMMENT; Schema: public; Owner: radar
--

COMMENT ON FUNCTION zradar_mslp(real, real, real, real) IS 'Reduction to mean sea level pressure';


--
-- TOC entry 1491 (class 1255 OID 31254)
-- Name: zradar_new_severity_index(real, real, real, real, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zradar_new_severity_index(real, real, real, real, double precision) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		vil    ALIAS for $1;
		top    ALIAS for $2;
		mrefl  ALIAS for $3;
		poh    ALIAS for $4;
		sqarea ALIAS for $5;
		csi  real;
		dvil real;
		npoh real;
		
        BEGIN

	IF TOP > 0 AND  VIL > 0 THEN
		dvil = vil / top;
	ELSE
		dvil = 0.001;
	END IF;

	IF POH > 100 THEN
		npoh =100.;
	ELSE
		npoh = POH;
	END IF;
	

              
	    csi := (dvil - 0.001) / (2.0 - 0.001) + (mrefl - 36.3) / (80 - 36.3) + npoh / 100 + (sqarea - 0.39) / (100.0 - 0.39);

	CASE
	WHEN csi is NULL THEN RETURN NULL::integer;
	WHEN csi < 0.187   THEN RETURN 1; --0.1801 --0.1953
	WHEN csi < 0.428   THEN RETURN 2; --0.4087 --0.4305
	WHEN csi < 0.698   THEN RETURN 3; --0.6694 --0.7044
	WHEN csi < 1.277   THEN RETURN 4; --1.2617 --1.1912
	WHEN csi < 1.818   THEN RETURN 5; --2.0852 --1.9586
	ELSE RETURN 6;
	END CASE;
		 	
        END;
$_$;


ALTER FUNCTION public.zradar_new_severity_index(real, real, real, real, double precision) OWNER TO postgres;

--
-- TOC entry 5030 (class 0 OID 0)
-- Dependencies: 1491
-- Name: FUNCTION zradar_new_severity_index(real, real, real, real, double precision); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION zradar_new_severity_index(real, real, real, real, double precision) IS 'Updated on 5th May 2014 (data since Aug 2009)';


--
-- TOC entry 1518 (class 1255 OID 31255)
-- Name: zradar_severity_index(real, real, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zradar_severity_index(real, real, real) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		vil ALIAS for $1;
		max ALIAS for $2;
		top ALIAS for $3;
		csi real;
        BEGIN
            csi := round(((2::double precision * vil + max + top / 10::double precision) / 20::double precision - 2::double precision)::numeric(6,3), 3);

	CASE
	WHEN csi is NULL THEN RETURN NULL::integer;
	WHEN csi < 0.6945  THEN RETURN 1;  -- 0.765 0.736
	WHEN csi < 0.9255  THEN RETURN 2;  -- 0.975 0.932
	WHEN csi < 1.2175  THEN RETURN 3;  -- 1.230 1.182
	WHEN csi < 2.0555  THEN RETURN 4;  -- 1.592 1.535
	WHEN csi < 11.2760 THEN RETURN 5;  -- 5.255 5.605
	ELSE RETURN 6;
	END CASE;
		 	
        END;
$_$;


ALTER FUNCTION public.zradar_severity_index(real, real, real) OWNER TO postgres;

--
-- TOC entry 5032 (class 0 OID 0)
-- Dependencies: 1518
-- Name: FUNCTION zradar_severity_index(real, real, real); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION zradar_severity_index(real, real, real) IS 'Updated on 5th May 2014 (data from Aug 2009 last update 4th July 2013)';


--
-- TOC entry 1499 (class 1255 OID 31256)
-- Name: zradar_td(real, real); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_td(real, real) RETURNS real
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		tt    ALIAS for $1;
		rh    ALIAS for $2;

		td real;
		
        BEGIN
        case
            when rh > 0 then
		td = 243.04*(log(rh/100)+((17.625*tt)/(243.04+tt)))/(17.625-log(rh/100)-((17.625*tt)/(243.04+tt)));
            else 
		td = null;
        end case;

                RETURN( td );


		 	
        END;
$_$;


ALTER FUNCTION public.zradar_td(real, real) OWNER TO radar;

--
-- TOC entry 5034 (class 0 OID 0)
-- Dependencies: 1499
-- Name: FUNCTION zradar_td(real, real); Type: COMMENT; Schema: public; Owner: radar
--

COMMENT ON FUNCTION zradar_td(real, real) IS 'Dew point temperature from TT and RH';


--
-- TOC entry 1493 (class 1255 OID 31257)
-- Name: zradar_windchill(real, real); Type: FUNCTION; Schema: public; Owner: radar
--

CREATE FUNCTION zradar_windchill(real, real) RETURNS real
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		ts    ALIAS for $1;
		vv    ALIAS for $2;
		
        BEGIN

		RETURN(13.12 + 0.6215 * ts - 11.37 * (3.6 * vv) ^ 0.16 + 0.3965 * ts * (3.6 * vv) ^ 0.16 );
        END;
$_$;


ALTER FUNCTION public.zradar_windchill(real, real) OWNER TO radar;

--
-- TOC entry 5036 (class 0 OID 0)
-- Dependencies: 1493
-- Name: FUNCTION zradar_windchill(real, real); Type: COMMENT; Schema: public; Owner: radar
--

COMMENT ON FUNCTION zradar_windchill(real, real) IS 'Wind chill formula';


SET search_path = realtime, pg_catalog;

--
-- TOC entry 1494 (class 1255 OID 31258)
-- Name: app_alert_fn(real, real, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_alert_fn(lon real, lat real, radius integer, si_input integer) RETURNS TABLE(si integer, dataora character varying)
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
  RETURN QUERY EXECUTE '
  SELECT 
  CASE
    WHEN si<3 THEN 0
    WHEN si<4 THEN 1
    WHEN si=4 THEN 2
    ELSE 3
  END AS si
, dataora FROM realtime.g_ellipse_app
WHERE ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032)
, ' || radius || '*1000.), the_geom) AND fulldate BETWEEN (now() - ''16 minutes''::interval) AND (now() - ''0 minutes''::interval)
AND si>=' || si_input || ' ORDER BY si DESC, fulldate DESC LIMIT 1;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.app_alert_fn(lon real, lat real, radius integer, si_input integer) OWNER TO postgres;

--
-- TOC entry 1495 (class 1255 OID 31259)
-- Name: app_alert_test_fn(real, real, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_alert_test_fn(lon real, lat real, radius integer, si_input integer) RETURNS TABLE(si integer, dataora character varying)
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
  RETURN QUERY EXECUTE '
  SELECT 
  CASE
    WHEN si<3 THEN 0
    WHEN si<4 THEN 1
    WHEN si=4 THEN 2
    ELSE 3
  END AS si
  , dataora FROM realtime.g_ellipse_app_test WHERE ST_INTERSECTS(ST_buffer(
ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032)
, ' || radius || '*1000.), the_geom) AND fulldate BETWEEN (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''16 minutes''::interval) AND (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''0 minutes''::interval) AND si>=' || si_input || ' ORDER BY si DESC,fulldate DESC LIMIT 1;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.app_alert_test_fn(lon real, lat real, radius integer, si_input integer) OWNER TO postgres;

--
-- TOC entry 1496 (class 1255 OID 31260)
-- Name: app_draw_fn(integer, integer, real); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_draw_fn(id_storm integer, forecast integer DEFAULT 0, forecasthour real DEFAULT 0) RETURNS SETOF text
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
    IF forecast < 1
    THEN --la richiesta e' sui dati storici
      RETURN QUERY EXECUTE '
      SELECT ST_AsGeoJSON(ST_Transform(the_geom,4326),3) FROM realtime.g_ellipse_app WHERE id_ellipse_gid2=' || id_storm ||';
      ';
    ELSE --la richiesta e' sul forecast
      RETURN QUERY EXECUTE '
      SELECT ST_AsGeoJSON(ST_transform(st_convexhull(st_collect(zradar_forecast_app(a.id_ellipse_gid2, 15::real, ' || forecastHour || '::real), a.the_geom)), 4326), 3) FROM realtime.g_ellipse_app a WHERE a.id_ellipse_gid2=' || id_storm ||' AND a.vv>0;
      ';
    END IF;
END IF;
END;
$$;


ALTER FUNCTION realtime.app_draw_fn(id_storm integer, forecast integer, forecasthour real) OWNER TO postgres;

--
-- TOC entry 1497 (class 1255 OID 31261)
-- Name: app_draw_test_fn(integer, integer, real); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_draw_test_fn(id_storm integer, forecast integer DEFAULT 0, forecasthour real DEFAULT 0) RETURNS SETOF text
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
    IF forecast < 1
    THEN --la richiesta e' sui dati storici
      RETURN QUERY EXECUTE '
      SELECT ST_AsGeoJSON(ST_Transform(the_geom,4326),3) FROM realtime.g_ellipse_app_test WHERE id_ellipse_gid2=' || id_storm ||';
      ';
    ELSE --la richiesta e' sul forecast
      RETURN QUERY EXECUTE '
      SELECT ST_AsGeoJSON(ST_transform(st_convexhull(st_collect(zradar_forecast_app_test(a.id_ellipse_gid2, 15::real, ' || forecastHour || '::real), a.the_geom)), 4326), 3) FROM realtime.g_ellipse_app_test a WHERE a.id_ellipse_gid2=' || id_storm ||' AND a.vv>0;
      ';
    END IF;
END IF;
END;
$$;


ALTER FUNCTION realtime.app_draw_test_fn(id_storm integer, forecast integer, forecasthour real) OWNER TO postgres;

--
-- TOC entry 1498 (class 1255 OID 31262)
-- Name: app_list_fn(real, real, integer, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_list_fn(lon real, lat real, radius integer, history integer, historyend integer) RETURNS TABLE(id_ellipse_gid2 integer, si text, dataora character varying, id_storm_track character varying)
    LANGUAGE plpgsql ROWS 50
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
  RETURN QUERY EXECUTE '

  SELECT DISTINCT ON (id_storm_track)
  id_ellipse_gid2, 
  (CASE
    WHEN si<3 THEN ''none''
    WHEN si<4 THEN ''low''
    WHEN si=4 THEN ''medium''
    ELSE ''high''
  END)::text AS si
  , dataora, id_storm_track FROM realtime.g_ellipse_app WHERE
  ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), the_geom)
  AND fulldate BETWEEN (now() - ''' || historyEnd || ' minutes''::interval) AND (now() - ''' || history || ' minutes''::interval) AND si>=3 ORDER BY id_storm_track, data_num DESC;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.app_list_fn(lon real, lat real, radius integer, history integer, historyend integer) OWNER TO postgres;

--
-- TOC entry 1500 (class 1255 OID 31263)
-- Name: app_list_forecast_fn(real, real, integer, integer, real); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_list_forecast_fn(lon real, lat real, radius integer, delta_forecast integer, delta_hour real) RETURNS SETOF text
    LANGUAGE plpgsql ROWS 50
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
  RETURN QUERY EXECUTE '
  SELECT id_ellipse_gid2||''f''||' || delta_forecast || '::text
  FROM realtime.g_ellipse_app a, (
  SELECT max(a.id_ellipse_gid2) AS gid2 FROM realtime.g_ellipse_app a
  WHERE fulldate > (now() - ''20 minutes''::interval) AND a.vv>0 AND si>=2
  GROUP BY a.id_storm_track
  ) AS foo
  WHERE st_intersects(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), st_convexhull(st_collect(zradar_forecast_app(foo.gid2, 15::real, ' || delta_hour || '::real), st_setsrid(the_geom, 23032))) ) AND a.id_ellipse_gid2 = foo.gid2;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.app_list_forecast_fn(lon real, lat real, radius integer, delta_forecast integer, delta_hour real) OWNER TO postgres;

--
-- TOC entry 1501 (class 1255 OID 31264)
-- Name: app_list_forecast_test_fn(real, real, integer, integer, real); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_list_forecast_test_fn(lon real, lat real, radius integer, delta_forecast integer, delta_hour real) RETURNS SETOF text
    LANGUAGE plpgsql ROWS 50
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
  RETURN QUERY EXECUTE '
  SELECT id_ellipse_gid2||''f''||' || delta_forecast || '::text
  FROM realtime.g_ellipse_app_test a, (
  SELECT max(a.id_ellipse_gid2) AS gid2 FROM realtime.g_ellipse_app_test a
  WHERE fulldate BETWEEN (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''20 minutes''::interval)
  AND (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'')) AND a.vv>0 AND si>=2
  GROUP BY a.id_storm_track
  ) AS foo
  WHERE st_intersects(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), st_convexhull(st_collect(zradar_forecast_app_test(foo.gid2, 15::real, ' || delta_hour || '::real), st_setsrid(the_geom, 23032))) ) AND a.id_ellipse_gid2 = foo.gid2;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.app_list_forecast_test_fn(lon real, lat real, radius integer, delta_forecast integer, delta_hour real) OWNER TO postgres;

--
-- TOC entry 1502 (class 1255 OID 31265)
-- Name: app_list_test_fn(real, real, integer, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION app_list_test_fn(lon real, lat real, radius integer, history integer, historyend integer) RETURNS TABLE(id_ellipse_gid2 integer, si text, dataora character varying, id_storm_track character varying)
    LANGUAGE plpgsql ROWS 50
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
--DA GESTIRE IN CASO DI ANOMALIA!
  THEN
  RETURN QUERY EXECUTE '
  SELECT DISTINCT ON (id_storm_track)
  id_ellipse_gid2,
  (CASE
    WHEN si<3 THEN ''none''
    WHEN si<4 THEN ''low''
    WHEN si=4 THEN ''medium''
    ELSE ''high''
  END)::text AS si
  , dataora, id_storm_track FROM realtime.g_ellipse_app_test WHERE ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), the_geom)
  AND fulldate BETWEEN (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''' || historyEnd || ' minutes''::interval) AND (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''' || history || ' minutes''::interval)
  AND si>=3 ORDER BY id_storm_track, data_num DESC;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.app_list_test_fn(lon real, lat real, radius integer, history integer, historyend integer) OWNER TO postgres;

--
-- TOC entry 1503 (class 1255 OID 31266)
-- Name: calc_id_parametro(text); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION calc_id_parametro(text) RETURNS text
    LANGUAGE sql
    AS $_$
SELECT CASE
            WHEN $1::text = 'T'::text THEN 'TERMA'::text
            WHEN $1::text = 'UR'::text THEN 'IGRO'::text
            WHEN $1::text = 'PP'::text THEN 'PLUV'::text
            WHEN $1::text = 'PPR'::text THEN 'PLUV'::text
            WHEN $1::text = 'VV'::text THEN 'VELV'::text
            WHEN $1::text = 'DV'::text THEN 'DIRV'::text
            WHEN $1::text = 'TV'::text THEN 'TERMA'::text
            WHEN $1::text = 'VVS'::text THEN 'VELS'::text
            WHEN $1::text = 'RG'::text THEN 'RADD'::text
            WHEN $1::text = 'DVS'::text THEN 'DIRS'::text
            ELSE NULL::text
        END
$_$;


ALTER FUNCTION realtime.calc_id_parametro(text) OWNER TO postgres;

--
-- TOC entry 1504 (class 1255 OID 31267)
-- Name: cardinal2degree(text); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION cardinal2degree(text) RETURNS real
    LANGUAGE sql
    AS $_$
SELECT CASE
        WHEN $1 = 'N' THEN 0
	WHEN $1 = 'NNE' THEN 22.5
	WHEN $1 = 'NE' THEN 45
	WHEN $1 = 'ENE' THEN 67.5
	WHEN $1 = 'E' THEN 90
	WHEN $1 = 'ESE' THEN 112.5
	WHEN $1 = 'SE' THEN 135
	WHEN $1 = 'SSE' THEN 157.5
	WHEN $1 = 'S' THEN 180
	WHEN $1 = 'SSW' THEN 202.5
	WHEN $1 = 'SW' THEN 225
	WHEN $1 = 'WSW' THEN 247.5
	WHEN $1 = 'W' THEN 270
	WHEN $1 = 'WNW' THEN 292.5
	WHEN $1 = 'NW' THEN 315
	WHEN $1 = 'NNW' THEN 337.5
        ELSE NULL::real
        END
$_$;


ALTER FUNCTION realtime.cardinal2degree(text) OWNER TO postgres;

--
-- TOC entry 1505 (class 1255 OID 31268)
-- Name: degree2cardinal(real); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION degree2cardinal(real) RETURNS text
    LANGUAGE sql
    AS $_$
SELECT CASE
        WHEN $1 BETWEEN  348.75 AND 360  THEN 'N'::text
	WHEN $1 BETWEEN  0 AND 11.25  THEN 'N'::text
	WHEN $1 BETWEEN  11.25 AND 33.75  THEN 'NNE'::text
	WHEN $1 BETWEEN  33.75 AND 56.25  THEN 'NE'::text
	WHEN $1 BETWEEN  56.25 AND 78.75   THEN 'ENE'::text
	WHEN $1 BETWEEN  78.75 AND 101.25  THEN 'E'::text
	WHEN $1 BETWEEN  101.25 AND 123.75  THEN 'ESE'::text
	WHEN $1 BETWEEN  123.75 AND 146.25  THEN 'SE'::text
	WHEN $1 BETWEEN  146.25 AND 168.75   THEN 'SSE'::text
	WHEN $1 BETWEEN  168.75 AND 191.25  THEN 'S'::text
	WHEN $1 BETWEEN  191.25 AND 213.75   THEN 'SSW'::text
	WHEN $1 BETWEEN  213.75 AND 236.25   THEN 'SW'::text
	WHEN $1 BETWEEN  236.25 AND 258.75   THEN 'WSW'::text
	WHEN $1 BETWEEN  258.75 AND 281.25   THEN 'W'::text
	WHEN $1 BETWEEN  281.25 AND 303.75   THEN 'WNW'::text
	WHEN $1 BETWEEN  303.75 AND 326.25   THEN 'NW'::text
	WHEN $1 BETWEEN  326.25 AND 348.75   THEN 'NNW'::text
            ELSE NULL::text
        END
$_$;


ALTER FUNCTION realtime.degree2cardinal(real) OWNER TO postgres;

--
-- TOC entry 1506 (class 1255 OID 31269)
-- Name: insert_ellipse_app(); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION insert_ellipse_app() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
INSERT INTO realtime.g_ellipse_app(id_storm_track, id_ellipse_gid2, dataora, fulldate, data_num, ora, utmx, utmy, lifetime, area, si, vv, dd, the_geom, poh, vil, comune)  
SELECT NEW.id, NEW.gid2, NEW.data, to_timestamp(NEW.data, 'YYYYMMDDHH24MI')::timestamp without time zone, NEW.data::numeric, substr(NEW.data::text, 9, 4), NEW.utmx, NEW.utmy, NEW.lifetime, NEW.area, zradar_new_severity_index(NEW.vil, NEW.top, NEW.mean, NEW.poh, sqrt(NEW.area / pi())) AS si, NEW.vv, NEW.dd, st_setsrid(ellipse(NEW.utmx::double precision, NEW.utmy::double precision, NEW.ax::double precision, NEW."by"::double precision, radians(NEW.theta::double precision), 8), 23032) AS the_geom, NEW.poh, NEW.vil, NEW.comune;
RETURN NEW;
END;
$$;


ALTER FUNCTION realtime.insert_ellipse_app() OWNER TO postgres;

--
-- TOC entry 1481 (class 1255 OID 31270)
-- Name: previdro_stato(); Type: FUNCTION; Schema: realtime; Owner: radar
--

CREATE FUNCTION previdro_stato() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

UPDATE realtime.previsioni_idro_stato SET stato =
    CASE
		WHEN GREATEST(max_valore_MC, max_valore_M1, max_valore_SO, max_valore_HE) > codice3 THEN 3
		WHEN GREATEST(max_valore_MC, max_valore_M1, max_valore_SO, max_valore_HE) > codice2 THEN 2
		WHEN GREATEST(max_valore_MC, max_valore_M1, max_valore_SO, max_valore_HE) > codice1 THEN 1
		WHEN GREATEST(max_valore_MC, max_valore_M1, max_valore_SO, max_valore_HE) IS NULL THEN -1
		ELSE 0
	END;
UPDATE realtime.previsioni_idro_stato SET data_ins = now();

RETURN NULL;
END;
$$;


ALTER FUNCTION realtime.previdro_stato() OWNER TO radar;

--
-- TOC entry 5038 (class 0 OID 0)
-- Dependencies: 1481
-- Name: FUNCTION previdro_stato(); Type: COMMENT; Schema: realtime; Owner: radar
--

COMMENT ON FUNCTION previdro_stato() IS 'Aggiorna lo stato delle stazioni idrologiche in base ai valori di livello previsto da vari modelli di previsione';


--
-- TOC entry 1507 (class 1255 OID 31271)
-- Name: radian2cardinal(real); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION radian2cardinal(real) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
    degree numeric(5,2) := $1 / (2*pi()) *360;
    card text;
BEGIN
SELECT into card
    CASE
        WHEN degree BETWEEN  348.75 AND 360  THEN 'N'::text
	WHEN degree BETWEEN  0 AND 11.25  THEN 'N'::text
	WHEN degree BETWEEN  11.25 AND 33.75  THEN 'NNE'::text
	WHEN degree BETWEEN  33.75 AND 56.25  THEN 'NE'::text
	WHEN degree BETWEEN  56.25 AND 78.75   THEN 'ENE'::text
	WHEN degree BETWEEN  78.75 AND 101.25  THEN 'E'::text
	WHEN degree BETWEEN  101.25 AND 123.75  THEN 'ESE'::text
	WHEN degree BETWEEN  123.75 AND 146.25  THEN 'SE'::text
	WHEN degree BETWEEN  146.25 AND 168.75   THEN 'SSE'::text
	WHEN degree BETWEEN  168.75 AND 191.25  THEN 'S'::text
	WHEN degree BETWEEN  191.25 AND 213.75   THEN 'SSW'::text
	WHEN degree BETWEEN  213.75 AND 236.25   THEN 'SW'::text
	WHEN degree BETWEEN  236.25 AND 258.75   THEN 'WSW'::text
	WHEN degree BETWEEN  258.75 AND 281.25   THEN 'W'::text
	WHEN degree BETWEEN  281.25 AND 303.75   THEN 'WNW'::text
	WHEN degree BETWEEN  303.75 AND 326.25   THEN 'NW'::text
	WHEN degree BETWEEN  326.25 AND 348.75   THEN 'NNW'::text
            ELSE NULL::text
        END;
return card;
END;
$_$;


ALTER FUNCTION realtime.radian2cardinal(real) OWNER TO postgres;

--
-- TOC entry 1508 (class 1255 OID 31272)
-- Name: stazioni_bis_stato(); Type: FUNCTION; Schema: realtime; Owner: radar
--

CREATE FUNCTION stazioni_bis_stato() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

IF (NEW.id_parametro = 'Q_MED') THEN
IF (NEW.data::date >= ( now() - '1 days'::interval )::date) THEN
UPDATE realtime.bis_stato SET ultimovalore=NEW.valore WHERE NEW.codice=codice;
UPDATE realtime.bis_stato SET data=NEW.data::date WHERE NEW.codice=codice;
UPDATE realtime.bis_stato SET stato=CASE
		WHEN NEW.valore > dmv_base THEN 0
		WHEN (NEW.valore > dmv_deroga) OR (NEW.valore < dmv_base) THEN 1
		WHEN NEW.valore < dmv_deroga THEN 2
		ELSE 3
	END
	WHERE NEW.codice=codice;
END IF;
END IF;

--In realta non sono sicuro che in questo modo io riesca ad intercettare quelle stazioni per cui non vi sono nuovi dati, per cui impongo uno stato = a -1 per tutte quelle stazioni che hanno una data piu vecchia di ieri:
UPDATE realtime.bis_stato SET stato=-1 WHERE data::date < ( now() - '1 days'::interval )::date;

RETURN NEW;
END;
$$;


ALTER FUNCTION realtime.stazioni_bis_stato() OWNER TO radar;

--
-- TOC entry 5039 (class 0 OID 0)
-- Dependencies: 1508
-- Name: FUNCTION stazioni_bis_stato(); Type: COMMENT; Schema: realtime; Owner: radar
--

COMMENT ON FUNCTION stazioni_bis_stato() IS 'Aggiorna lo stato delle stazioni idrologiche in base ai valori di portata e soglie relative';


--
-- TOC entry 1509 (class 1255 OID 31273)
-- Name: trig_dbstorm_update_comune(); Type: FUNCTION; Schema: realtime; Owner: radar
--

CREATE FUNCTION trig_dbstorm_update_comune() RETURNS trigger
    LANGUAGE plpgsql
    AS $$BEGIN
UPDATE  realtime.g_dbstorm 
 set
 comune = limiti_amministrativi.localita,
 provincia = limiti_amministrativi.provincia,
 regione = limiti_amministrativi.regione
FROM dati_di_base.limiti_amministrativi
WHERE gid2 = NEW.gid2 and
ST_Intersects(ST_Transform(NEW.the_geom,32632), limiti_amministrativi.the_geom);

if NEW.lifetime = 0
THEN
	insert into realtime.g_stormpath (id, data, lifetime, gid, lunghezza, the_geom) values (NEW.id, NEW.data, NEW.lifetime, NEW.gid2, 0.0, ST_MakeLine(NEW.the_geom, NEW.the_geom));
ELSE
	update realtime.g_stormpath set
		the_geom = st_addpoint(the_geom, NEW.the_geom),
		lunghezza = ST_length(st_addpoint(the_geom, NEW.the_geom)),
		lifetime = NEW.lifetime
	WHERE id = NEW.id;
END IF;

RETURN NULL;
END;
$$;


ALTER FUNCTION realtime.trig_dbstorm_update_comune() OWNER TO radar;

--
-- TOC entry 5040 (class 0 OID 0)
-- Dependencies: 1509
-- Name: FUNCTION trig_dbstorm_update_comune(); Type: COMMENT; Schema: realtime; Owner: radar
--

COMMENT ON FUNCTION trig_dbstorm_update_comune() IS 'Aggiorna localita, comune e regione ed inserisce od aggiorna g_stormpath (cremo, 2016.05.02)';


--
-- TOC entry 1510 (class 1255 OID 31274)
-- Name: update_bacini_flag(); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION update_bacini_flag() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE realtime.cumulata_bacini SET flag =
CASE WHEN ST_Contains(ST_Transform(b.the_geom, 32632), a.the_geom) THEN 0 ELSE 4 END from 
dati_di_base.bacini_defense a, dati_di_base.radar_visibility4000poly b
--Proviamo ad usare NEW perche' con le righe commentate mi saltava qualche inserimento:
WHERE NEW.id_conoide = a.id_bacino AND NEW.id_conoide = realtime.cumulata_bacini.id_conoide
/*
where realtime.cumulata_bacini_2012.id_conoide = a.id_bacino AND realtime.cumulata_bacini_2012.gid = (
select gid FROM realtime.cumulata_bacini_2012 ORDER BY gid DESC LIMIT 1
)
*/
;
RETURN NEW;
END;
$$;


ALTER FUNCTION realtime.update_bacini_flag() OWNER TO postgres;

--
-- TOC entry 5041 (class 0 OID 0)
-- Dependencies: 1510
-- Name: FUNCTION update_bacini_flag(); Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON FUNCTION update_bacini_flag() IS 'Aggiorna flag sui bacini in base che siano o meno entro il raggio di buona visibilita del radar';


--
-- TOC entry 1511 (class 1255 OID 31275)
-- Name: webgis_alert_fn(real, real, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION webgis_alert_fn(lon real, lat real, radius integer, si_input integer) RETURNS TABLE(si integer, si_str_it text, dataora character varying, direction text, distance integer, vv real, localita character varying, posizione text, utmx integer, utmy integer)
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
  THEN
  RETURN QUERY EXECUTE '
  SELECT 
  si,
  CASE
    WHEN si<3 THEN ''none''
    WHEN si<4 THEN ''moderato''
    WHEN si=4 THEN ''intenso''
    ELSE ''molto intenso''
  END AS si_str_it
  , dataora, realtime.degree2cardinal(dd) AS direction, ROUND(ST_Distance(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), g_ellipse_app.the_geom)/1000)::integer AS distance, vv, 
b.localita, 
realtime.radian2cardinal(ST_Azimuth(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ST_SetSRID(ST_Point(utmx, utmy), 23032))::real) as position, utmx::integer, utmy::integer
FROM realtime.g_ellipse_app
, dati_di_base.limiti_amministrativi b 
WHERE 
ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), g_ellipse_app.the_geom) AND fulldate BETWEEN (now() - ''16 minutes''::interval) AND (now() - ''0 minutes''::interval) AND si>=' || si_input || '
AND ST_INTERSECTS(b.the_geom, ST_Transform(ST_SetSRID(ST_Point(utmx, utmy), 23032), 32632))
ORDER BY si DESC, fulldate DESC, distance ASC LIMIT 1;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.webgis_alert_fn(lon real, lat real, radius integer, si_input integer) OWNER TO postgres;

--
-- TOC entry 1512 (class 1255 OID 31276)
-- Name: webgis_alert_test_fn(real, real, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION webgis_alert_test_fn(lon real, lat real, radius integer, si_input integer) RETURNS TABLE(si integer, si_str_it text, dataora character varying, direction text, distance integer, vv real, localita character varying, posizione text, utmx integer, utmy integer)
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
  THEN
  RETURN QUERY EXECUTE '
  SELECT 
  si,
  CASE
    WHEN si<3 THEN ''none''
    WHEN si<4 THEN ''moderato''
    WHEN si=4 THEN ''intenso''
    ELSE ''molto intenso''
  END AS si_str_it
  , dataora, realtime.degree2cardinal(dd) AS direction, ROUND(ST_Distance(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), g_ellipse_app_test.the_geom)/1000)::integer AS distance, vv, 
b.localita, 
realtime.radian2cardinal(ST_Azimuth(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ST_SetSRID(ST_Point(utmx, utmy), 23032))::real) as position, utmx::integer, utmy::integer
FROM realtime.g_ellipse_app_test
, dati_di_base.limiti_amministrativi b 
WHERE 
ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), g_ellipse_app_test.the_geom) AND fulldate BETWEEN (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''16 minutes''::interval) AND (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''0 minutes''::interval) AND si>=' || si_input || '
AND ST_INTERSECTS(b.the_geom, ST_Transform(ST_SetSRID(ST_Point(utmx, utmy), 23032), 32632))
ORDER BY si DESC, fulldate DESC, distance ASC LIMIT 1;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.webgis_alert_test_fn(lon real, lat real, radius integer, si_input integer) OWNER TO postgres;

--
-- TOC entry 1513 (class 1255 OID 31277)
-- Name: webgis_list_fn(real, real, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION webgis_list_fn(lon real, lat real, radius integer, si_input integer) RETURNS TABLE(si integer, si_str_it text, dataora character varying, direction text, distance integer, vv integer, localita character varying, posizione text, utmx integer, utmy integer)
    LANGUAGE plpgsql ROWS 25
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
  THEN
  RETURN QUERY EXECUTE '
  SELECT 
  si,
  CASE
    WHEN si<3 THEN ''none''
    WHEN si<4 THEN ''moderato''
    WHEN si=4 THEN ''intenso''
    ELSE ''molto intenso''
  END AS si_str_it
  , dataora, realtime.degree2cardinal(dd) AS direction, ROUND(ST_Distance(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), g_ellipse_app.the_geom)/1000)::integer AS distance, vv::integer, 
b.localita, 
realtime.radian2cardinal(ST_Azimuth(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ST_SetSRID(ST_Point(utmx, utmy), 23032))::real) as position, utmx::integer, utmy::integer
FROM realtime.g_ellipse_app
, dati_di_base.limiti_amministrativi b 
WHERE 
ST_INTERSECTS(b.the_geom, ST_Transform(ST_SetSRID(ST_Point(utmx, utmy), 23032), 32632))
AND id_ellipse_gid2 IN (
SELECT DISTINCT ON (id_storm_track) id_ellipse_gid2 FROM realtime.g_ellipse_app WHERE 
ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), g_ellipse_app.the_geom) AND fulldate BETWEEN (now() - ''16 minutes''::interval) AND (now() - ''0 minutes''::interval) AND si>=' || si_input || ' 
ORDER BY id_storm_track, fulldate DESC, si DESC
) ORDER BY si DESC, fulldate DESC, distance ASC;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.webgis_list_fn(lon real, lat real, radius integer, si_input integer) OWNER TO postgres;

--
-- TOC entry 1514 (class 1255 OID 31278)
-- Name: webgis_list_test_fn(real, real, integer, integer); Type: FUNCTION; Schema: realtime; Owner: postgres
--

CREATE FUNCTION webgis_list_test_fn(lon real, lat real, radius integer, si_input integer) RETURNS TABLE(si integer, si_str_it text, dataora character varying, direction text, distance integer, vv integer, localita character varying, posizione text, utmx integer, utmy integer)
    LANGUAGE plpgsql ROWS 25
    AS $$
DECLARE
  anomalie integer;
BEGIN
  SELECT count(id_sistema) INTO anomalie FROM realtime.anomalie WHERE data_fine IS NULL AND id_sistema=6;
  IF anomalie < 1
  THEN
  RETURN QUERY EXECUTE '
  SELECT 
  si,
  CASE
    WHEN si<3 THEN ''none''
    WHEN si<4 THEN ''moderato''
    WHEN si=4 THEN ''intenso''
    ELSE ''molto intenso''
  END AS si_str_it
  , dataora, realtime.degree2cardinal(dd) AS direction, ROUND(ST_Distance(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), g_ellipse_app_test.the_geom)/1000)::integer AS distance, vv::integer, 
b.localita, 
realtime.radian2cardinal(ST_Azimuth(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ST_SetSRID(ST_Point(utmx, utmy), 23032))::real) as position, utmx::integer, utmy::integer
FROM realtime.g_ellipse_app_test
, dati_di_base.limiti_amministrativi b 
WHERE 
ST_INTERSECTS(b.the_geom, ST_Transform(ST_SetSRID(ST_Point(utmx, utmy), 23032), 32632))
AND id_ellipse_gid2 IN (
SELECT DISTINCT ON (id_storm_track) id_ellipse_gid2 FROM realtime.g_ellipse_app_test WHERE 
ST_INTERSECTS(ST_buffer(ST_Transform(ST_GeomFromText(''POINT(' || lon || ' ' || lat || ')'', 4326), 23032), ' || radius || '*1000.), g_ellipse_app_test.the_geom) AND fulldate BETWEEN (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''16 minutes''::interval) AND (to_timestamp(''201407291350'',''YYYYMMDDHH24MI'') - ''0 minutes''::interval) AND si>=' || si_input || ' 
ORDER BY id_storm_track, fulldate DESC, si DESC
) ORDER BY si DESC, fulldate DESC, distance ASC;
';
END IF;
END;
$$;


ALTER FUNCTION realtime.webgis_list_test_fn(lon real, lat real, radius integer, si_input integer) OWNER TO postgres;

SET search_path = topology, pg_catalog;

--
-- TOC entry 1445 (class 1255 OID 31175)
-- Name: _asgmledge(integer, integer, integer, public.geometry, regclass, text, integer, integer, text, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _asgmledge(edge_id integer, start_node integer, end_node integer, line public.geometry, visitedtable regclass, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  visited bool;
  nsprefix text;
  gml text;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Edge ' || nsprefix
    || 'id="' || idprefix || 'E' || edge_id || '">';

  -- Start node
  gml = gml || '<' || nsprefix || 'directedNode orientation="-"';
  -- Do visited bookkeeping if visitedTable was given
  visited = NULL;
  IF visitedTable IS NOT NULL THEN
    EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 1 AND element_id = '
            || start_node LIMIT 1 INTO visited;
    IF visited IS NOT NULL THEN
      gml = gml || ' xlink:href="#' || idprefix || 'N' || start_node || '" />';
    ELSE
      -- Mark as visited 
      EXECUTE 'INSERT INTO ' || visitedTable::text
        || '(element_type, element_id) VALUES (1, '
        || start_node || ')';
    END IF;
  END IF;
  IF visited IS NULL THEN
    gml = gml || '>';
    gml = gml || topology._AsGMLNode(start_node, NULL, nsprefix_in,
                                     prec, options, idprefix, gmlver);
    gml = gml || '</' || nsprefix || 'directedNode>';
  END IF;

  -- End node
  gml = gml || '<' || nsprefix || 'directedNode';
  -- Do visited bookkeeping if visitedTable was given
  visited = NULL;
  IF visitedTable IS NOT NULL THEN
    EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 1 AND element_id = '
            || end_node LIMIT 1 INTO visited;
    IF visited IS NOT NULL THEN
      gml = gml || ' xlink:href="#' || idprefix || 'N' || end_node || '" />';
    ELSE
      -- Mark as visited 
      EXECUTE 'INSERT INTO ' || visitedTable::text
        || '(element_type, element_id) VALUES (1, '
        || end_node || ')';
    END IF;
  END IF;
  IF visited IS NULL THEN
    gml = gml || '>';
    gml = gml || topology._AsGMLNode(end_node, NULL, nsprefix_in,
                                     prec, options, idprefix, gmlver);
    gml = gml || '</' || nsprefix || 'directedNode>';
  END IF;

  IF line IS NOT NULL THEN
    gml = gml || '<' || nsprefix || 'curveProperty>'
              || ST_AsGML(gmlver, line, prec, options, nsprefix_in)
              || '</' || nsprefix || 'curveProperty>';
  END IF;

  gml = gml || '</' || nsprefix || 'Edge>';

  RETURN gml;
END
$$;


ALTER FUNCTION topology._asgmledge(edge_id integer, start_node integer, end_node integer, line public.geometry, visitedtable regclass, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) OWNER TO postgres;

--
-- TOC entry 1446 (class 1255 OID 31176)
-- Name: _asgmlface(text, integer, regclass, text, integer, integer, text, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _asgmlface(toponame text, face_id integer, visitedtable regclass, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  visited bool;
  nsprefix text;
  gml text;
  rec RECORD;
  rec2 RECORD;
  bounds geometry;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Face ' || nsprefix
    || 'id="' || idprefix || 'F' || face_id || '">';

  -- Construct the face geometry, then for each polygon:
  FOR rec IN SELECT (ST_DumpRings((ST_Dump(ST_ForceRHR(
    topology.ST_GetFaceGeometry(toponame, face_id)))).geom)).geom
  LOOP

      -- Contents of a directed face are the list of edges
      -- that cover the specific ring
      bounds = ST_Boundary(rec.geom);

      FOR rec2 IN EXECUTE
        'SELECT e.*, ST_LineLocatePoint('
        || quote_literal(bounds::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
        || ', ST_LineLocatePoint('
        || quote_literal(bounds::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
        || quote_ident(toponame)
        || '.edge e WHERE ( e.left_face = ' || face_id
        || ' OR e.right_face = ' || face_id
        || ') AND ST_Covers('
        || quote_literal(bounds::text)
        || ', e.geom) ORDER BY pos'
      LOOP

        gml = gml || '<' || nsprefix || 'directedEdge';

        -- if this edge goes in same direction to the
        --       ring bounds, make it with negative orientation
        IF rec2.pos2 > rec2.pos THEN -- edge goes in same direction
          gml = gml || ' orientation="-"';
        END IF;

        -- Do visited bookkeeping if visitedTable was given
        IF visitedTable IS NOT NULL THEN

          EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 2 AND element_id = '
            || rec2.edge_id LIMIT 1 INTO visited;
          IF visited THEN
            -- Use xlink:href if visited
            gml = gml || ' xlink:href="#' || idprefix || 'E'
                      || rec2.edge_id || '" />';
            CONTINUE;
          ELSE
            -- Mark as visited otherwise
            EXECUTE 'INSERT INTO ' || visitedTable::text
              || '(element_type, element_id) VALUES (2, '
              || rec2.edge_id || ')';
          END IF;

        END IF;

        gml = gml || '>';

        gml = gml || topology._AsGMLEdge(rec2.edge_id, rec2.start_node,
                                        rec2.end_node, rec2.geom,
                                        visitedTable, nsprefix_in,
                                        prec, options, idprefix, gmlver);
        gml = gml || '</' || nsprefix || 'directedEdge>';

      END LOOP;
    END LOOP;

  gml = gml || '</' || nsprefix || 'Face>';

  RETURN gml;
END
$$;


ALTER FUNCTION topology._asgmlface(toponame text, face_id integer, visitedtable regclass, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) OWNER TO postgres;

--
-- TOC entry 1444 (class 1255 OID 31174)
-- Name: _asgmlnode(integer, public.geometry, text, integer, integer, text, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _asgmlnode(id integer, point public.geometry, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  nsprefix text;
  gml text;
BEGIN

  nsprefix := 'gml:';
  IF NOT nsprefix_in IS NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Node ' || nsprefix
    || 'id="' || idprefix || 'N' || id || '"';
  IF point IS NOT NULL THEN
    gml = gml || '>'
              || '<' || nsprefix || 'pointProperty>'
              || ST_AsGML(gmlver, point, prec, options, nsprefix_in)
              || '</' || nsprefix || 'pointProperty>'
              || '</' || nsprefix || 'Node>';
  ELSE
    gml = gml || '/>';
  END IF;
  RETURN gml;
END
$$;


ALTER FUNCTION topology._asgmlnode(id integer, point public.geometry, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) OWNER TO postgres;

--
-- TOC entry 1470 (class 1255 OID 31215)
-- Name: _st_addfacesplit(character varying, integer, integer, boolean); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _st_addfacesplit(atopology character varying, anedge integer, oface integer, mbr_only boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  fan RECORD;
  newface INTEGER;
  sql TEXT;
  isccw BOOLEAN;
  ishole BOOLEAN;

BEGIN

  IF oface = 0 AND mbr_only THEN
    RETURN NULL;
  END IF;

  SELECT null::int[] as newring_edges,
         null::geometry as shell
  INTO fan;

  SELECT array_agg(edge)
  FROM topology.getringedges(atopology, anedge)
  INTO STRICT fan.newring_edges;


  -- You can't get to the other side of an edge forming a ring 
  IF fan.newring_edges @> ARRAY[-anedge] THEN
    RETURN 0;
  END IF;


  sql := 'WITH ids as ( select row_number() over () as seq, edge from unnest('
    || quote_literal(fan.newring_edges::text)
    || '::int[] ) u(edge) ), edges AS ( select CASE WHEN i.edge < 0 THEN ST_Reverse(e.geom) ELSE e.geom END as g FROM ids i left join '
    || quote_ident(atopology) || '.edge_data e ON(e.edge_id = abs(i.edge)) ORDER BY seq) SELECT ST_MakePolygon(ST_MakeLine(g.g)) FROM edges g;';
  EXECUTE sql INTO fan.shell;


  isccw := NOT ST_OrderingEquals(fan.shell, ST_ForceRHR(fan.shell));


  IF oface = 0 THEN
    IF NOT isccw THEN
      RETURN NULL;
    END IF;
  END IF;

  IF mbr_only AND oface != 0 THEN
    -- Update old face mbr (nothing to do if we're opening an hole)
    IF isccw THEN -- {
      sql := 'UPDATE '
        || quote_ident(atopology) || '.face SET mbr = '
        || quote_literal(ST_Envelope(fan.shell)::text)
        || '::geometry WHERE face_id = ' || oface;
    	EXECUTE sql;
    END IF; -- }
    RETURN NULL;
  END IF;

  IF oface != 0 AND NOT isccw THEN -- {
    -- Face created an hole in an outer face
    sql := 'INSERT INTO '
      || quote_ident(atopology) || '.face(mbr) SELECT mbr FROM '
      || quote_ident(atopology)
      || '.face WHERE face_id = ' || oface
      || ' RETURNING face_id';
  ELSE
    sql := 'INSERT INTO '
      || quote_ident(atopology) || '.face(mbr) VALUES ('
      || quote_literal(ST_Envelope(fan.shell)::text)
      || '::geometry) RETURNING face_id';
  END IF; -- }

  -- Insert new face
  EXECUTE sql INTO STRICT newface;

  -- Update forward edges
  sql := 'UPDATE '
    || quote_ident(atopology) || '.edge_data SET left_face = ' || newface
    || ' WHERE left_face = ' || oface || ' AND edge_id = ANY ('
    || quote_literal(array( select +(x) from unnest(fan.newring_edges) u(x) )::text)
    || ')';
  EXECUTE sql;

  -- Update backward edges
  sql := 'UPDATE '
    || quote_ident(atopology) || '.edge_data SET right_face = ' || newface
    || ' WHERE right_face = ' || oface || ' AND edge_id = ANY ('
    || quote_literal(array( select -(x) from unnest(fan.newring_edges) u(x) )::text)
    || ')';
  EXECUTE sql;

  IF oface != 0 AND NOT isccw THEN -- {
    -- face shrinked, must update all non-contained edges and nodes
    ishole := true;
  ELSE
    ishole := false;
  END IF; -- }

  -- Update edges bounding the old face
  sql := 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET left_face = CASE WHEN left_face = '
    || oface || ' THEN ' || newface
    || ' ELSE left_face END, right_face = CASE WHEN right_face = '
    || oface || ' THEN ' || newface
    || ' ELSE right_face END WHERE ( left_face = ' || oface
    || ' OR right_face = ' || oface
    || ') AND NOT edge_id = ANY ('
    || quote_literal( array(
        select abs(x) from unnest(fan.newring_edges) u(x)
       )::text )
    || ') AND ';
  IF ishole THEN sql := sql || 'NOT '; END IF;
  sql := sql || '( ' || quote_literal(fan.shell::text)
    || ' && geom AND _ST_Contains(' || quote_literal(fan.shell::text)
    -- We only need to check a single point, but must not be an endpoint
    || '::geometry, ST_LineInterpolatePoint(geom, 0.2)) )';
  EXECUTE sql;

  -- Update isolated nodes in new new face 
  sql := 'UPDATE '
    || quote_ident(atopology) || '.node SET containing_face = ' || newface
    || ' WHERE containing_face = ' || oface 
    || ' AND ';
  IF ishole THEN sql := sql || 'NOT '; END IF;
  sql := sql || 'ST_Contains(' || quote_literal(fan.shell::text) || '::geometry, geom)';
  EXECUTE sql;

  RETURN newface;

END
$$;


ALTER FUNCTION topology._st_addfacesplit(atopology character varying, anedge integer, oface integer, mbr_only boolean) OWNER TO postgres;

--
-- TOC entry 1468 (class 1255 OID 31212)
-- Name: _st_adjacentedges(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _st_adjacentedges(atopology character varying, anode integer, anedge integer) RETURNS integer[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  ret integer[];
BEGIN
  WITH edgestar AS (
    SELECT *, count(*) over () AS cnt
    FROM topology.GetNodeEdges(atopology, anode)
  )
  SELECT ARRAY[ (
      SELECT p.edge AS prev FROM edgestar p
      WHERE p.sequence = CASE WHEN m.sequence-1 < 1 THEN cnt
                         ELSE m.sequence-1 END
    ), (
      SELECT p.edge AS prev FROM edgestar p WHERE p.sequence = ((m.sequence)%cnt)+1
    ) ]
  FROM edgestar m
  WHERE edge = anedge
  INTO ret;

  RETURN ret;
END
$$;


ALTER FUNCTION topology._st_adjacentedges(atopology character varying, anode integer, anedge integer) OWNER TO postgres;

--
-- TOC entry 1425 (class 1255 OID 31152)
-- Name: _st_mintolerance(public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _st_mintolerance(ageom public.geometry) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT 3.6 * power(10,  - ( 15 - log(coalesce(
      nullif(
        greatest(abs(ST_xmin($1)), abs(ST_ymin($1)),
                 abs(ST_xmax($1)), abs(ST_ymax($1))),
        0),
      1)) ));
$_$;


ALTER FUNCTION topology._st_mintolerance(ageom public.geometry) OWNER TO postgres;

--
-- TOC entry 1426 (class 1255 OID 31153)
-- Name: _st_mintolerance(character varying, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _st_mintolerance(atopology character varying, ageom public.geometry) RETURNS double precision
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
  ret FLOAT8;
BEGIN
  SELECT COALESCE(
    NULLIF(precision, 0),
    topology._st_mintolerance($2))
  FROM topology.topology
  WHERE name = $1 INTO ret;
  IF NOT FOUND THEN
    RAISE EXCEPTION
      'No topology with name "%" in topology.topology', atopology;
  END IF;
  return ret;
END;
$_$;


ALTER FUNCTION topology._st_mintolerance(atopology character varying, ageom public.geometry) OWNER TO postgres;

--
-- TOC entry 1458 (class 1255 OID 31196)
-- Name: _st_remedgecheck(character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION _st_remedgecheck(tname character varying, tid integer, eid integer, lf integer, rf integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  sql text;
  fidary int[];
  rec RECORD;
BEGIN
  -- Check that no TopoGeometry references the edge being removed
  sql := 'SELECT r.topogeo_id, r.layer_id'
      || ', l.schema_name, l.table_name, l.feature_column '
      || 'FROM topology.layer l INNER JOIN '
      || quote_ident(tname)
      || '.relation r ON (l.layer_id = r.layer_id) '
      || 'WHERE l.level = 0 AND l.feature_type = 2 '
      || ' AND l.topology_id = ' || tid
      || ' AND abs(r.element_id) = ' || eid ;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented dropping edge %',
            rec.topogeo_id, rec.layer_id,
            rec.schema_name, rec.table_name, rec.feature_column,
            eid;
  END LOOP;

  IF lf != rf THEN -- {

    RAISE NOTICE 'Deletion of edge % joins faces % and %',
                    eid, lf, rf;

    -- check if any topo_geom is defined only by one of the
    -- joined faces. In such case there would be no way to adapt
    -- the definition in case of healing, so we'd have to bail out
    -- 
    fidary = ARRAY[lf, rf];
    sql := 'SELECT t.* from ('
      || 'SELECT r.topogeo_id, r.layer_id'
      || ', l.schema_name, l.table_name, l.feature_column'
      || ', array_agg(r.element_id) as elems '
      || 'FROM topology.layer l INNER JOIN '
      || quote_ident(tname)
      || '.relation r ON (l.layer_id = r.layer_id) '
      || 'WHERE l.level = 0 AND l.feature_type = 3 '
      || ' AND l.topology_id = ' || tid
      || ' AND r.element_id = ANY (' || quote_literal(fidary)
      || ') group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
      || ' l.feature_column ) t';

    -- No surface can be defined by universal face 
    IF lf != 0 AND rf != 0 THEN -- {
      sql := sql || ' WHERE NOT t.elems @> ' || quote_literal(fidary);
    END IF; -- }


    FOR rec IN EXECUTE sql LOOP
      RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing faces % and %',
            rec.topogeo_id, rec.layer_id,
            rec.schema_name, rec.table_name, rec.feature_column,
            rf, lf;
    END LOOP;

  END IF; -- } two faces healed...
END
$$;


ALTER FUNCTION topology._st_remedgecheck(tname character varying, tid integer, eid integer, lf integer, rf integer) OWNER TO postgres;

--
-- TOC entry 1429 (class 1255 OID 31156)
-- Name: addedge(character varying, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addedge(atopology character varying, aline public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	edgeid int;
	rec RECORD;
  ix geometry; 
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR aline IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Aline must be a linestring
	--
	IF substring(geometrytype(aline), 1, 4) != 'LINE'
	THEN
		RAISE EXCEPTION 'Edge geometry must be a linestring';
	END IF;

	--
	-- Check there's no face registered in the topology
	--
	FOR rec IN EXECUTE 'SELECT count(face_id) FROM '
		|| quote_ident(atopology) || '.face '
		|| ' WHERE face_id != 0 LIMIT 1'
	LOOP
		IF rec.count > 0 THEN
			RAISE EXCEPTION 'AddEdge can only be used against topologies with no faces defined';
		END IF;
	END LOOP;

	--
	-- Check if the edge crosses an existing node
	--
	FOR rec IN EXECUTE 'SELECT node_id FROM '
		|| quote_ident(atopology) || '.node '
		|| 'WHERE ST_Crosses('
		|| quote_literal(aline::text) || '::geometry, geom'
		|| ')'
	LOOP
		RAISE EXCEPTION 'Edge crosses node %', rec.node_id;
	END LOOP;

	--
	-- Check if the edge intersects an existing edge
	-- on anything but endpoints
	--
	-- Following DE-9 Intersection Matrix represent
	-- the only relation we accept. 
	--
	--    F F 1
	--    F * *
	--    1 * 2
	--
	-- Example1: linestrings touching at one endpoint
	--    FF1 F00 102
	--    FF1 F** 1*2 <-- our match
	--
	-- Example2: linestrings touching at both endpoints
	--    FF1 F0F 1F2
	--    FF1 F** 1*2 <-- our match
	--
	FOR rec IN EXECUTE 'SELECT edge_id, geom, ST_Relate('
		|| quote_literal(aline::text)
		|| '::geometry, geom, 2) as im'
		|| ' FROM '
		|| quote_ident(atopology) || '.edge '
		|| 'WHERE '
		|| quote_literal(aline::text) || '::geometry && geom'

	LOOP

	  IF ST_RelateMatch(rec.im, 'FF1F**1*2') THEN
	    CONTINUE; -- no interior intersection
	  END IF;

	  -- Reuse an EQUAL edge (be it closed or not)
	  IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
	      RETURN rec.edge_id;
	  END IF;

	  -- WARNING: the constructive operation might throw an exception
	  BEGIN
	    ix = ST_Intersection(rec.geom, aline);
	  EXCEPTION
	  WHEN OTHERS THEN
	    RAISE NOTICE 'Could not compute intersection between input edge (%) and edge % (%)', aline::text, rec.edge_id, rec.geom::text;
	  END;

	  RAISE EXCEPTION 'Edge intersects (not on endpoints) with existing edge % at or near point %', rec.edge_id, ST_AsText(ST_PointOnSurface(ix));

	END LOOP;

	--
	-- Get new edge id from sequence
	--
	FOR rec IN EXECUTE 'SELECT nextval(' ||
		quote_literal(
			quote_ident(atopology) || '.edge_data_edge_id_seq'
		) || ')'
	LOOP
		edgeid = rec.nextval;
	END LOOP;

	--
	-- Insert the new row
	--
	EXECUTE 'INSERT INTO '
		|| quote_ident(atopology)
		|| '.edge(edge_id, start_node, end_node, '
		|| 'next_left_edge, next_right_edge, '
		|| 'left_face, right_face, '
		|| 'geom) '
		|| ' VALUES('

		-- edge_id
		|| edgeid ||','

		-- start_node
		|| 'topology.addNode('
		|| quote_literal(atopology)
		|| ', ST_StartPoint('
		|| quote_literal(aline::text)
		|| ')) ,'

		-- end_node
		|| 'topology.addNode('
		|| quote_literal(atopology)
		|| ', ST_EndPoint('
		|| quote_literal(aline::text)
		|| ')) ,'

		-- next_left_edge
		|| -edgeid ||','

		-- next_right_edge
		|| edgeid ||','

		-- left_face
		|| '0,'

		-- right_face
		|| '0,'

		-- geom
		||quote_literal(aline::text)
		|| ')';

	RETURN edgeid;
	
END
$$;


ALTER FUNCTION topology.addedge(atopology character varying, aline public.geometry) OWNER TO postgres;

--
-- TOC entry 1430 (class 1255 OID 31157)
-- Name: addface(character varying, public.geometry, boolean); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addface(atopology character varying, apoly public.geometry, force_new boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  bounds geometry;
  symdif geometry;
  faceid int;
  rec RECORD;
  rrec RECORD;
  relate text;
  right_edges int[];
  left_edges int[];
  all_edges geometry;
  old_faceid int;
  old_edgeid int;
  sql text;
  right_side bool;
  edgeseg geometry;
  p1 geometry;
  p2 geometry;
  p3 geometry;
  loc float8;
  segnum int;
  numsegs int;
BEGIN
  --
  -- Atopology and apoly are required
  -- 
  IF atopology IS NULL OR apoly IS NULL THEN
    RAISE EXCEPTION 'Invalid null argument';
  END IF;

  --
  -- Aline must be a polygon
  --
  IF substring(geometrytype(apoly), 1, 4) != 'POLY'
  THEN
    RAISE EXCEPTION 'Face geometry must be a polygon';
  END IF;

  for rrec IN SELECT (ST_DumpRings(ST_ForceRHR(apoly))).geom
  LOOP -- {
    --
    -- Find all bounds edges, forcing right-hand-rule
    -- to know what's left and what's right...
    --
    bounds = ST_Boundary(rrec.geom);

    sql := 'SELECT e.geom, e.edge_id, '
      || 'e.left_face, e.right_face FROM '
      || quote_ident(atopology) || '.edge e, (SELECT '
      || quote_literal(bounds::text)
      || '::geometry as geom) r WHERE '
      || 'r.geom && e.geom'
    ;
    -- RAISE DEBUG 'SQL: %', sql;
    FOR rec IN EXECUTE sql
    LOOP -- {
      --RAISE DEBUG 'Edge % has bounding box intersection', rec.edge_id;

      -- Find first non-empty segment of the edge
      numsegs = ST_NumPoints(rec.geom);
      segnum = 1;
      WHILE segnum < numsegs LOOP
        p1 = ST_PointN(rec.geom, segnum);
        p2 = ST_PointN(rec.geom, segnum+1);
        IF ST_Distance(p1, p2) > 0 THEN
          EXIT;
        END IF;
        segnum = segnum + 1;
      END LOOP;

      IF segnum = numsegs THEN
        RAISE WARNING 'Edge % is collapsed', rec.edge_id;
        CONTINUE; -- we don't want to spend time on it
      END IF;

      edgeseg = ST_MakeLine(p1, p2);

      -- Skip non-covered edges
      IF NOT ST_Equals(p2, ST_EndPoint(rec.geom)) THEN
        IF NOT ( _ST_Intersects(bounds, p1) AND _ST_Intersects(bounds, p2) )
        THEN
          --RAISE DEBUG 'Edge % has points % and % not intersecting with ring bounds', rec.edge_id, st_astext(p1), st_astext(p2);
          CONTINUE;
        END IF;
      ELSE
        -- must be a 2-points only edge, let's use Covers (more expensive)
        IF NOT _ST_Covers(bounds, edgeseg) THEN
          --RAISE DEBUG 'Edge % is not covered by ring', rec.edge_id;
          CONTINUE;
        END IF;
      END IF;

      p3 = ST_StartPoint(bounds);
      IF ST_DWithin(edgeseg, p3, 0) THEN
        -- Edge segment covers ring endpoint, See bug #874
        loc = ST_LineLocatePoint(edgeseg, p3);
        -- WARNING: this is as robust as length of edgeseg allows...
        IF loc > 0.9 THEN
          -- shift last point down 
          p2 = ST_LineInterpolatePoint(edgeseg, loc - 0.1);
        ELSIF loc < 0.1 THEN
          -- shift first point up
          p1 = ST_LineInterpolatePoint(edgeseg, loc + 0.1); 
        ELSE
          -- when ring start point is in between, we swap the points
          p3 = p1; p1 = p2; p2 = p3;
        END IF;
      END IF;

      right_side = ST_LineLocatePoint(bounds, p1) < 
                   ST_LineLocatePoint(bounds, p2);
  

      IF right_side THEN
        right_edges := array_append(right_edges, rec.edge_id);
        old_faceid = rec.right_face;
      ELSE
        left_edges := array_append(left_edges, rec.edge_id);
        old_faceid = rec.left_face;
      END IF;

      IF faceid IS NULL OR faceid = 0 THEN
        faceid = old_faceid;
        old_edgeid = rec.edge_id;
      ELSIF faceid != old_faceid THEN
        RAISE EXCEPTION 'Edge % has face % registered on the side of this face, while edge % has face % on the same side', rec.edge_id, old_faceid, old_edgeid, faceid;
      END IF;

      -- Collect all edges for final full coverage check
      all_edges = ST_Collect(all_edges, rec.geom);

    END LOOP; -- }
  END LOOP; -- }

  IF all_edges IS NULL THEN
    RAISE EXCEPTION 'Found no edges on the polygon boundary';
  END IF;


  --
  -- Check that all edges found, taken togheter,
  -- fully match the ring boundary and nothing more
  --
  -- If the test fail either we need to add more edges
  -- from the polygon ring or we need to split
  -- some of the existing ones.
  -- 
  bounds = ST_Boundary(apoly);
  IF NOT ST_isEmpty(ST_SymDifference(bounds, all_edges)) THEN
    IF NOT ST_isEmpty(ST_Difference(bounds, all_edges)) THEN
      RAISE EXCEPTION 'Polygon boundary is not fully defined by existing edges at or near point %', ST_AsText(ST_PointOnSurface(ST_Difference(bounds, all_edges)));
    ELSE
      RAISE EXCEPTION 'Existing edges cover polygon boundary and more at or near point % (invalid topology?)', ST_AsText(ST_PointOnSurface(ST_Difference(all_edges, bounds)));
    END IF;
  END IF;

  IF faceid IS NOT NULL AND faceid != 0 THEN
    IF NOT force_new THEN
      RETURN faceid;
    ELSE
    END IF;
  END IF;

  --
  -- Get new face id from sequence
  --
  FOR rec IN EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(atopology) || '.face_face_id_seq'
    ) || ')'
  LOOP
    faceid = rec.nextval;
  END LOOP;

  --
  -- Insert new face 
  --
  EXECUTE 'INSERT INTO '
    || quote_ident(atopology)
    || '.face(face_id, mbr) VALUES('
    -- face_id
    || faceid || ','
    -- minimum bounding rectangle
    || quote_literal(ST_Envelope(apoly)::text)
    || ')';

  --
  -- Update all edges having this face on the left
  --
  IF left_edges IS NOT NULL THEN
    EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET left_face = '
    || quote_literal(faceid)
    || ' WHERE edge_id = ANY('
    || quote_literal(left_edges)
    || ') ';
  END IF;

  --
  -- Update all edges having this face on the right
  --
  IF right_edges IS NOT NULL THEN
    EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET right_face = '
    || quote_literal(faceid)
    || ' WHERE edge_id = ANY('
    || quote_literal(right_edges)
    || ') ';
  END IF;


  --
  -- Set left_face/right_face of any contained edge 
  --
  EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET right_face = '
    || quote_literal(faceid)
    || ', left_face = '
    || quote_literal(faceid)
    || ' WHERE ST_Contains('
    || quote_literal(apoly::text)
    || ', geom)';

  -- 
  -- Set containing_face of any contained node 
  -- 
  EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.node SET containing_face = '
    || quote_literal(faceid)
    || ' WHERE containing_face IS NOT NULL AND ST_Contains('
    || quote_literal(apoly::text)
    || ', geom)';

  RETURN faceid;
	
END
$$;


ALTER FUNCTION topology.addface(atopology character varying, apoly public.geometry, force_new boolean) OWNER TO postgres;

--
-- TOC entry 1428 (class 1255 OID 31155)
-- Name: addnode(character varying, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addnode(atopology character varying, apoint public.geometry) RETURNS integer
    LANGUAGE sql
    AS $_$
  SELECT topology.AddNode($1, $2, false, false);
$_$;


ALTER FUNCTION topology.addnode(atopology character varying, apoint public.geometry) OWNER TO postgres;

--
-- TOC entry 1427 (class 1255 OID 31154)
-- Name: addnode(character varying, public.geometry, boolean, boolean); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addnode(atopology character varying, apoint public.geometry, allowedgesplitting boolean, setcontainingface boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	nodeid int;
	rec RECORD;
  containing_face int;
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Check if a coincident node already exists
	-- 
	-- We use index AND x/y equality
	--
	FOR rec IN EXECUTE 'SELECT node_id FROM '
		|| quote_ident(atopology) || '.node ' ||
		'WHERE geom && ' || quote_literal(apoint::text) || '::geometry'
		||' AND ST_X(geom) = ST_X('||quote_literal(apoint::text)||'::geometry)'
		||' AND ST_Y(geom) = ST_Y('||quote_literal(apoint::text)||'::geometry)'
	LOOP
		RETURN  rec.node_id;
	END LOOP;

	--
	-- Check if any edge crosses this node
	-- (endpoints are fine)
	--
	FOR rec IN EXECUTE 'SELECT edge_id FROM '
		|| quote_ident(atopology) || '.edge ' 
		|| 'WHERE ST_DWithin('
		|| quote_literal(apoint::text) 
		|| ', geom, 0) AND NOT ST_Equals('
		|| quote_literal(apoint::text)
		|| ', ST_StartPoint(geom)) AND NOT ST_Equals('
		|| quote_literal(apoint::text)
		|| ', ST_EndPoint(geom))'
	LOOP
    IF allowEdgeSplitting THEN
      RETURN topology.ST_ModEdgeSplit(atopology, rec.edge_id, apoint);
    ELSE
		  RAISE EXCEPTION 'An edge crosses the given node.';
    END IF;
	END LOOP;

  IF setContainingFace THEN
    containing_face := topology.GetFaceByPoint(atopology, apoint, 0);
  ELSE
    containing_face := NULL;
  END IF;

	--
	-- Get new node id from sequence
	--
	FOR rec IN EXECUTE 'SELECT nextval(' ||
		quote_literal(
			quote_ident(atopology) || '.node_node_id_seq'
		) || ')'
	LOOP
		nodeid = rec.nextval;
	END LOOP;

	--
	-- Insert the new row
	--
	EXECUTE 'INSERT INTO ' || quote_ident(atopology)
		|| '.node(node_id, containing_face, geom) 
		VALUES(' || nodeid || ',' || coalesce(containing_face::text, 'NULL') || ','
    || quote_literal(apoint::text) || ')';

	RETURN nodeid;
	
END
$$;


ALTER FUNCTION topology.addnode(atopology character varying, apoint public.geometry, allowedgesplitting boolean, setcontainingface boolean) OWNER TO postgres;

--
-- TOC entry 1401 (class 1255 OID 31123)
-- Name: addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE sql
    AS $_$
  SELECT topology.AddTopoGeometryColumn($1, $2, $3, $4, $5, NULL);
$_$;


ALTER FUNCTION topology.addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1400 (class 1255 OID 31122)
-- Name: addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addtopogeometrycolumn(toponame character varying, schema character varying, tbl character varying, col character varying, ltype character varying, child integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  intltype integer;
  newlevel integer;
  topoid integer;
  rec RECORD;
  newlayer_id integer;
  query text;
BEGIN

        -- Get topology id
        SELECT id FROM topology.topology into topoid
                WHERE name = toponame;

  IF topoid IS NULL THEN
    RAISE EXCEPTION 'Topology % does not exist', toponame;
  END IF;

  IF ltype ILIKE '%POINT%' OR ltype ILIKE 'PUNTAL' THEN
    intltype = 1;
  ELSIF ltype ILIKE '%LINE%' OR ltype ILIKE 'LINEAL' THEN
    intltype = 2;
  ELSIF ltype ILIKE '%POLYGON%' OR ltype ILIKE 'AREAL' THEN
    intltype = 3;
  ELSIF ltype ILIKE '%COLLECTION%' OR ltype ILIKE 'GEOMETRY' THEN
    intltype = 4;
  ELSE
    RAISE EXCEPTION 'Layer type must be one of POINT,LINE,POLYGON,COLLECTION';
  END IF;

  --
  -- Add new TopoGeometry column in schema.table
  --
  EXECUTE 'ALTER TABLE ' || quote_ident(schema)
    || '.' || quote_ident(tbl) 
    || ' ADD COLUMN ' || quote_ident(col)
    || ' topology.TopoGeometry;';


  --
  -- See if child id exists and extract its level
  --
  IF child IS NOT NULL THEN
    SELECT level + 1 FROM topology.layer
      WHERE layer_id = child
      INTO newlevel;
    IF newlevel IS NULL THEN
      RAISE EXCEPTION 'Child layer % does not exist in topology "%"', child, toponame;
    END IF;
  END IF;

  --
  -- Get new layer id from sequence
  --
  EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(toponame) || '.layer_id_seq'
    ) || ')' INTO STRICT newlayer_id;

  EXECUTE 'INSERT INTO ' 
    || 'topology.layer(topology_id, '
    || 'layer_id, level, child_id, schema_name, '
    || 'table_name, feature_column, feature_type) '
    || 'VALUES ('
    || topoid || ','
    || newlayer_id || ',' || COALESCE(newlevel, 0) || ','
    || COALESCE(child::text, 'NULL') || ','
    || quote_literal(schema) || ','
    || quote_literal(tbl) || ','
    || quote_literal(col) || ','
    || intltype || ');';


  --
  -- Create a sequence for TopoGeometries in this new layer
  --
  EXECUTE 'CREATE SEQUENCE ' || quote_ident(toponame)
    || '.topogeo_s_' || newlayer_id;

  --
  -- Add constraints on TopoGeom column
  --
  EXECUTE 'ALTER TABLE ' || quote_ident(schema)
    || '.' || quote_ident(tbl) 
    || ' ADD CONSTRAINT "check_topogeom_' || col || '" CHECK ('
    || 'topology_id(' || quote_ident(col) || ') = ' || topoid
    || ' AND '
    || 'layer_id(' || quote_ident(col) || ') = ' || newlayer_id
    || ' AND '
    || 'type(' || quote_ident(col) || ') = ' || intltype
    || ');';

  --
  -- Add dependency of the feature column on the topology schema
  --
  query = 'INSERT INTO pg_catalog.pg_depend SELECT '
    || 'fcat.oid, fobj.oid, fsub.attnum, tcat.oid, '
    || 'tobj.oid, 0, ''n'' '
    || 'FROM pg_class fcat, pg_namespace fnsp, '
    || ' pg_class fobj, pg_attribute fsub, '
    || ' pg_class tcat, pg_namespace tobj '
    || ' WHERE fcat.relname = ''pg_class'' '
    || ' AND fnsp.nspname = ' || quote_literal(schema)
    || ' AND fobj.relnamespace = fnsp.oid '
    || ' AND fobj.relname = ' || quote_literal(tbl)
    || ' AND fsub.attrelid = fobj.oid '
    || ' AND fsub.attname = ' || quote_literal(col)
    || ' AND tcat.relname = ''pg_namespace'' '
    || ' AND tobj.nspname = ' || quote_literal(toponame);

--
-- The only reason to add this dependency is to avoid
-- simple drop of a feature column. Still, drop cascade
-- will remove both the feature column and the sequence
-- corrupting the topology anyway ...
--

  RETURN newlayer_id;
END;
$$;


ALTER FUNCTION topology.addtopogeometrycolumn(toponame character varying, schema character varying, tbl character varying, col character varying, ltype character varying, child integer) OWNER TO postgres;

--
-- TOC entry 1477 (class 1255 OID 31224)
-- Name: addtosearchpath(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION addtosearchpath(a_schema_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	var_result text;
	var_cur_search_path text;
BEGIN
	SELECT reset_val INTO var_cur_search_path FROM pg_settings WHERE name = 'search_path';
	IF var_cur_search_path LIKE '%' || quote_ident(a_schema_name) || '%' THEN
		var_result := a_schema_name || ' already in database search_path';
	ELSE
		EXECUTE 'ALTER DATABASE ' || quote_ident(current_database()) || ' SET search_path = ' || var_cur_search_path || ', ' || quote_ident(a_schema_name); 
		var_result := a_schema_name || ' has been added to end of database search_path ';
	END IF;
  
  RETURN var_result;
END
$$;


ALTER FUNCTION topology.addtosearchpath(a_schema_name character varying) OWNER TO postgres;

--
-- TOC entry 1454 (class 1255 OID 31185)
-- Name: asgml(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
 SELECT topology.AsGML($1, 'gml');
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry) OWNER TO postgres;

--
-- TOC entry 1452 (class 1255 OID 31183)
-- Name: asgml(topogeometry, regclass); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, visitedtable regclass) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, 'gml', 15, 1, $2);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, visitedtable regclass) OWNER TO postgres;

--
-- TOC entry 1451 (class 1255 OID 31182)
-- Name: asgml(topogeometry, text); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
 SELECT topology.AsGML($1, $2, 15, 1, NULL);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text) OWNER TO postgres;

--
-- TOC entry 1453 (class 1255 OID 31184)
-- Name: asgml(topogeometry, regclass, text); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, visitedtable regclass, nsprefix text) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, $3, 15, 1, $2);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, visitedtable regclass, nsprefix text) OWNER TO postgres;

--
-- TOC entry 1450 (class 1255 OID 31181)
-- Name: asgml(topogeometry, text, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, opts integer) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
 SELECT topology.AsGML($1, $2, $3, $4, NULL);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text, prec integer, opts integer) OWNER TO postgres;

--
-- TOC entry 1449 (class 1255 OID 31180)
-- Name: asgml(topogeometry, text, integer, integer, regclass); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, vis regclass) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, $2, $3, $4, $5, '');
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text, prec integer, options integer, vis regclass) OWNER TO postgres;

--
-- TOC entry 1448 (class 1255 OID 31179)
-- Name: asgml(topogeometry, text, integer, integer, regclass, text); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, visitedtable regclass, idprefix text) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, $2, $3, $4, $5, $6, 3);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text, prec integer, options integer, visitedtable regclass, idprefix text) OWNER TO postgres;

--
-- TOC entry 1447 (class 1255 OID 31177)
-- Name: asgml(topogeometry, text, integer, integer, regclass, text, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix_in text, precision_in integer, options_in integer, visitedtable regclass, idprefix text, gmlver integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  nsprefix text;
  precision int;
  options int;
  visited bool;
  toponame text;
  gml text;
  sql text;
  rec RECORD;
  rec2 RECORD;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  precision := 15;
  IF precision_in IS NOT NULL THEN
    precision = precision_in;
  END IF;

  options := 1;
  IF options_in IS NOT NULL THEN
    options = options_in;
  END IF;

  -- Get topology name (for subsequent queries)
  SELECT name FROM topology.topology into toponame
              WHERE id = tg.topology_id;

  -- Puntual TopoGeometry
  IF tg.type = 1 THEN
    gml = '<' || nsprefix || 'TopoPoint>';
    -- For each defining node, print a directedNode
    FOR rec IN  EXECUTE 'SELECT r.element_id, n.geom from '
      || quote_ident(toponame) || '.relation r LEFT JOIN '
      || quote_ident(toponame) || '.node n ON (r.element_id = n.node_id)'
      || ' WHERE r.layer_id = ' || tg.layer_id
      || ' AND r.topogeo_id = ' || tg.id
    LOOP
      gml = gml || '<' || nsprefix || 'directedNode';
      -- Do visited bookkeeping if visitedTable was given
      IF visitedTable IS NOT NULL THEN
        EXECUTE 'SELECT true FROM '
                || visitedTable::text
                || ' WHERE element_type = 1 AND element_id = '
                || rec.element_id LIMIT 1 INTO visited;
        IF visited IS NOT NULL THEN
          gml = gml || ' xlink:href="#' || idprefix || 'N' || rec.element_id || '" />';
          CONTINUE;
        ELSE
          -- Mark as visited 
          EXECUTE 'INSERT INTO ' || visitedTable::text
            || '(element_type, element_id) VALUES (1, '
            || rec.element_id || ')';
        END IF;
      END IF;
      gml = gml || '>';
      gml = gml || topology._AsGMLNode(rec.element_id, rec.geom, nsprefix_in, precision, options, idprefix, gmlver);
      gml = gml || '</' || nsprefix || 'directedNode>';
    END LOOP;
    gml = gml || '</' || nsprefix || 'TopoPoint>';
    RETURN gml;

  ELSIF tg.type = 2 THEN -- lineal
    gml = '<' || nsprefix || 'TopoCurve>';

    FOR rec IN SELECT (ST_Dump(topology.Geometry(tg))).geom
    LOOP
      FOR rec2 IN EXECUTE
        'SELECT e.*, ST_LineLocatePoint('
        || quote_literal(rec.geom::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
        || ', ST_LineLocatePoint('
        || quote_literal(rec.geom::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
        || quote_ident(toponame)
        || '.edge e WHERE ST_Covers('
        || quote_literal(rec.geom::text)
        || ', e.geom) ORDER BY pos'
        -- TODO: add relation to the conditional, to reduce load ?
      LOOP

        gml = gml || '<' || nsprefix || 'directedEdge';

        -- if this edge goes in opposite direction to the
        --       line, make it with negative orientation
        IF rec2.pos2 < rec2.pos THEN -- edge goes in opposite direction
          gml = gml || ' orientation="-"';
        END IF;

        -- Do visited bookkeeping if visitedTable was given
        IF visitedTable IS NOT NULL THEN

          EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 2 AND element_id = '
            || rec2.edge_id LIMIT 1 INTO visited;
          IF visited THEN
            -- Use xlink:href if visited
            gml = gml || ' xlink:href="#' || idprefix || 'E' || rec2.edge_id || '" />';
            CONTINUE;
          ELSE
            -- Mark as visited otherwise
            EXECUTE 'INSERT INTO ' || visitedTable::text
              || '(element_type, element_id) VALUES (2, '
              || rec2.edge_id || ')';
          END IF;

        END IF;


        gml = gml || '>';

        gml = gml || topology._AsGMLEdge(rec2.edge_id,
                                        rec2.start_node,
                                        rec2.end_node, rec2.geom,
                                        visitedTable,
                                        nsprefix_in, precision,
                                        options, idprefix, gmlver);


        gml = gml || '</' || nsprefix || 'directedEdge>';
      END LOOP;
    END LOOP;

    gml = gml || '</' || nsprefix || 'TopoCurve>';
    return gml;

  ELSIF tg.type = 3 THEN -- areal
    gml = '<' || nsprefix || 'TopoSurface>';

    -- For each defining face, print a directedFace
    FOR rec IN  EXECUTE 'SELECT f.face_id from '
      || quote_ident(toponame) || '.relation r LEFT JOIN '
      || quote_ident(toponame) || '.face f ON (r.element_id = f.face_id)'
      || ' WHERE r.layer_id = ' || tg.layer_id
      || ' AND r.topogeo_id = ' || tg.id
    LOOP
      gml = gml || '<' || nsprefix || 'directedFace';
      -- Do visited bookkeeping if visitedTable was given
      IF visitedTable IS NOT NULL THEN
        EXECUTE 'SELECT true FROM '
                || visitedTable::text
                || ' WHERE element_type = 3 AND element_id = '
                || rec.face_id LIMIT 1 INTO visited;
        IF visited IS NOT NULL THEN
          gml = gml || ' xlink:href="#' || idprefix || 'F' || rec.face_id || '" />';
          CONTINUE;
        ELSE
          -- Mark as visited 
          EXECUTE 'INSERT INTO ' || visitedTable::text
            || '(element_type, element_id) VALUES (3, '
            || rec.face_id || ')';
        END IF;
      END IF;
      gml = gml || '>';
      gml = gml || topology._AsGMLFace(toponame, rec.face_id, visitedTable,
                                       nsprefix_in, precision,
                                       options, idprefix, gmlver);
      gml = gml || '</' || nsprefix || 'directedFace>';
    END LOOP;
    gml = gml || '</' || nsprefix || 'TopoSurface>';
    RETURN gml;

  ELSIF tg.type = 4 THEN -- collection
    RAISE EXCEPTION 'Collection TopoGeometries are not supported by AsGML';

  END IF;
	

  RETURN gml;
	
END
$$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix_in text, precision_in integer, options_in integer, visitedtable regclass, idprefix text, gmlver integer) OWNER TO postgres;

--
-- TOC entry 1441 (class 1255 OID 31186)
-- Name: astopojson(topogeometry, regclass); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION astopojson(tg topogeometry, edgemaptable regclass) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  toponame text;
  json text;
  sql text;
  bounds GEOMETRY;
  rec RECORD;
  rec2 RECORD;
  side int;
  arcid int;
  arcs int[];
  ringtxt TEXT[];
  comptxt TEXT[];
  edges_found BOOLEAN;
  old_search_path TEXT;
  all_faces int[];
  faces int[];
  visited_face int;
  shell_faces int[];
  visited_edges int[];
  looking_for_holes BOOLEAN;
BEGIN

  IF tg IS NULL THEN
    RETURN NULL;
  END IF;

  -- Get topology name (for subsequent queries)
  SELECT name FROM topology.topology into toponame
              WHERE id = tg.topology_id;

  -- Puntual TopoGeometry
  IF tg.type = 1 THEN
    -- TODO: implement scale ?
    --json := ST_AsGeoJSON(topology.Geometry(tg));
    --return json;
    RAISE EXCEPTION 'TopoJSON export does not support puntual objects';
  ELSIF tg.type = 2 THEN -- lineal

    FOR rec IN SELECT (ST_Dump(topology.Geometry(tg))).geom
    LOOP -- {

      sql := 'SELECT e.*, ST_LineLocatePoint('
            || quote_literal(rec.geom::text)
            || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
            || ', ST_LineLocatePoint('
            || quote_literal(rec.geom::text)
            || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
            || quote_ident(toponame)
            || '.edge e WHERE ST_Covers('
            || quote_literal(rec.geom::text)
            || ', e.geom) ORDER BY pos';
            -- TODO: add relation to the conditional, to reduce load ?
      FOR rec2 IN EXECUTE sql
      LOOP -- {

        IF edgeMapTable IS NOT NULL THEN
          sql := 'SELECT arc_id-1 FROM ' || edgeMapTable::text || ' WHERE edge_id = ' || rec2.edge_id;
          EXECUTE sql INTO arcid;
          IF arcid IS NULL THEN
            EXECUTE 'INSERT INTO ' || edgeMapTable::text
              || '(edge_id) VALUES (' || rec2.edge_id || ') RETURNING arc_id-1'
            INTO arcid;
          END IF;
        ELSE
          arcid := rec2.edge_id;
        END IF;

        -- edge goes in opposite direction
        IF rec2.pos2 < rec2.pos THEN
          arcid := -(arcid+1);
        END IF;

        arcs := arcs || arcid;

      END LOOP; -- }

      comptxt := comptxt || ( '[' || array_to_string(arcs, ',') || ']' );
      arcs := NULL;

    END LOOP; -- }

    json := '{ "type": "MultiLineString", "arcs": [' || array_to_string(comptxt,',') || ']}';

    return json;

  ELSIF tg.type = 3 THEN -- areal

    json := '{ "type": "MultiPolygon", "arcs": [';

    EXECUTE 'SHOW search_path' INTO old_search_path;
    EXECUTE 'SET search_path TO ' || quote_ident(toponame) || ',' || old_search_path;

    SELECT array_agg(id) as f
    FROM ( SELECT (topology.GetTopoGeomElements(tg))[1] as id ) as f
    INTO all_faces;


    visited_edges := ARRAY[]::int[];
    faces := all_faces;
    looking_for_holes := false;
    shell_faces := ARRAY[]::int[];

    LOOP -- {

      arcs := NULL;
      edges_found := false;


      FOR rec in -- {
WITH RECURSIVE
_edges AS (
  SELECT e.*, 
         e.left_face = ANY ( faces ) as lf,
         e.right_face = ANY ( faces ) as rf
  FROM edge e
  WHERE ( e.left_face = ANY ( faces ) OR
          e.right_face = ANY ( faces ) )
),
_leftmost_non_dangling_edge AS (
  SELECT * FROM _edges e
    WHERE ( e.lf or e.rf ) AND ( e.lf != e.rf )
          AND NOT e.edge_id = ANY ( visited_edges )
      -- TODO: and not in visited ?
  ORDER BY geom LIMIT 1
),
_edgepath AS (
  SELECT
    CASE
      WHEN e.lf THEN lme.edge_id
      ELSE -lme.edge_id
    END as signed_edge_id,
    false as back,

    e.lf = e.rf as dangling,
    e.left_face, e.right_face,
    e.lf, e.rf,
    e.next_right_edge, e.next_left_edge

  FROM _edges e, _leftmost_non_dangling_edge lme
  WHERE e.edge_id = abs(lme.edge_id)
    UNION
  SELECT
    CASE
      WHEN p.dangling AND NOT p.back THEN -p.signed_edge_id
      WHEN p.signed_edge_id < 0 THEN p.next_right_edge
      ELSE p.next_left_edge
    END, -- signed_edge_id
    CASE
      WHEN p.dangling AND NOT p.back THEN true
      ELSE false
    END, -- back

    e.lf = e.rf, -- dangling
    e.left_face, e.right_face,
    e.lf, e.rf,
    e.next_right_edge, e.next_left_edge

  FROM _edges e, _edgepath p
  WHERE
    e.edge_id = CASE
      WHEN p.dangling AND NOT p.back THEN abs(p.signed_edge_id)
      WHEN p.signed_edge_id < 0 THEN abs(p.next_right_edge)
      ELSE abs(p.next_left_edge)
    END
)
SELECT abs(signed_edge_id) as edge_id, signed_edge_id, dangling,
        lf, rf, left_face, right_face
FROM _edgepath
      LOOP  -- }{



        IF rec.left_face = ANY (all_faces) AND NOT rec.left_face = ANY (shell_faces) THEN
          shell_faces := shell_faces || rec.left_face;
        END IF;

        IF rec.right_face = ANY (all_faces) AND NOT rec.right_face = ANY (shell_faces) THEN
          shell_faces := shell_faces || rec.right_face;
        END IF;

        visited_edges := visited_edges || rec.edge_id;

        edges_found := true;

        -- TODO: drop ?
        IF rec.dangling THEN
          CONTINUE;
        END IF;

        IF rec.left_face = ANY (all_faces) AND rec.right_face = ANY (all_faces) THEN
          CONTINUE;
        END IF;

        IF edgeMapTable IS NOT NULL THEN
          sql := 'SELECT arc_id-1 FROM ' || edgeMapTable::text || ' WHERE edge_id = ' || rec.edge_id;
          EXECUTE sql INTO arcid;
          IF arcid IS NULL THEN
            EXECUTE 'INSERT INTO ' || edgeMapTable::text
              || '(edge_id) VALUES (' || rec.edge_id || ') RETURNING arc_id-1'
            INTO arcid;
          END IF;
        ELSE
          arcid := rec.edge_id-1;
        END IF;

        -- Swap sign, use two's complement for negative edges
        IF rec.signed_edge_id >= 0 THEN
          arcid := - ( arcid + 1 );
        END IF;


        arcs := arcid || arcs;

      END LOOP; -- }


      IF NOT edges_found THEN
        IF looking_for_holes THEN
          looking_for_holes := false;
          comptxt := comptxt || ( '[' || array_to_string(ringtxt, ',') || ']' );
          ringtxt := NULL;
          faces := all_faces;
          shell_faces := ARRAY[]::int[];
        ELSE
          EXIT; -- end of loop
        END IF;
      ELSE
        faces := shell_faces;
        IF arcs IS NOT NULL THEN
          ringtxt := ringtxt || ( '[' || array_to_string(arcs,',') || ']' );
        END IF;
        looking_for_holes := true;
      END IF;

    END LOOP; -- }

    json := json || array_to_string(comptxt, ',') || ']}';

    EXECUTE 'SET search_path TO ' || old_search_path;


  ELSIF tg.type = 4 THEN -- collection
    RAISE EXCEPTION 'Collection TopoGeometries are not supported by AsTopoJSON';

  END IF;
	
  RETURN json;
	
END
$$;


ALTER FUNCTION topology.astopojson(tg topogeometry, edgemaptable regclass) OWNER TO postgres;

--
-- TOC entry 1440 (class 1255 OID 31169)
-- Name: cleartopogeom(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION cleartopogeom(tg topogeometry) RETURNS topogeometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  topology_info RECORD;
  sql TEXT;
BEGIN

  -- Get topology information
  SELECT id, name FROM topology.topology
    INTO topology_info
    WHERE id = topology_id(tg);
  IF NOT FOUND THEN
      RAISE EXCEPTION 'No topology with id "%" in topology.topology', topology_id(tg);
  END IF;

  -- Clear the TopoGeometry contents
  sql := 'DELETE FROM ' || quote_ident(topology_info.name)
        || '.relation WHERE layer_id = '
        || layer_id(tg)
        || ' AND topogeo_id = '
        || id(tg);
  EXECUTE sql;


  RETURN tg;

END
$$;


ALTER FUNCTION topology.cleartopogeom(tg topogeometry) OWNER TO postgres;

--
-- TOC entry 1418 (class 1255 OID 31145)
-- Name: copytopology(character varying, character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION copytopology(atopology character varying, newtopo character varying) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  rec RECORD;
  rec2 RECORD;
  oldtopo_id integer;
  newtopo_id integer;
  n int4;
  ret text;
BEGIN

  SELECT * FROM topology.topology where name = atopology
  INTO strict rec;
  oldtopo_id = rec.id;
  -- TODO: more gracefully handle unexistent topology

  SELECT topology.CreateTopology(newtopo, rec.SRID, rec.precision, rec.hasZ)
  INTO strict newtopo_id;

  -- Copy faces
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.face SELECT * FROM ' || quote_ident(atopology)
    || '.face WHERE face_id != 0';
  -- Update faces sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.face_face_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.face_face_id_seq))';

  -- Copy nodes
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.node SELECT * FROM ' || quote_ident(atopology)
    || '.node';
  -- Update node sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.node_node_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.node_node_id_seq))';

  -- Copy edges
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.edge_data SELECT * FROM ' || quote_ident(atopology)
    || '.edge_data';
  -- Update edge sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.edge_data_edge_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.edge_data_edge_id_seq))';

  -- Copy layers and their TopoGeometry sequences 
  FOR rec IN SELECT * FROM topology.layer WHERE topology_id = oldtopo_id
  LOOP
    INSERT INTO topology.layer (topology_id, layer_id, feature_type,
      level, child_id, schema_name, table_name, feature_column) 
      VALUES (newtopo_id, rec.layer_id, rec.feature_type,
              rec.level, rec.child_id, newtopo,
              'LAYER' ||  rec.layer_id, '');
    -- Create layer's TopoGeometry sequences
    EXECUTE 'SELECT last_value FROM ' 
      || quote_ident(atopology) || '.topogeo_s_' || rec.layer_id 
      INTO STRICT n;
    EXECUTE 'CREATE SEQUENCE ' || quote_ident(newtopo)
      || '.topogeo_s_' || rec.layer_id;
    EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.topogeo_s_' || rec.layer_id
      ) || ', ' || n || ')';
  END LOOP;

  -- Copy TopoGeometry definitions
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.relation SELECT * FROM ' || quote_ident(atopology)
    || '.relation';

  RETURN newtopo_id;
END
$$;


ALTER FUNCTION topology.copytopology(atopology character varying, newtopo character varying) OWNER TO postgres;

--
-- TOC entry 1404 (class 1255 OID 31126)
-- Name: createtopogeom(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer) RETURNS topogeometry
    LANGUAGE sql STRICT
    AS $_$
  SELECT topology.CreateTopoGeom($1,$2,$3,'{{0,0}}');
$_$;


ALTER FUNCTION topology.createtopogeom(toponame character varying, tg_type integer, layer_id integer) OWNER TO postgres;

--
-- TOC entry 1403 (class 1255 OID 31125)
-- Name: createtopogeom(character varying, integer, integer, topoelementarray); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer, tg_objs topoelementarray) RETURNS topogeometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  i integer;
  dims varchar;
  outerdims varchar;
  innerdims varchar;
  obj_type integer;
  obj_id integer;
  ret topology.TopoGeometry;
  rec RECORD;
  layertype integer;
  layerlevel integer;
  layerchild integer;
BEGIN

  IF tg_type < 1 OR tg_type > 4 THEN
    RAISE EXCEPTION 'Invalid TopoGeometry type % (must be in the range 1..4)', tg_type;
  END IF;

  -- Get topology id into return TopoGeometry
  SELECT id FROM topology.topology into ret.topology_id
    WHERE name = toponame;

  --
  -- Get layer info
  --
  layertype := NULL;
  FOR rec IN EXECUTE 'SELECT * FROM topology.layer'
    || ' WHERE topology_id = ' || ret.topology_id
    || ' AND layer_id = ' || layer_id
  LOOP
    layertype = rec.feature_type;
    layerlevel = rec.level;
    layerchild = rec.child_id;
  END LOOP;

  -- Check for existence of given layer id
  IF layertype IS NULL THEN
    RAISE EXCEPTION 'No layer with id % is registered with topology %', layer_id, toponame;
  END IF;

  -- Verify compatibility between layer geometry type and
  -- TopoGeom requested geometry type
  IF layertype != 4 and layertype != tg_type THEN
    RAISE EXCEPTION 'A Layer of type % cannot contain a TopoGeometry of type %', layertype, tg_type;
  END IF;

  -- Set layer id and type in return object
  ret.layer_id = layer_id;
  ret.type = tg_type;

  --
  -- Get new TopoGeo id from sequence
  --
  FOR rec IN EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(toponame) || '.topogeo_s_' || layer_id
    ) || ')'
  LOOP
    ret.id = rec.nextval;
  END LOOP;

  -- Loop over outer dimension
  i = array_lower(tg_objs, 1);
  LOOP
    obj_id = tg_objs[i][1];
    obj_type = tg_objs[i][2];

    -- Elements of type 0 represent emptiness, just skip them
    IF obj_type = 0 THEN
      IF obj_id != 0 THEN
        RAISE EXCEPTION 'Malformed empty topo element {0,%} -- id must be 0 as well', obj_id;
      END IF;
    ELSE
      IF layerlevel = 0 THEN -- array specifies lower-level objects
        IF tg_type != 4 and tg_type != obj_type THEN
          RAISE EXCEPTION 'A TopoGeometry of type % cannot contain topology elements of type %', tg_type, obj_type;
        END IF;
      ELSE -- array specifies lower-level topogeometries
        IF obj_type != layerchild THEN
          RAISE EXCEPTION 'TopoGeom element layer do not match TopoGeom child layer';
        END IF;
        -- TODO: verify that the referred TopoGeometry really
        -- exists in the relation table ?
      END IF;

      --RAISE NOTICE 'obj:% type:% id:%', i, obj_type, obj_id;

      --
      -- Insert record into the Relation table
      --
      EXECUTE 'INSERT INTO '||quote_ident(toponame)
        || '.relation(topogeo_id, layer_id, '
        || 'element_id,element_type) '
        || ' VALUES ('||ret.id
        ||','||ret.layer_id
        || ',' || obj_id || ',' || obj_type || ');';
    END IF;

    i = i+1;
    IF i > array_upper(tg_objs, 1) THEN
      EXIT;
    END IF;
  END LOOP;

  RETURN ret;

END
$$;


ALTER FUNCTION topology.createtopogeom(toponame character varying, tg_type integer, layer_id integer, tg_objs topoelementarray) OWNER TO postgres;

--
-- TOC entry 1414 (class 1255 OID 31142)
-- Name: createtopology(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION createtopology(character varying) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT topology.CreateTopology($1, ST_SRID('POINT EMPTY'::geometry), 0); $_$;


ALTER FUNCTION topology.createtopology(character varying) OWNER TO postgres;

--
-- TOC entry 1413 (class 1255 OID 31141)
-- Name: createtopology(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION createtopology(character varying, integer) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT topology.CreateTopology($1, $2, 0); $_$;


ALTER FUNCTION topology.createtopology(character varying, integer) OWNER TO postgres;

--
-- TOC entry 1412 (class 1255 OID 31140)
-- Name: createtopology(character varying, integer, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION createtopology(toponame character varying, srid integer, prec double precision) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT topology.CreateTopology($1, $2, $3, false);$_$;


ALTER FUNCTION topology.createtopology(toponame character varying, srid integer, prec double precision) OWNER TO postgres;

--
-- TOC entry 1411 (class 1255 OID 31138)
-- Name: createtopology(character varying, integer, double precision, boolean); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION createtopology(atopology character varying, srid integer, prec double precision, hasz boolean) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  rec RECORD;
  topology_id integer;
  ndims integer;
BEGIN

--  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
--  LOOP
--    RAISE EXCEPTION 'SQL/MM Spatial exception - schema already exists';
--  END LOOP;

  ndims = 2;
  IF hasZ THEN ndims = 3; END IF;

  ------ Fetch next id for the new topology
  FOR rec IN SELECT nextval('topology.topology_id_seq')
  LOOP
    topology_id = rec.nextval;
  END LOOP;


  EXECUTE 'CREATE SCHEMA ' || quote_ident(atopology);

  -------------{ face CREATION
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.face ('
  || 'face_id SERIAL,'
  || ' CONSTRAINT face_primary_key PRIMARY KEY(face_id)'
  || ');';

  -- Add mbr column to the face table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''face'',''mbr'','||quote_literal(srid)
  ||',''POLYGON'',2)'; -- 2d only mbr is good enough

  -------------} END OF face CREATION


  --------------{ node CREATION

  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.node ('
  || 'node_id SERIAL,'
  --|| 'geom GEOMETRY,'
  || 'containing_face INTEGER,'

  || 'CONSTRAINT node_primary_key PRIMARY KEY(node_id),'

  --|| 'CONSTRAINT node_geometry_type CHECK '
  --|| '( GeometryType(geom) = ''POINT'' ),'

  || 'CONSTRAINT face_exists FOREIGN KEY(containing_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id)'

  || ');';

  -- Add geometry column to the node table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''node'',''geom'','||quote_literal(srid)
  ||',''POINT'',' || ndims || ')';

  --------------} END OF node CREATION

  --------------{ edge CREATION

  -- edge_data table
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.edge_data ('
  || 'edge_id SERIAL NOT NULL PRIMARY KEY,'
  || 'start_node INTEGER NOT NULL,'
  || 'end_node INTEGER NOT NULL,'
  || 'next_left_edge INTEGER NOT NULL,'
  || 'abs_next_left_edge INTEGER NOT NULL,'
  || 'next_right_edge INTEGER NOT NULL,'
  || 'abs_next_right_edge INTEGER NOT NULL,'
  || 'left_face INTEGER NOT NULL,'
  || 'right_face INTEGER NOT NULL,'
  --|| 'geom GEOMETRY NOT NULL,'

  --|| 'CONSTRAINT edge_geometry_type CHECK '
  --|| '( GeometryType(geom) = ''LINESTRING'' ),'

  || 'CONSTRAINT start_node_exists FOREIGN KEY(start_node)'
  || ' REFERENCES ' || quote_ident(atopology) || '.node(node_id),'

  || 'CONSTRAINT end_node_exists FOREIGN KEY(end_node) '
  || ' REFERENCES ' || quote_ident(atopology) || '.node(node_id),'

  || 'CONSTRAINT left_face_exists FOREIGN KEY(left_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id),'

  || 'CONSTRAINT right_face_exists FOREIGN KEY(right_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id),'

  || 'CONSTRAINT next_left_edge_exists FOREIGN KEY(abs_next_left_edge)'
  || ' REFERENCES ' || quote_ident(atopology)
  || '.edge_data(edge_id)'
  || ' DEFERRABLE INITIALLY DEFERRED,'

  || 'CONSTRAINT next_right_edge_exists '
  || 'FOREIGN KEY(abs_next_right_edge)'
  || ' REFERENCES ' || quote_ident(atopology)
  || '.edge_data(edge_id) '
  || ' DEFERRABLE INITIALLY DEFERRED'
  || ');';

  -- Add geometry column to the edge_data table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''edge_data'',''geom'','||quote_literal(srid)
  ||',''LINESTRING'',' || ndims || ')';


  -- edge standard view (select rule)
  EXECUTE 'CREATE VIEW ' || quote_ident(atopology)
    || '.edge AS SELECT '
    || ' edge_id, start_node, end_node, next_left_edge, '
    || ' next_right_edge, '
    || ' left_face, right_face, geom FROM '
    || quote_ident(atopology) || '.edge_data';

  -- edge standard view description
  EXECUTE 'COMMENT ON VIEW ' || quote_ident(atopology)
    || '.edge IS '
    || '''Contains edge topology primitives''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.edge_id IS '
    || '''Unique identifier of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.start_node IS '
    || '''Unique identifier of the node at the start of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.end_node IS '
    || '''Unique identifier of the node at the end of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.next_left_edge IS '
    || '''Unique identifier of the next edge of the face on the left (when looking in the direction from START_NODE to END_NODE), moving counterclockwise around the face boundary''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.next_right_edge IS '
    || '''Unique identifier of the next edge of the face on the right (when looking in the direction from START_NODE to END_NODE), moving counterclockwise around the face boundary''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.left_face IS '
    || '''Unique identifier of the face on the left side of the edge when looking in the direction from START_NODE to END_NODE''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.right_face IS '
    || '''Unique identifier of the face on the right side of the edge when looking in the direction from START_NODE to END_NODE''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.geom IS '
    || '''The geometry of the edge''';

  -- edge standard view (insert rule)
  EXECUTE 'CREATE RULE edge_insert_rule AS ON INSERT '
          || 'TO ' || quote_ident(atopology)
    || '.edge DO INSTEAD '
                || ' INSERT into ' || quote_ident(atopology)
    || '.edge_data '
                || ' VALUES (NEW.edge_id, NEW.start_node, NEW.end_node, '
    || ' NEW.next_left_edge, abs(NEW.next_left_edge), '
    || ' NEW.next_right_edge, abs(NEW.next_right_edge), '
    || ' NEW.left_face, NEW.right_face, NEW.geom);';

  --------------} END OF edge CREATION

  --------------{ layer sequence 
  EXECUTE 'CREATE SEQUENCE '
    || quote_ident(atopology) || '.layer_id_seq;';
  --------------} layer sequence

  --------------{ relation CREATION
  --
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.relation ('
  || ' topogeo_id integer NOT NULL, '
  || ' layer_id integer NOT NULL, ' 
  || ' element_id integer NOT NULL, '
  || ' element_type integer NOT NULL, '
  || ' UNIQUE(layer_id,topogeo_id,element_id,element_type));';

  EXECUTE 
  'CREATE TRIGGER relation_integrity_checks '
  ||'BEFORE UPDATE OR INSERT ON '
  || quote_ident(atopology) || '.relation FOR EACH ROW '
  || ' EXECUTE PROCEDURE topology.RelationTrigger('
  ||topology_id||','||quote_literal(atopology)||')';
  --------------} END OF relation CREATION

  
  ------- Default (world) face
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) || '.face(face_id) VALUES(0);';

  ------- GiST index on face
  EXECUTE 'CREATE INDEX face_gist ON '
    || quote_ident(atopology)
    || '.face using gist (mbr);';

  ------- GiST index on node
  EXECUTE 'CREATE INDEX node_gist ON '
    || quote_ident(atopology)
    || '.node using gist (geom);';

  ------- GiST index on edge
  EXECUTE 'CREATE INDEX edge_gist ON '
    || quote_ident(atopology)
    || '.edge_data using gist (geom);';

  ------- Indexes on left_face and right_face of edge_data
  ------- NOTE: these indexes speed up GetFaceGeometry (and thus
  -------       TopoGeometry::Geometry) by a factor of 10 !
  -------       See http://trac.osgeo.org/postgis/ticket/806
  EXECUTE 'CREATE INDEX edge_left_face_idx ON '
    || quote_ident(atopology)
    || '.edge_data (left_face);';
  EXECUTE 'CREATE INDEX edge_right_face_idx ON '
    || quote_ident(atopology)
    || '.edge_data (right_face);';

  ------- Indexes on start_node and end_node of edge_data
  ------- NOTE: this indexes speed up node deletion
  -------       by a factor of 1000 !
  -------       See http://trac.osgeo.org/postgis/ticket/2082
  EXECUTE 'CREATE INDEX edge_start_node_idx ON '
    || quote_ident(atopology)
    || '.edge_data (start_node);';
  EXECUTE 'CREATE INDEX edge_end_node_idx ON '
    || quote_ident(atopology)
    || '.edge_data (end_node);';

  -- TODO: consider also adding an index on node.containing_face 

  ------- Add record to the "topology" metadata table
  EXECUTE 'INSERT INTO topology.topology '
    || '(id, name, srid, precision, hasZ) VALUES ('
    || quote_literal(topology_id) || ','
    || quote_literal(atopology) || ','
    || quote_literal(srid) || ',' || quote_literal(prec)
    || ',' || hasZ
    || ')';

  RETURN topology_id;
END
$$;


ALTER FUNCTION topology.createtopology(atopology character varying, srid integer, prec double precision, hasz boolean) OWNER TO postgres;

--
-- TOC entry 1402 (class 1255 OID 31124)
-- Name: droptopogeometrycolumn(character varying, character varying, character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION droptopogeometrycolumn(schema character varying, tbl character varying, col character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  lyrinfo RECORD;
  ok BOOL;
  result text;
BEGIN

        -- Get layer and topology info
  ok = false;
  FOR rec IN EXECUTE 'SELECT t.name as toponame, l.* FROM '
    || 'topology.topology t, topology.layer l '
    || ' WHERE l.topology_id = t.id'
    || ' AND l.schema_name = ' || quote_literal(schema)
    || ' AND l.table_name = ' || quote_literal(tbl)
    || ' AND l.feature_column = ' || quote_literal(col)
  LOOP
    ok = true;
    lyrinfo = rec;
  END LOOP;

  -- Layer not found
  IF NOT ok THEN
    RAISE EXCEPTION 'No layer registered on %.%.%',
      schema,tbl,col;
  END IF;
    
  -- Clean up the topology schema
  BEGIN
    -- Cleanup the relation table
    EXECUTE 'DELETE FROM ' || quote_ident(lyrinfo.toponame)
      || '.relation '
      || ' WHERE '
      || 'layer_id = ' || lyrinfo.layer_id;

    -- Drop the sequence for topogeoms in this layer
    EXECUTE 'DROP SEQUENCE ' || quote_ident(lyrinfo.toponame)
      || '.topogeo_s_' || lyrinfo.layer_id;
  EXCEPTION
    WHEN UNDEFINED_TABLE THEN
      RAISE NOTICE '%', SQLERRM;
    WHEN OTHERS THEN
      RAISE EXCEPTION 'Got % (%)', SQLERRM, SQLSTATE;
  END;

  ok = false;
  FOR rec IN SELECT * FROM pg_namespace n, pg_class c, pg_attribute a
    WHERE text(n.nspname) = schema
    AND c.relnamespace = n.oid
    AND text(c.relname) = tbl
    AND a.attrelid = c.oid
    AND text(a.attname) = col
  LOOP
    ok = true;
    EXIT;
  END LOOP;


  IF ok THEN
    -- Set feature column to NULL to bypass referential integrity
    -- checks
    EXECUTE 'UPDATE ' || quote_ident(schema) || '.'
      || quote_ident(tbl)
      || ' SET ' || quote_ident(col)
      || ' = NULL';
  END IF;

  -- Delete the layer record
  EXECUTE 'DELETE FROM topology.layer '
    || ' WHERE topology_id = ' || lyrinfo.topology_id
    || ' AND layer_id = ' || lyrinfo.layer_id;

  IF ok THEN
    -- Drop the layer column
    EXECUTE 'ALTER TABLE ' || quote_ident(schema) || '.'
      || quote_ident(tbl)
      || ' DROP ' || quote_ident(col)
      || ' cascade';
  END IF;

  result = 'Layer ' || lyrinfo.layer_id || ' ('
    || schema || '.' || tbl || '.' || col
    || ') dropped';

  RETURN result;
END;
$$;


ALTER FUNCTION topology.droptopogeometrycolumn(schema character varying, tbl character varying, col character varying) OWNER TO postgres;

--
-- TOC entry 1415 (class 1255 OID 31143)
-- Name: droptopology(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION droptopology(atopology character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  topoid integer;
  rec RECORD;
BEGIN

  -- Get topology id
        SELECT id FROM topology.topology into topoid
                WHERE name = atopology;


  IF topoid IS NOT NULL THEN

    RAISE NOTICE 'Dropping all layers from topology % (%)',
      atopology, topoid;

    -- Drop all layers in the topology
    FOR rec IN EXECUTE 'SELECT * FROM topology.layer WHERE '
      || ' topology_id = ' || topoid
    LOOP

      EXECUTE 'SELECT topology.DropTopoGeometryColumn('
        || quote_literal(rec.schema_name)
        || ','
        || quote_literal(rec.table_name)
        || ','
        || quote_literal(rec.feature_column)
        || ')';
    END LOOP;

    -- Delete record from topology.topology
    EXECUTE 'DELETE FROM topology.topology WHERE id = '
      || topoid;

  END IF;


  -- Drop the schema (if it exists)
  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
  LOOP
    EXECUTE 'DROP SCHEMA '||quote_ident(atopology)||' CASCADE';
  END LOOP;

  RETURN 'Topology ' || quote_literal(atopology) || ' dropped';
END
$$;


ALTER FUNCTION topology.droptopology(atopology character varying) OWNER TO postgres;

--
-- TOC entry 1420 (class 1255 OID 31148)
-- Name: equals(topogeometry, topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION equals(tg1 topogeometry, tg2 topogeometry) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  rec RECORD;
  toponame varchar;
  query text;
BEGIN

  IF tg1.topology_id != tg2.topology_id THEN
    -- TODO: revert to ::geometry instead ?
    RAISE EXCEPTION 'Cannot compare TopoGeometries from different topologies';
  END IF;

  -- Not the same type, not equal
  IF tg1.type != tg2.type THEN
    RETURN FALSE;
  END IF;

  -- Geometry collection are not currently supported
  IF tg2.type = 4 THEN
    RAISE EXCEPTION 'GeometryCollection are not supported by equals()';
  END IF;

        -- Get topology name
        SELECT name FROM topology.topology into toponame
                WHERE id = tg1.topology_id;

  -- Two geometries are equal if they are composed by 
  -- the same TopoElements
  FOR rec IN EXECUTE 'SELECT * FROM '
    || ' topology.GetTopoGeomElements('
    || quote_literal(toponame) || ', '
    || tg1.layer_id || ',' || tg1.id || ') '
    || ' EXCEPT SELECT * FROM '
    || ' topology.GetTopogeomElements('
    || quote_literal(toponame) || ', '
    || tg2.layer_id || ',' || tg2.id || ');'
  LOOP
    RETURN FALSE;
  END LOOP;

  FOR rec IN EXECUTE 'SELECT * FROM '
    || ' topology.GetTopoGeomElements('
    || quote_literal(toponame) || ', '
    || tg2.layer_id || ',' || tg2.id || ')'
    || ' EXCEPT SELECT * FROM '
    || ' topology.GetTopogeomElements('
    || quote_literal(toponame) || ', '
    || tg1.layer_id || ',' || tg1.id || '); '
  LOOP
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END
$$;


ALTER FUNCTION topology.equals(tg1 topogeometry, tg2 topogeometry) OWNER TO postgres;

--
-- TOC entry 1409 (class 1255 OID 31134)
-- Name: geometry(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION geometry(topogeom topogeometry) RETURNS public.geometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  toponame varchar;
  geom geometry;
  rec RECORD;
  plyr RECORD;
  clyr RECORD;
  sql TEXT;
BEGIN

  -- Get topology name
  SELECT name FROM topology.topology
  WHERE id = topogeom.topology_id
  INTO toponame;
  IF toponame IS NULL THEN
    RAISE EXCEPTION 'Invalid TopoGeometry (unexistent topology id %)', topogeom.topology_id;
  END IF;

  -- Get layer info
  SELECT * FROM topology.layer
    WHERE topology_id = topogeom.topology_id
    AND layer_id = topogeom.layer_id
    INTO plyr;
  IF plyr IS NULL THEN
    RAISE EXCEPTION 'Could not find TopoGeometry layer % in topology %', topogeom.layer_id, topogeom.topology_id;
  END IF;

  --
  -- If this feature layer is on any level > 0 we will
  -- compute the topological union of all child features
  -- in fact recursing.
  --
  IF plyr.level > 0 THEN -- {

    -- Get child layer info
    SELECT * FROM topology.layer WHERE layer_id = plyr.child_id
      AND topology_id = topogeom.topology_id
      INTO clyr;
    IF clyr IS NULL THEN
      RAISE EXCEPTION 'Invalid layer % in topology % (unexistent child layer %)', topogeom.layer_id, topogeom.topology_id, plyr.child_id;
    END IF;

    sql := 'SELECT st_multi(st_union(topology.Geometry('
      || quote_ident(clyr.feature_column)
      || '))) as geom FROM '
      || quote_ident(clyr.schema_name) || '.'
      || quote_ident(clyr.table_name)
      || ', ' || quote_ident(toponame) || '.relation pr'
      || ' WHERE '
      || ' pr.topogeo_id = ' || topogeom.id
      || ' AND '
      || ' pr.layer_id = ' || topogeom.layer_id
      || ' AND '
      || ' id('||quote_ident(clyr.feature_column)
      || ') = pr.element_id '
      || ' AND '
      || 'layer_id('||quote_ident(clyr.feature_column)
      || ') = pr.element_type ';
    --RAISE DEBUG '%', query;
    EXECUTE sql INTO geom;
      
  ELSIF topogeom.type = 3 THEN -- [multi]polygon -- }{

    sql := 'SELECT st_multi(st_union('
      || 'topology.ST_GetFaceGeometry('
      || quote_literal(toponame) || ','
      || 'element_id))) as g FROM ' 
      || quote_ident(toponame)
      || '.relation WHERE topogeo_id = '
      || topogeom.id || ' AND layer_id = '
      || topogeom.layer_id || ' AND element_type = 3 ';
    EXECUTE sql INTO geom;

  ELSIF topogeom.type = 2 THEN -- [multi]line -- }{

    sql := 
      'SELECT st_multi(ST_LineMerge(ST_Collect(e.geom))) as g FROM '
      || quote_ident(toponame) || '.edge e, '
      || quote_ident(toponame) || '.relation r '
      || ' WHERE r.topogeo_id = ' || topogeom.id
      || ' AND r.layer_id = ' || topogeom.layer_id
      || ' AND r.element_type = 2 '
      || ' AND abs(r.element_id) = e.edge_id';
    EXECUTE sql INTO geom;
  
  ELSIF topogeom.type = 1 THEN -- [multi]point -- }{

    sql :=
      'SELECT st_multi(st_union(n.geom)) as g FROM '
      || quote_ident(toponame) || '.node n, '
      || quote_ident(toponame) || '.relation r '
      || ' WHERE r.topogeo_id = ' || topogeom.id
      || ' AND r.layer_id = ' || topogeom.layer_id
      || ' AND r.element_type = 1 '
      || ' AND r.element_id = n.node_id';
    EXECUTE sql INTO geom;

  ELSIF topogeom.type = 4 THEN -- mixed collection -- }{

    sql := 'WITH areas AS ( SELECT ST_Union('
      || 'topology.ST_GetFaceGeometry('
      || quote_literal(toponame) || ','
      || 'element_id)) as g FROM ' 
      || quote_ident(toponame)
      || '.relation WHERE topogeo_id = '
      || topogeom.id || ' AND layer_id = '
      || topogeom.layer_id || ' AND element_type = 3), '
      || 'lines AS ( SELECT ST_LineMerge(ST_Collect(e.geom)) as g FROM '
      || quote_ident(toponame) || '.edge e, '
      || quote_ident(toponame) || '.relation r '
      || ' WHERE r.topogeo_id = ' || topogeom.id
      || ' AND r.layer_id = ' || topogeom.layer_id
      || ' AND r.element_type = 2 '
      || ' AND abs(r.element_id) = e.edge_id ), '
      || ' points as ( SELECT st_union(n.geom) as g FROM '
      || quote_ident(toponame) || '.node n, '
      || quote_ident(toponame) || '.relation r '
      || ' WHERE r.topogeo_id = ' || topogeom.id
      || ' AND r.layer_id = ' || topogeom.layer_id
      || ' AND r.element_type = 1 '
      || ' AND r.element_id = n.node_id ), '
      || ' un as ( SELECT g FROM areas UNION ALL SELECT g FROM lines '
      || '          UNION ALL SELECT g FROM points ) '
      || 'SELECT ST_Multi(ST_Collect(g)) FROM un';
    EXECUTE sql INTO geom;

  ELSE -- }{

    RAISE EXCEPTION 'Invalid TopoGeometries (unknown type %)', topogeom.type;

  END IF; -- }

  IF geom IS NULL THEN
    IF topogeom.type = 3 THEN -- [multi]polygon
      geom := 'MULTIPOLYGON EMPTY';
    ELSIF topogeom.type = 2 THEN -- [multi]line
      geom := 'MULTILINESTRING EMPTY';
    ELSIF topogeom.type = 1 THEN -- [multi]point
      geom := 'MULTIPOINT EMPTY';
    ELSE
      geom := 'GEOMETRYCOLLECTION EMPTY';
    END IF;
  END IF;

  RETURN geom;
END
$$;


ALTER FUNCTION topology.geometry(topogeom topogeometry) OWNER TO postgres;

--
-- TOC entry 1438 (class 1255 OID 31167)
-- Name: geometrytype(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION geometrytype(tg topogeometry) RETURNS text
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT CASE
		WHEN type($1) = 1 THEN 'MULTIPOINT'
		WHEN type($1) = 2 THEN 'MULTILINESTRING'
		WHEN type($1) = 3 THEN 'MULTIPOLYGON'
		WHEN type($1) = 4 THEN 'GEOMETRYCOLLECTION'
		ELSE 'UNEXPECTED'
		END;
$_$;


ALTER FUNCTION topology.geometrytype(tg topogeometry) OWNER TO postgres;

--
-- TOC entry 1422 (class 1255 OID 31150)
-- Name: getedgebypoint(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION getedgebypoint(atopology character varying, apoint public.geometry, tol1 double precision) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
	sql text;
	idedge int;
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Tolerance must be >= 0
	--
	IF tol1 < 0
	THEN
		RAISE EXCEPTION 'Tolerance must be >=0';
	END IF;


    if tol1 = 0 then
    	sql := 'SELECT a.edge_id FROM ' 
        || quote_ident(atopology) 
        || '.edge_data as a WHERE '
        || '(a.geom && ' || quote_literal(apoint::text)||'::geometry) '
        || ' AND (ST_Intersects(a.geom,' || quote_literal(apoint::text)||'::geometry) );';
    else
    	sql := 'SELECT a.edge_id FROM ' 
        || quote_ident(atopology) 
        || '.edge_data as a WHERE '
        || '(ST_DWithin(a.geom,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ') );';
    end if;

    BEGIN
    EXECUTE sql INTO STRICT idedge;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            idedge = 0;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Two or more edges found';
    END;

	RETURN idedge;
	
END
$$;


ALTER FUNCTION topology.getedgebypoint(atopology character varying, apoint public.geometry, tol1 double precision) OWNER TO postgres;

--
-- TOC entry 1424 (class 1255 OID 31151)
-- Name: getfacebypoint(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION getfacebypoint(atopology character varying, apoint public.geometry, tol1 double precision) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
	sql text;
	idface int;
BEGIN

    idface := -1;

	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Tolerance must be >= 0
	--
	IF tol1 < 0
	THEN
		RAISE EXCEPTION 'Tolerance must be >=0';
	END IF;
    --
    -- first test is to check if there is inside an mbr
    --
    if tol1 = 0 then
    	sql := 'SELECT a.face_id FROM ' 
        || quote_ident(atopology) 
        || '.face as a WHERE '
        || '(a.mbr && ' || quote_literal(apoint::text)||'::geometry) '
        || 'LIMIT 1;';
    else
    	sql := 'SELECT a.face_id FROM ' 
        || quote_ident(atopology) 
        || '.face as a WHERE '
        || '(ST_DWithin(a.mbr,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ') ) '
        || 'LIMIT 1;';
    end if;

    BEGIN
    EXECUTE sql INTO STRICT idface;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            idface = 0;
    END;

    if idface > 0 then
        --
        -- probably there is something so now check the exact test
        --

    	if tol1 = 0 then
        	sql := 'SELECT e.face_id FROM ('
            || 'SELECT d.face_id,ST_BuildArea(ST_Union(geom)) as geom FROM ('
    		|| 'SELECT b.edge_id as edge_id,b.left_face as face_id,b.geom as geom FROM '
        	|| quote_ident(atopology) || '.edge_data as b,'
            || '(SELECT a.face_id FROM '
    		|| quote_ident(atopology) || '.face as a '
        	|| 'WHERE ST_Intersects(a.mbr,' || quote_literal(apoint::text)||'::geometry)=true'
            || ') as c '
    		|| 'WHERE (b.left_face = c.face_id) '
        	|| ' UNION ALL '
            || 'SELECT b.edge_id as edge_id, b.right_face as face_id, b.geom as geom FROM '
    		|| quote_ident(atopology) || '.edge_data as b,'
        	|| '(SELECT a.face_id FROM '
            || quote_ident(atopology) || '.face as a '
    		|| 'WHERE ST_Intersects(a.mbr,' || quote_literal(apoint::text)||'::geometry)=true'
        	|| ') as c '
            || 'WHERE (b.right_face = c.face_id) '
    		|| ') as d '
        	|| 'GROUP BY face_id '
            || ') as e '
    		|| 'WHERE ST_Intersects(e.geom, ' || quote_literal(apoint::text)||'::geometry)=true;';
        else
        	sql := 'SELECT e.face_id FROM ('
            || 'SELECT d.face_id,ST_BuildArea(ST_Union(geom)) as geom FROM ('
    		|| 'SELECT b.edge_id as edge_id,b.left_face as face_id,b.geom as geom FROM '
        	|| quote_ident(atopology) || '.edge_data as b,'
            || '(SELECT a.face_id FROM '
    		|| quote_ident(atopology) || '.face as a '
        	|| 'WHERE ST_DWithin(a.mbr,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ')=true'
            || ') as c '
    		|| 'WHERE (b.left_face = c.face_id) '
        	|| ' UNION ALL '
            || 'SELECT b.edge_id as edge_id, b.right_face as face_id, b.geom as geom FROM '
    		|| quote_ident(atopology) || '.edge_data as b,'
        	|| '(SELECT a.face_id FROM '
            || quote_ident(atopology) || '.face as a '
    		|| 'WHERE ST_DWithin(a.mbr,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ')=true'
        	|| ') as c '
            || 'WHERE (b.right_face = c.face_id) '
    		|| ') as d '
        	|| 'GROUP BY face_id '
            || ') as e '
    		|| 'WHERE ST_DWithin(e.geom, ' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ')=true;';
        end if;
	
    	RAISE DEBUG ' ==> %',sql;

        BEGIN
            EXECUTE sql INTO STRICT idface;
        	EXCEPTION
        	    WHEN NO_DATA_FOUND THEN
                    idface = 0;
                WHEN TOO_MANY_ROWS THEN
                    RAISE EXCEPTION 'Two or more faces found';
            END;

    end if;
    
    RETURN idface;
	
END
$$;


ALTER FUNCTION topology.getfacebypoint(atopology character varying, apoint public.geometry, tol1 double precision) OWNER TO postgres;

--
-- TOC entry 1421 (class 1255 OID 31149)
-- Name: getnodebypoint(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION getnodebypoint(atopology character varying, apoint public.geometry, tol1 double precision) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
	sql text;
	idnode int;
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Tolerance must be >= 0
	--
	IF tol1 < 0
	THEN
		RAISE EXCEPTION 'Tolerance must be >=0';
	END IF;


    if tol1 = 0 then
    	sql := 'SELECT a.node_id FROM ' 
        || quote_ident(atopology) 
        || '.node as a WHERE '
        || '(a.geom && ' || quote_literal(apoint::text)||'::geometry) '
        || ' AND (ST_Intersects(a.geom,' || quote_literal(apoint::text)||'::geometry) );';
    else
    	sql := 'SELECT a.node_id FROM ' 
        || quote_ident(atopology) 
        || '.node as a WHERE '
        || '(ST_DWithin(a.geom,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ') );';
    end if;

    BEGIN
    EXECUTE sql INTO STRICT idnode;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            idnode = 0;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Two or more nodes found';
    END;

	RETURN idnode;
	
END
$$;


ALTER FUNCTION topology.getnodebypoint(atopology character varying, apoint public.geometry, tol1 double precision) OWNER TO postgres;

--
-- TOC entry 1476 (class 1255 OID 31223)
-- Name: getnodeedges(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION getnodeedges(atopology character varying, anode integer) RETURNS SETOF getfaceedges_returntype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  curedge int;
  nextedge int;
  rec RECORD;
  retrec topology.GetFaceEdges_ReturnType;
  n int;
  sql text;
BEGIN

  n := 0;
  sql :=
    'WITH incident_edges AS ( SELECT edge_id, start_node, end_node, ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anode
    || ' or end_node = ' || anode
    || ') SELECT edge_id, ST_Azimuth(ST_StartPoint(geom), ST_PointN(geom, 2)) as az FROM  incident_edges WHERE start_node = ' || anode
    || ' UNION ALL SELECT -edge_id, ST_Azimuth(ST_EndPoint(geom), ST_PointN(geom, ST_NumPoints(geom)-1)) FROM incident_edges WHERE end_node = ' || anode
    || ' ORDER BY az';

  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    n := n + 1;
    retrec.sequence := n;
    retrec.edge := rec.edge_id;
    RETURN NEXT retrec;
  END LOOP; -- incident edges }

END
$$;


ALTER FUNCTION topology.getnodeedges(atopology character varying, anode integer) OWNER TO postgres;

--
-- TOC entry 1475 (class 1255 OID 31222)
-- Name: getringedges(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION getringedges(atopology character varying, anedge integer, maxedges integer DEFAULT NULL::integer) RETURNS SETOF getfaceedges_returntype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  rec RECORD;
  retrec topology.GetFaceEdges_ReturnType;
  n int;
  sql text;
BEGIN
  sql := 'WITH RECURSIVE edgering AS ( SELECT '
    || anedge
    || ' as signed_edge_id, edge_id, next_left_edge, next_right_edge FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE edge_id = '
    || abs(anedge)
    || ' UNION '
    || ' SELECT CASE WHEN p.signed_edge_id < 0 THEN p.next_right_edge '
    || ' ELSE p.next_left_edge END, e.edge_id, e.next_left_edge, e.next_right_edge '
    || ' FROM ' || quote_ident(atopology)
    || '.edge_data e, edgering p WHERE e.edge_id = CASE WHEN p.signed_edge_id < 0 '
    || 'THEN abs(p.next_right_edge) ELSE abs(p.next_left_edge) END ) SELECT * FROM edgering';

  n := 1;
  FOR rec IN EXECUTE sql
  LOOP
    retrec.sequence := n;
    retrec.edge := rec.signed_edge_id;
    RETURN NEXT retrec;

    n := n + 1;

    IF n > maxedges THEN
      RAISE EXCEPTION 'Max traversing limit hit: %', maxedges;
    END IF;
  END LOOP;

END
$$;


ALTER FUNCTION topology.getringedges(atopology character varying, anedge integer, maxedges integer) OWNER TO postgres;

--
-- TOC entry 1406 (class 1255 OID 31131)
-- Name: gettopogeomelementarray(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopogeomelementarray(tg topogeometry) RETURNS topoelementarray
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  toponame varchar;
BEGIN
  toponame = topology.GetTopologyName(tg.topology_id);
  RETURN topology.GetTopoGeomElementArray(toponame, tg.layer_id, tg.id);
END;
$$;


ALTER FUNCTION topology.gettopogeomelementarray(tg topogeometry) OWNER TO postgres;

--
-- TOC entry 1405 (class 1255 OID 31130)
-- Name: gettopogeomelementarray(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopogeomelementarray(toponame character varying, layer_id integer, tgid integer) RETURNS topoelementarray
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  rec RECORD;
  tg_objs varchar := '{';
  i integer;
  query text;
BEGIN

  query = 'SELECT * FROM topology.GetTopoGeomElements('
    || quote_literal(toponame) || ','
    || quote_literal(layer_id) || ','
    || quote_literal(tgid)
    || ') as obj ORDER BY obj';


  -- TODO: why not using array_agg here ?

  i = 1;
  FOR rec IN EXECUTE query
  LOOP
    IF i > 1 THEN
      tg_objs = tg_objs || ',';
    END IF;
    tg_objs = tg_objs || '{'
      || rec.obj[1] || ',' || rec.obj[2]
      || '}';
    i = i+1;
  END LOOP;

  tg_objs = tg_objs || '}';

  RETURN tg_objs;
END;
$$;


ALTER FUNCTION topology.gettopogeomelementarray(toponame character varying, layer_id integer, tgid integer) OWNER TO postgres;

--
-- TOC entry 1408 (class 1255 OID 31133)
-- Name: gettopogeomelements(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopogeomelements(tg topogeometry) RETURNS SETOF topoelement
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  toponame varchar;
  rec RECORD;
BEGIN
  toponame = topology.GetTopologyName(tg.topology_id);
  FOR rec IN SELECT * FROM topology.GetTopoGeomElements(toponame,
    tg.layer_id,tg.id) as ret
  LOOP
    RETURN NEXT rec.ret;
  END LOOP;
  RETURN;
END;
$$;


ALTER FUNCTION topology.gettopogeomelements(tg topogeometry) OWNER TO postgres;

--
-- TOC entry 1407 (class 1255 OID 31132)
-- Name: gettopogeomelements(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopogeomelements(toponame character varying, layerid integer, tgid integer) RETURNS SETOF topoelement
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  ret topology.TopoElement;
  rec RECORD;
  rec2 RECORD;
  query text;
  query2 text;
  lyr RECORD;
  ok bool;
BEGIN

  -- Get layer info
  ok = false;
  FOR rec IN EXECUTE 'SELECT * FROM '
    || ' topology.layer '
    || ' WHERE layer_id = ' || layerid
  LOOP
    lyr = rec;
    ok = true;
  END LOOP;

  IF NOT ok THEN
    RAISE EXCEPTION 'Layer % does not exist', layerid;
  END IF;


  query = 'SELECT abs(element_id) as element_id, element_type FROM '
    || quote_ident(toponame) || '.relation WHERE '
    || ' layer_id = ' || layerid
    || ' AND topogeo_id = ' || quote_literal(tgid)
    || ' ORDER BY element_type, element_id';

  --RAISE NOTICE 'Query: %', query;

  FOR rec IN EXECUTE query
  LOOP
    IF lyr.level > 0 THEN
      query2 = 'SELECT * from topology.GetTopoGeomElements('
        || quote_literal(toponame) || ','
        || rec.element_type
        || ','
        || rec.element_id
        || ') as ret;';
      --RAISE NOTICE 'Query2: %', query2;
      FOR rec2 IN EXECUTE query2
      LOOP
        RETURN NEXT rec2.ret;
      END LOOP;
    ELSE
      ret = '{' || rec.element_id || ',' || rec.element_type || '}';
      RETURN NEXT ret;
    END IF;
  
  END LOOP;

  RETURN;
END;
$$;


ALTER FUNCTION topology.gettopogeomelements(toponame character varying, layerid integer, tgid integer) OWNER TO postgres;

--
-- TOC entry 1396 (class 1255 OID 31128)
-- Name: gettopologyid(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopologyid(toponame character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  ret integer;
BEGIN
        SELECT id FROM topology.topology into ret
                WHERE name = toponame;
  RETURN ret;
END
$$;


ALTER FUNCTION topology.gettopologyid(toponame character varying) OWNER TO postgres;

--
-- TOC entry 1395 (class 1255 OID 31127)
-- Name: gettopologyname(integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopologyname(topoid integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  ret varchar;
BEGIN
        SELECT name FROM topology.topology into ret
                WHERE id = topoid;
  RETURN ret;
END
$$;


ALTER FUNCTION topology.gettopologyname(topoid integer) OWNER TO postgres;

--
-- TOC entry 1397 (class 1255 OID 31129)
-- Name: gettopologysrid(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION gettopologysrid(toponame character varying) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
  SELECT SRID FROM topology.topology WHERE name = $1;
$_$;


ALTER FUNCTION topology.gettopologysrid(toponame character varying) OWNER TO postgres;

--
-- TOC entry 1419 (class 1255 OID 31146)
-- Name: intersects(topogeometry, topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION intersects(tg1 topogeometry, tg2 topogeometry) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  tgbuf topology.TopoGeometry;
  rec RECORD;
  toponame varchar;
  query text;
BEGIN
  IF tg1.topology_id != tg2.topology_id THEN
    -- TODO: revert to ::geometry instead ?
    RAISE EXCEPTION 'Cannot compute intersection between TopoGeometries from different topologies';
  END IF;

  -- Order TopoGeometries so that tg1 has less-or-same
  -- dimensionality of tg1 (point,line,polygon,collection)
  IF tg1.type > tg2.type THEN
    tgbuf := tg2;
    tg2 := tg1;
    tg1 := tgbuf;
  END IF;

  --RAISE NOTICE 'tg1.id:% tg2.id:%', tg1.id, tg2.id;
  -- Geometry collection are not currently supported
  IF tg2.type = 4 THEN
    RAISE EXCEPTION 'GeometryCollection are not supported by intersects()';
  END IF;

        -- Get topology name
        SELECT name FROM topology.topology into toponame
                WHERE id = tg1.topology_id;

  -- Hierarchical TopoGeometries are not currently supported
  query = 'SELECT level FROM topology.layer'
    || ' WHERE '
    || ' topology_id = ' || tg1.topology_id
    || ' AND '
    || '( layer_id = ' || tg1.layer_id
    || ' OR layer_id = ' || tg2.layer_id
    || ' ) '
    || ' AND level > 0 ';

  --RAISE NOTICE '%', query;

  FOR rec IN EXECUTE query
  LOOP
    -- TODO: revert to ::geometry instead ?
    RAISE EXCEPTION 'Hierarchical TopoGeometries are not currently supported by intersects()';
  END LOOP;

  IF tg1.type = 1 THEN -- [multi]point


    IF tg2.type = 1 THEN -- point/point
  ---------------------------------------------------------
  -- 
  --  Two [multi]point features intersect if they share
  --  any Node 
  --
  --
  --
      query =
        'SELECT a.topogeo_id FROM '
        || quote_ident(toponame) ||
        '.relation a, '
        || quote_ident(toponame) ||
        '.relation b '
        || 'WHERE a.layer_id = ' || tg1.layer_id
        || ' AND b.layer_id = ' || tg2.layer_id
        || ' AND a.topogeo_id = ' || tg1.id
        || ' AND b.topogeo_id = ' || tg2.id
        || ' AND a.element_id = b.element_id '
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- they share an element
      END LOOP;
      RETURN FALSE; -- no elements shared
  --
  ---------------------------------------------------------
      

    ELSIF tg2.type = 2 THEN -- point/line
  ---------------------------------------------------------
  -- 
  --  A [multi]point intersects a [multi]line if they share
  --  any Node. 
  --
  --
  --
      query =
        'SELECT a.topogeo_id FROM '
        || quote_ident(toponame) ||
        '.relation a, '
        || quote_ident(toponame) ||
        '.relation b, '
        || quote_ident(toponame) ||
        '.edge_data e '
        || 'WHERE a.layer_id = ' || tg1.layer_id
        || ' AND b.layer_id = ' || tg2.layer_id
        || ' AND a.topogeo_id = ' || tg1.id
        || ' AND b.topogeo_id = ' || tg2.id
        || ' AND abs(b.element_id) = e.edge_id '
        || ' AND ( '
          || ' e.start_node = a.element_id '
          || ' OR '
          || ' e.end_node = a.element_id '
        || ' )'
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- they share an element
      END LOOP;
      RETURN FALSE; -- no elements shared
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 3 THEN -- point/polygon
  ---------------------------------------------------------
  -- 
  --  A [multi]point intersects a [multi]polygon if any
  --  Node of the point is contained in any face of the
  --  polygon OR ( is end_node or start_node of any edge
  --  of any polygon face ).
  --
  --  We assume the Node-in-Face check is faster becasue
  --  there will be less Faces then Edges in any polygon.
  --
  --
  --
  --
      -- Check if any node is contained in a face
      query =
        'SELECT n.node_id as id FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.node n '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id
        || ' AND n.node_id = r1.element_id '
        || ' AND r2.element_id = n.containing_face '
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        --RAISE NOTICE 'Node % in polygon face', rec.id;
        RETURN TRUE; -- one (or more) nodes are
                     -- contained in a polygon face
      END LOOP;

      -- Check if any node is start or end of any polygon
      -- face edge
      query =
        'SELECT n.node_id as nid, e.edge_id as eid '
        || ' FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e, '
        || quote_ident(toponame) ||
        '.node n '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id
        || ' AND n.node_id = r1.element_id '
        || ' AND ( '
        || ' e.left_face = r2.element_id '
        || ' OR '
        || ' e.right_face = r2.element_id '
        || ' ) '
        || ' AND ( '
        || ' e.start_node = r1.element_id '
        || ' OR '
        || ' e.end_node = r1.element_id '
        || ' ) '
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        --RAISE NOTICE 'Node % on edge % bound', rec.nid, rec.eid;
        RETURN TRUE; -- one node is start or end
                     -- of a face edge
      END LOOP;

      RETURN FALSE; -- no intersection
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 4 THEN -- point/collection
      RAISE EXCEPTION 'Intersection point/collection not implemented yet';

    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type %', tg2.type;
    END IF;

  ELSIF tg1.type = 2 THEN -- [multi]line
    IF tg2.type = 2 THEN -- line/line
  ---------------------------------------------------------
  -- 
  --  A [multi]line intersects a [multi]line if they share
  --  any Node. 
  --
  --
  --
      query =
        'SELECT e1.start_node FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e1, '
        || quote_ident(toponame) ||
        '.edge_data e2 '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id
        || ' AND abs(r1.element_id) = e1.edge_id '
        || ' AND abs(r2.element_id) = e2.edge_id '
        || ' AND ( '
        || ' e1.start_node = e2.start_node '
        || ' OR '
        || ' e1.start_node = e2.end_node '
        || ' OR '
        || ' e1.end_node = e2.start_node '
        || ' OR '
        || ' e1.end_node = e2.end_node '
        || ' )'
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- they share an element
      END LOOP;
      RETURN FALSE; -- no elements shared
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 3 THEN -- line/polygon
  ---------------------------------------------------------
  -- 
  -- A [multi]line intersects a [multi]polygon if they share
  -- any Node (touch-only case), or if any line edge has any
  -- polygon face on the left or right (full-containment case
  -- + edge crossing case).
  --
  --
      -- E1 are line edges, E2 are polygon edges
      -- R1 are line relations.
      -- R2 are polygon relations.
      -- R2.element_id are FACE ids
      query =
        'SELECT e1.edge_id'
        || ' FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e1, '
        || quote_ident(toponame) ||
        '.edge_data e2 '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id

        -- E1 are line edges
        || ' AND e1.edge_id = abs(r1.element_id) '

        -- E2 are face edges
        || ' AND ( e2.left_face = r2.element_id '
        || '   OR e2.right_face = r2.element_id ) '

        || ' AND ( '

        -- Check if E1 have left-or-right face 
        -- being part of R2.element_id
        || ' e1.left_face = r2.element_id '
        || ' OR '
        || ' e1.right_face = r2.element_id '

        -- Check if E1 share start-or-end node
        -- with any E2.
        || ' OR '
        || ' e1.start_node = e2.start_node '
        || ' OR '
        || ' e1.start_node = e2.end_node '
        || ' OR '
        || ' e1.end_node = e2.start_node '
        || ' OR '
        || ' e1.end_node = e2.end_node '

        || ' ) '

        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- either common node
                     -- or edge-in-face
      END LOOP;

      RETURN FALSE; -- no intersection
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 4 THEN -- line/collection
      RAISE EXCEPTION 'Intersection line/collection not implemented yet';

    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type %', tg2.type;
    END IF;


  ELSIF tg1.type = 3 THEN -- [multi]polygon

    IF tg2.type = 3 THEN -- polygon/polygon
  ---------------------------------------------------------
  -- 
  -- A [multi]polygon intersects a [multi]polygon if they share
  -- any Node (touch-only case), or if any face edge has any of the
  -- other polygon face on the left or right (full-containment case
  -- + edge crossing case).
  --
  --
      -- E1 are poly1 edges.
      -- E2 are poly2 edges
      -- R1 are poly1 relations.
      -- R2 are poly2 relations.
      -- R1.element_id are poly1 FACE ids
      -- R2.element_id are poly2 FACE ids
      query =
        'SELECT e1.edge_id'
        || ' FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e1, '
        || quote_ident(toponame) ||
        '.edge_data e2 '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id

        -- E1 are poly1 edges
        || ' AND ( e1.left_face = r1.element_id '
        || '   OR e1.right_face = r1.element_id ) '

        -- E2 are poly2 edges
        || ' AND ( e2.left_face = r2.element_id '
        || '   OR e2.right_face = r2.element_id ) '

        || ' AND ( '

        -- Check if any edge from a polygon face
        -- has any of the other polygon face
        -- on the left or right 
        || ' e1.left_face = r2.element_id '
        || ' OR '
        || ' e1.right_face = r2.element_id '
        || ' OR '
        || ' e2.left_face = r1.element_id '
        || ' OR '
        || ' e2.right_face = r1.element_id '

        -- Check if E1 share start-or-end node
        -- with any E2.
        || ' OR '
        || ' e1.start_node = e2.start_node '
        || ' OR '
        || ' e1.start_node = e2.end_node '
        || ' OR '
        || ' e1.end_node = e2.start_node '
        || ' OR '
        || ' e1.end_node = e2.end_node '

        || ' ) '

        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- either common node
                     -- or edge-in-face
      END LOOP;

      RETURN FALSE; -- no intersection
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 4 THEN -- polygon/collection
      RAISE EXCEPTION 'Intersection poly/collection not implemented yet';

    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type %', tg2.type;
    END IF;

  ELSIF tg1.type = 4 THEN -- collection
    IF tg2.type = 4 THEN -- collection/collection
      RAISE EXCEPTION 'Intersection collection/collection not implemented yet';
    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type %', tg2.type;
    END IF;

  ELSE
    RAISE EXCEPTION 'Invalid TopoGeometry type %', tg1.type;
  END IF;
END
$$;


ALTER FUNCTION topology.intersects(tg1 topogeometry, tg2 topogeometry) OWNER TO postgres;

--
-- TOC entry 1398 (class 1255 OID 31091)
-- Name: layertrigger(); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION layertrigger() RETURNS trigger
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  rec RECORD;
  ok BOOL;
  toponame varchar;
  query TEXT;
BEGIN

  --RAISE NOTICE 'LayerTrigger called % % at % level', TG_WHEN, TG_OP, TG_LEVEL;


  IF TG_OP = 'INSERT' THEN
    RAISE EXCEPTION 'LayerTrigger not meant to be called on INSERT';
  ELSIF TG_OP = 'UPDATE' THEN
    RAISE EXCEPTION 'The topology.layer table cannot be updated';
  END IF;


  -- Check for existance of any feature column referencing
  -- this layer
  FOR rec IN SELECT * FROM pg_namespace n, pg_class c, pg_attribute a
    WHERE text(n.nspname) = OLD.schema_name
    AND c.relnamespace = n.oid
    AND text(c.relname) = OLD.table_name
    AND a.attrelid = c.oid
    AND text(a.attname) = OLD.feature_column
  LOOP
    query = 'SELECT * '
      || ' FROM ' || quote_ident(OLD.schema_name)
      || '.' || quote_ident(OLD.table_name)
      || ' WHERE layer_id('
      || quote_ident(OLD.feature_column)||') '
      || '=' || OLD.layer_id
      || ' LIMIT 1';
    --RAISE NOTICE '%', query;
    FOR rec IN EXECUTE query
    LOOP
      RAISE NOTICE 'A feature referencing layer % of topology % still exists in %.%.%', OLD.layer_id, OLD.topology_id, OLD.schema_name, OLD.table_name, OLD.feature_column;
      RETURN NULL;
    END LOOP;
  END LOOP;


  -- Get topology name
  SELECT name FROM topology.topology INTO toponame
    WHERE id = OLD.topology_id;

  IF toponame IS NULL THEN
    RAISE NOTICE 'Could not find name of topology with id %',
      OLD.layer_id;
  END IF;

  -- Check if any record in the relation table references this layer
  FOR rec IN SELECT c.oid FROM pg_namespace n, pg_class c
    WHERE text(n.nspname) = toponame AND c.relnamespace = n.oid
          AND c.relname = 'relation'
  LOOP
    query = 'SELECT * '
      || ' FROM ' || quote_ident(toponame)
      || '.relation '
      || ' WHERE layer_id = '|| OLD.layer_id
      || ' LIMIT 1';
    --RAISE NOTICE '%', query;
    FOR rec IN EXECUTE query
    LOOP
      RAISE NOTICE 'A record in %.relation still references layer %', toponame, OLD.layer_id;
      RETURN NULL;
    END LOOP;
  END LOOP;

  RETURN OLD;
END;
$$;


ALTER FUNCTION topology.layertrigger() OWNER TO postgres;

--
-- TOC entry 1436 (class 1255 OID 31164)
-- Name: polygonize(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION polygonize(toponame character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  sql text;
  rec RECORD;
  faces int;
BEGIN

  sql := 'SELECT (st_dump(st_polygonize(geom))).geom from '
         || quote_ident(toponame) || '.edge_data';

  faces = 0;
  FOR rec in EXECUTE sql LOOP
    BEGIN
      PERFORM topology.AddFace(toponame, rec.geom);
      faces = faces + 1;
    EXCEPTION
      WHEN OTHERS THEN
        RAISE WARNING 'Error registering face % (%)', rec.geom, SQLERRM;
    END;
  END LOOP;
  RETURN faces || ' faces registered';
END
$$;


ALTER FUNCTION topology.polygonize(toponame character varying) OWNER TO postgres;

--
-- TOC entry 1478 (class 1255 OID 31225)
-- Name: postgis_topology_scripts_installed(); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION postgis_topology_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT '2.1.8'::text || ' r' || 13780::text AS version $$;


ALTER FUNCTION topology.postgis_topology_scripts_installed() OWNER TO postgres;

--
-- TOC entry 1399 (class 1255 OID 31121)
-- Name: relationtrigger(); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION relationtrigger() RETURNS trigger
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  toponame varchar;
  topoid integer;
  plyr RECORD; -- parent layer
  rec RECORD;
  ok BOOL;

BEGIN
  IF TG_NARGS != 2 THEN
    RAISE EXCEPTION 'RelationTrigger called with wrong number of arguments';
  END IF;

  topoid = TG_ARGV[0];
  toponame = TG_ARGV[1];

  --RAISE NOTICE 'RelationTrigger called % % on %.relation for a %', TG_WHEN, TG_OP, toponame, TG_LEVEL;


  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'RelationTrigger not meant to be called on DELETE';
  END IF;

  -- Get layer info (and verify it exists)
  ok = false;
  FOR plyr IN EXECUTE 'SELECT * FROM topology.layer '
    || 'WHERE '
    || ' topology_id = ' || topoid
    || ' AND'
    || ' layer_id = ' || NEW.layer_id
  LOOP
    ok = true;
    EXIT;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION 'Layer % does not exist in topology %',
      NEW.layer_id, topoid;
    RETURN NULL;
  END IF;

  IF plyr.level > 0 THEN -- this is hierarchical layer

    -- ElementType must be the layer child id
    IF NEW.element_type != plyr.child_id THEN
      RAISE EXCEPTION 'Type of elements in layer % must be set to its child layer id %', plyr.layer_id, plyr.child_id;
      RETURN NULL;
    END IF;

    -- ElementId must be an existent TopoGeometry in child layer
    ok = false;
    FOR rec IN EXECUTE 'SELECT topogeo_id FROM '
      || quote_ident(toponame) || '.relation '
      || ' WHERE layer_id = ' || plyr.child_id 
      || ' AND topogeo_id = ' || NEW.element_id
    LOOP
      ok = true;
      EXIT;
    END LOOP;
    IF NOT ok THEN
      RAISE EXCEPTION 'TopoGeometry % does not exist in the child layer %', NEW.element_id, plyr.child_id;
      RETURN NULL;
    END IF;

  ELSE -- this is a basic layer

    -- ElementType must be compatible with layer type
    IF plyr.feature_type != 4
      AND plyr.feature_type != NEW.element_type
    THEN
      RAISE EXCEPTION 'Element of type % is not compatible with layer of type %', NEW.element_type, plyr.feature_type;
      RETURN NULL;
    END IF;

    --
    -- Now lets see if the element is consistent, which
    -- is it exists in the topology tables.
    --

    --
    -- Element is a Node
    --
    IF NEW.element_type = 1 
    THEN
      ok = false;
      FOR rec IN EXECUTE 'SELECT node_id FROM '
        || quote_ident(toponame) || '.node '
        || ' WHERE node_id = ' || NEW.element_id
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Node % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;

    --
    -- Element is an Edge
    --
    ELSIF NEW.element_type = 2 
    THEN
      ok = false;
      FOR rec IN EXECUTE 'SELECT edge_id FROM '
        || quote_ident(toponame) || '.edge_data '
        || ' WHERE edge_id = ' || abs(NEW.element_id)
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Edge % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;

    --
    -- Element is a Face
    --
    ELSIF NEW.element_type = 3 
    THEN
      IF NEW.element_id = 0 THEN
        RAISE EXCEPTION 'Face % cannot be associated with any feature', NEW.element_id;
        RETURN NULL;
      END IF;
      ok = false;
      FOR rec IN EXECUTE 'SELECT face_id FROM '
        || quote_ident(toponame) || '.face '
        || ' WHERE face_id = ' || NEW.element_id
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Face % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;
    END IF;

  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION topology.relationtrigger() OWNER TO postgres;

--
-- TOC entry 1472 (class 1255 OID 31218)
-- Name: st_addedgemodface(character varying, integer, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_addedgemodface(atopology character varying, anode integer, anothernode integer, acurve public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  rrec RECORD;
  i INTEGER;
  topoid INTEGER;
  az FLOAT8;
  span RECORD; -- start point analysis data
  epan RECORD; --   end point analysis data
  fan RECORD; -- face analisys
  newedge RECORD; -- informations about new edge
  sql TEXT;
  newfaces INTEGER[];
  newface INTEGER;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL
    OR anode IS NULL
    OR anothernode IS NULL
    OR acurve IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid curve';
  END IF;
  
  --
  -- Curve must be simple
  --
  IF NOT ST_IsSimple(acurve) THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Get topology id
  --
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  -- Initialize new edge info (will be filled up more later)
  SELECT anode as start_node, anothernode as end_node, acurve as geom,
    NULL::int as next_left_edge, NULL::int as next_right_edge,
    NULL::int as left_face, NULL::int as right_face, NULL::int as edge_id,
    NULL::int as prev_left_edge, NULL::int as prev_right_edge, -- convenience
    anode = anothernode as isclosed, -- convenience
    false as start_node_isolated, -- convenience
    false as end_node_isolated, -- convenience
    NULL::geometry as start_node_geom, -- convenience
    NULL::geometry as end_node_geom, -- convenience
    ST_RemoveRepeatedPoints(acurve) as cleangeom -- convenience
  INTO newedge;

  -- Compute azimut of first edge end on start node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_StartPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom, 2)) AS myaz
  INTO span;
  IF span.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;

  -- Compute azimuth of last edge end on end node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_EndPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom,
                              ST_NumPoints(newedge.cleangeom)-1)) AS myaz
  INTO epan;
  IF epan.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;


  -- 
  -- Check endpoints existance, match with Curve geometry
  -- and get face information (if any)
  --
  i := 0;
  FOR rec IN EXECUTE 'SELECT node_id, containing_face, geom FROM '
    || quote_ident(atopology)
    || '.node WHERE node_id IN ( '
    || anode || ',' || anothernode
    || ')'
  LOOP
    IF rec.containing_face IS NOT NULL THEN
      IF newedge.left_face IS NULL THEN
        newedge.left_face := rec.containing_face;
        newedge.right_face := rec.containing_face;
      ELSE
        IF newedge.left_face != rec.containing_face THEN
          RAISE EXCEPTION
            'SQL/MM Spatial exception - geometry crosses an edge (endnodes in faces % and %)', newedge.left_face, rec.containing_face;
        END IF;
      END IF;
    END IF;

    IF rec.node_id = anode THEN
      newedge.start_node_geom = rec.geom;
    END IF;

    IF rec.node_id = anothernode THEN
      newedge.end_node_geom = rec.geom;
    END IF;

    i := i + 1;
  END LOOP;

  IF newedge.start_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT ST_Equals(newedge.start_node_geom, ST_StartPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  IF newedge.end_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT ST_Equals(newedge.end_node_geom, ST_EndPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - end node not geometry end point.';
  END IF;

  --
  -- Check if this geometry crosses any node
  --
  FOR rec IN EXECUTE
    'SELECT node_id, ST_Relate(geom, '
    || quote_literal(acurve::text) || '::geometry, 2) as relate FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(acurve::text)
    || '::geometry'
  LOOP
    IF ST_RelateMatch(rec.relate, 'T********') THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - geometry crosses a node';
    END IF;
  END LOOP;

  --
  -- Check if this geometry has any interaction with any existing edge
  --
  FOR rec IN EXECUTE 'SELECT edge_id, ST_Relate(geom,' 
    || quote_literal(acurve::text)
    || '::geometry, 2) as im FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE geom && '
    || quote_literal(acurve::text) || '::geometry'
  LOOP

    --RAISE DEBUG 'IM=%',rec.im;

    IF ST_RelateMatch(rec.im, 'F********') THEN
      CONTINUE; -- no interior intersection
    END IF;

    IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - coincident edge %', rec.edge_id;
    END IF;

    -- NOT IN THE SPECS: geometry touches an edge
    IF ST_RelateMatch(rec.im, '1********') THEN
      RAISE EXCEPTION
        'Spatial exception - geometry intersects edge %', rec.edge_id;
    END IF;

    IF ST_RelateMatch(rec.im, 'T********') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - geometry crosses edge %', rec.edge_id;
    END IF;

  END LOOP;

  ---------------------------------------------------------------
  --
  -- All checks passed, time to prepare the new edge
  --
  ---------------------------------------------------------------

  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(atopology) || '.edge_data_edge_id_seq') || ')'
  INTO STRICT newedge.edge_id;


  -- Find links on start node -- {


  sql :=
    'SELECT edge_id, -1 AS end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anode
    || ' UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || newedge.end_node
      || ',-1,0,0,' -- pretend we start elsewhere
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom), ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
                       ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;

    IF az IS NULL THEN
      RAISE EXCEPTION 'Invalid edge % found (no two distinct nodes exist)',
        rec.edge_id;
    END IF;


    az = az - span.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF span.maxaz IS NULL OR az > span.maxaz THEN
      span.maxaz := az;
      span.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF span.minaz IS NULL OR az < span.minaz THEN
      span.minaz := az;
      span.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', span.nextCW, span.minaz, span.nextCCW, span.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN span.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN span.was_isolated = true; END IF;
  END IF;

  IF span.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_right_edge := newedge.edge_id;
    newedge.prev_left_edge := -newedge.edge_id;
  ELSE
    newedge.next_right_edge := span.nextCW;
    newedge.prev_left_edge := -span.nextCCW;
  END IF;


  -- } start_node analysis


  -- Find links on end_node {
      

  sql :=
    'SELECT edge_id, -1 as end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anothernode
    || 'UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anothernode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || -1 -- pretend we end elsewhere
      || ',' || newedge.start_node || ',0,0,'
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anothernode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom),
                       ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
        ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;


    az := az - epan.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF epan.maxaz IS NULL OR az > epan.maxaz THEN
      epan.maxaz := az;
      epan.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF epan.minaz IS NULL OR az < epan.minaz THEN
      epan.minaz := az;
      epan.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', epan.nextCW, epan.minaz, epan.nextCCW, epan.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN epan.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN epan.was_isolated = true; END IF;
  END IF;

  IF epan.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_left_edge := -newedge.edge_id;
    newedge.prev_right_edge := newedge.edge_id;
  ELSE
    newedge.next_left_edge := epan.nextCW;
    newedge.prev_right_edge := -epan.nextCCW;
  END IF;

  -- } end_node analysis


  ----------------------------------------------------------------------
  --
  -- If we don't have faces setup by now we must have encountered
  -- a malformed topology (no containing_face on isolated nodes, no
  -- left/right faces on adjacent edges or mismatching values)
  --
  ----------------------------------------------------------------------
  IF newedge.left_face != newedge.right_face THEN
    RAISE EXCEPTION 'Left(%)/right(%) faces mismatch: invalid topology ?', 
      newedge.left_face, newedge.right_face;
  END IF;
  IF newedge.left_face IS NULL THEN
    RAISE EXCEPTION 'Could not derive edge face from linked primitives: invalid topology ?';
  END IF;

  ----------------------------------------------------------------------
  --
  -- Insert the new edge, and update all linking
  --
  ----------------------------------------------------------------------

  -- Insert the new edge with what we have so far
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) 
    || '.edge VALUES(' || newedge.edge_id
    || ',' || newedge.start_node
    || ',' || newedge.end_node
    || ',' || newedge.next_left_edge
    || ',' || newedge.next_right_edge
    || ',' || newedge.left_face
    || ',' || newedge.right_face
    || ',' || quote_literal(newedge.geom::geometry::text)
    || ')';

  -- Link prev_left_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_left_edge) != newedge.edge_id THEN
    IF newedge.prev_left_edge > 0 THEN
      -- its next_left_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_left_edge;
    ELSE
      -- its next_right_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_left_edge;
    END IF;
  END IF;

  -- Link prev_right_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_right_edge) != newedge.edge_id THEN
    IF newedge.prev_right_edge > 0 THEN
      -- its next_left_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || -newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_right_edge;
    ELSE
      -- its next_right_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || -newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_right_edge;
    END IF;
  END IF;

  -- NOT IN THE SPECS...
  -- set containing_face = null for start_node and end_node
  -- if they where isolated 
  IF span.was_isolated OR epan.was_isolated THEN
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.node SET containing_face = null WHERE node_id IN ('
        || anode || ',' || anothernode || ')';
  END IF;

  --------------------------------------------
  -- Check face splitting
  --------------------------------------------

  SELECT topology._ST_AddFaceSplit(atopology, newedge.edge_id, newedge.left_face, false)
  INTO newface;
  IF newface = 0 THEN
    RETURN newedge.edge_id; 
  END IF;

  IF newface IS NULL THEN -- must be forming a maximal ring in universal face
    SELECT topology._ST_AddFaceSplit(atopology, -newedge.edge_id, newedge.left_face, false)
    INTO newface;
  ELSE
    PERFORM topology._ST_AddFaceSplit(atopology, -newedge.edge_id, newedge.left_face, true);
  END IF;

  IF newface IS NULL THEN
    RETURN newedge.edge_id; 
  END IF;

  --------------------------------------------
  -- Update topogeometries, if needed
  --------------------------------------------

  IF newedge.left_face != 0 THEN -- {

    -- NOT IN THE SPECS:
    -- update TopoGeometry compositions to add newface
    sql := 'SELECT r.topogeo_id, r.layer_id FROM '
      || quote_ident(atopology)
      || '.relation r, topology.layer l '
      || ' WHERE l.topology_id = ' || topoid
      || ' AND l.level = 0 '
      || ' AND l.layer_id = r.layer_id '
      || ' AND r.element_id = ' || newedge.left_face
      || ' AND r.element_type = 3 ';
    --RAISE DEBUG 'SQL: %', sql;
    FOR rec IN EXECUTE sql
    LOOP

      -- Add reference to the other face
      sql := 'INSERT INTO ' || quote_ident(atopology)
        || '.relation VALUES( ' || rec.topogeo_id
        || ',' || rec.layer_id || ',' || newface || ', 3)';
      --RAISE DEBUG 'SQL: %', sql;
      EXECUTE sql;

    END LOOP;

  END IF; -- }

  RETURN newedge.edge_id;
END
$$;


ALTER FUNCTION topology.st_addedgemodface(atopology character varying, anode integer, anothernode integer, acurve public.geometry) OWNER TO postgres;

--
-- TOC entry 1471 (class 1255 OID 31216)
-- Name: st_addedgenewfaces(character varying, integer, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_addedgenewfaces(atopology character varying, anode integer, anothernode integer, acurve public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  i INTEGER;
  topoid INTEGER;
  az FLOAT8;
  span RECORD; -- start point analysis data
  epan RECORD; --   end point analysis data
  fan RECORD; -- face analisys
  newedge RECORD; -- informations about new edge
  sql TEXT;
  newfaces INTEGER[];
  newface INTEGER;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL
    OR anode IS NULL
    OR anothernode IS NULL
    OR acurve IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid curve';
  END IF;
  
  --
  -- Curve must be simple
  --
  IF NOT ST_IsSimple(acurve) THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Get topology id
  --
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  -- Initialize new edge info (will be filled up more later)
  SELECT anode as start_node, anothernode as end_node, acurve as geom,
    NULL::int as next_left_edge, NULL::int as next_right_edge,
    NULL::int as left_face, NULL::int as right_face, NULL::int as edge_id,
    NULL::int as prev_left_edge, NULL::int as prev_right_edge, -- convenience
    anode = anothernode as isclosed, -- convenience
    false as start_node_isolated, -- convenience
    false as end_node_isolated, -- convenience
    NULL::geometry as start_node_geom, -- convenience
    NULL::geometry as end_node_geom, -- convenience
    ST_RemoveRepeatedPoints(acurve) as cleangeom -- convenience
  INTO newedge;

  -- Compute azimuth of first edge end on start node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_StartPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom, 2)) AS myaz
  INTO span;
  IF span.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;

  -- Compute azimuth of last edge end on end node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_EndPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom,
                              ST_NumPoints(newedge.cleangeom)-1)) AS myaz
  INTO epan;
  IF epan.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;


  -- 
  -- Check endpoints existance, match with Curve geometry
  -- and get face information (if any)
  --
  i := 0;
  FOR rec IN EXECUTE 'SELECT node_id, containing_face, geom FROM '
    || quote_ident(atopology)
    || '.node WHERE node_id IN ( '
    || anode || ',' || anothernode
    || ')'
  LOOP
    IF rec.containing_face IS NOT NULL THEN
      IF newedge.left_face IS NULL THEN
        newedge.left_face := rec.containing_face;
        newedge.right_face := rec.containing_face;
      ELSE
        IF newedge.left_face != rec.containing_face THEN
          RAISE EXCEPTION
            'SQL/MM Spatial exception - geometry crosses an edge (endnodes in faces % and %)', newedge.left_face, rec.containing_face;
        END IF;
      END IF;
    END IF;

    IF rec.node_id = anode THEN
      newedge.start_node_geom = rec.geom;
    END IF;

    IF rec.node_id = anothernode THEN
      newedge.end_node_geom = rec.geom;
    END IF;

    i := i + 1;
  END LOOP;

  IF newedge.start_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT ST_Equals(newedge.start_node_geom, ST_StartPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  IF newedge.end_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT ST_Equals(newedge.end_node_geom, ST_EndPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - end node not geometry end point.';
  END IF;

  RAISE DEBUG 'All Checked !';

  --
  -- Check if this geometry crosses any node
  --
  FOR rec IN EXECUTE
    'SELECT node_id, ST_Relate(geom, '
    || quote_literal(acurve::text) || '::geometry, 2) as relate FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(acurve::text)
    || '::geometry'
  LOOP
    IF ST_RelateMatch(rec.relate, 'T********') THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - geometry crosses a node';
    END IF;
  END LOOP;

  --
  -- Check if this geometry has any interaction with any existing edge
  --
  FOR rec IN EXECUTE 'SELECT edge_id, ST_Relate(geom,' 
    || quote_literal(acurve::text)
    || '::geometry, 2) as im FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE geom && '
    || quote_literal(acurve::text) || '::geometry'
  LOOP

    --RAISE DEBUG 'IM=%',rec.im;

    IF ST_RelateMatch(rec.im, 'F********') THEN
      CONTINUE; -- no interior intersection
    END IF;

    IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - coincident edge %', rec.edge_id;
    END IF;

    -- NOT IN THE SPECS: geometry touches an edge
    IF ST_RelateMatch(rec.im, '1********') THEN
      RAISE EXCEPTION
        'Spatial exception - geometry intersects edge %', rec.edge_id;
    END IF;

    IF ST_RelateMatch(rec.im, 'T********') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - geometry crosses edge %', rec.edge_id;
    END IF;

  END LOOP;

  ---------------------------------------------------------------
  --
  -- All checks passed, time to prepare the new edge
  --
  ---------------------------------------------------------------

  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(atopology) || '.edge_data_edge_id_seq') || ')'
  INTO STRICT newedge.edge_id;


  -- Find links on start node -- {


  sql :=
    'SELECT edge_id, -1 AS end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anode
    || ' UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || newedge.end_node
      || ',-1,0,0,' -- pretend we start elsewhere
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom), ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
                       ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;

    IF az IS NULL THEN
      RAISE EXCEPTION 'Invalid edge % found (no two distinct nodes exist)',
        rec.edge_id;
    END IF;


    az = az - span.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF span.maxaz IS NULL OR az > span.maxaz THEN
      span.maxaz := az;
      span.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF span.minaz IS NULL OR az < span.minaz THEN
      span.minaz := az;
      span.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', span.nextCW, span.minaz, span.nextCCW, span.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN span.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN span.was_isolated = true; END IF;
  END IF;

  IF span.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_right_edge := newedge.edge_id;
    newedge.prev_left_edge := -newedge.edge_id;
  ELSE
    newedge.next_right_edge := span.nextCW;
    newedge.prev_left_edge := -span.nextCCW;
  END IF;


  -- } start_node analysis


  -- Find links on end_node {
      

  sql :=
    'SELECT edge_id, -1 as end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anothernode
    || 'UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anothernode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || -1 -- pretend we end elsewhere
      || ',' || newedge.start_node || ',0,0,'
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anothernode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom),
                       ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
        ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;


    az := az - epan.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF epan.maxaz IS NULL OR az > epan.maxaz THEN
      epan.maxaz := az;
      epan.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF epan.minaz IS NULL OR az < epan.minaz THEN
      epan.minaz := az;
      epan.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', epan.nextCW, epan.minaz, epan.nextCCW, epan.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN epan.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN epan.was_isolated = true; END IF;
  END IF;

  IF epan.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_left_edge := -newedge.edge_id;
    newedge.prev_right_edge := newedge.edge_id;
  ELSE
    newedge.next_left_edge := epan.nextCW;
    newedge.prev_right_edge := -epan.nextCCW;
  END IF;

  -- } end_node analysis


  ----------------------------------------------------------------------
  --
  -- If we don't have faces setup by now we must have encountered
  -- a malformed topology (no containing_face on isolated nodes, no
  -- left/right faces on adjacent edges or mismatching values)
  --
  ----------------------------------------------------------------------
  IF newedge.left_face != newedge.right_face THEN
    RAISE EXCEPTION 'Left(%)/right(%) faces mismatch: invalid topology ?', 
      newedge.left_face, newedge.right_face;
  END IF;
  IF newedge.left_face IS NULL THEN
    RAISE EXCEPTION 'Could not derive edge face from linked primitives: invalid topology ?';
  END IF;

  ----------------------------------------------------------------------
  --
  -- Insert the new edge, and update all linking
  --
  ----------------------------------------------------------------------

  -- Insert the new edge with what we have so far
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) 
    || '.edge VALUES(' || newedge.edge_id
    || ',' || newedge.start_node
    || ',' || newedge.end_node
    || ',' || newedge.next_left_edge
    || ',' || newedge.next_right_edge
    || ',' || newedge.left_face
    || ',' || newedge.right_face
    || ',' || quote_literal(newedge.geom::geometry::text)
    || ')';

  -- Link prev_left_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_left_edge) != newedge.edge_id THEN
    IF newedge.prev_left_edge > 0 THEN
      -- its next_left_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_left_edge;
    ELSE
      -- its next_right_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_left_edge;
    END IF;
  END IF;

  -- Link prev_right_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_right_edge) != newedge.edge_id THEN
    IF newedge.prev_right_edge > 0 THEN
      -- its next_left_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || -newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_right_edge;
    ELSE
      -- its next_right_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || -newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_right_edge;
    END IF;
  END IF;

  -- NOT IN THE SPECS...
  -- set containing_face = null for start_node and end_node
  -- if they where isolated 
  IF span.was_isolated OR epan.was_isolated THEN
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.node SET containing_face = null WHERE node_id IN ('
        || anode || ',' || anothernode || ')';
  END IF;

  --------------------------------------------
  -- Check face splitting
  --------------------------------------------


  SELECT topology._ST_AddFaceSplit(atopology, -newedge.edge_id, newedge.left_face, false)
  INTO newface;

  IF newface = 0 THEN
    RETURN newedge.edge_id; 
  END IF;

  newfaces[1] := newface;

  SELECT topology._ST_AddFaceSplit(atopology, newedge.edge_id, newedge.left_face, false)
  INTO newface;

  newfaces[2] := newface;

  IF newedge.left_face != 0 THEN -- {

    -- NOT IN THE SPECS:
    -- update TopoGeometry compositions to substitute oldface with newfaces
    sql := 'UPDATE '
      || quote_ident(atopology)
      || '.relation r set element_id = ' || newfaces[1]
      || ' FROM topology.layer l '
      || ' WHERE l.topology_id = ' || topoid
      || ' AND l.level = 0 '
      || ' AND l.layer_id = r.layer_id '
      || ' AND r.element_id = ' || newedge.left_face
      || ' AND r.element_type = 3 RETURNING r.topogeo_id, r.layer_id';
    --RAISE DEBUG 'SQL: %', sql;
    FOR rec IN EXECUTE sql
    LOOP

      -- Add reference to the other face
      sql := 'INSERT INTO ' || quote_ident(atopology)
        || '.relation VALUES( ' || rec.topogeo_id
        || ',' || rec.layer_id || ',' || newfaces[2] || ', 3)';
      --RAISE DEBUG 'SQL: %', sql;
      EXECUTE sql;

    END LOOP;

    -- drop old face from faces table
    sql := 'DELETE FROM ' || quote_ident(atopology)
      || '.face WHERE face_id = ' || newedge.left_face;
    EXECUTE sql;

  END IF; -- }

  RETURN newedge.edge_id;
END
$$;


ALTER FUNCTION topology.st_addedgenewfaces(atopology character varying, anode integer, anothernode integer, acurve public.geometry) OWNER TO postgres;

--
-- TOC entry 1467 (class 1255 OID 31211)
-- Name: st_addisoedge(character varying, integer, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_addisoedge(atopology character varying, anode integer, anothernode integer, acurve public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  aface INTEGER;
  face GEOMETRY;
  snodegeom GEOMETRY;
  enodegeom GEOMETRY;
  count INTEGER;
  rec RECORD;
  edgeid INTEGER;
BEGIN

  --
  -- All arguments required
  -- 
  IF atopology IS NULL
     OR anode IS NULL
     OR anothernode IS NULL
     OR acurve IS NULL
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS:
  -- A closed edge is never isolated (as it forms a face)
  IF anode = anothernode THEN
      RAISE EXCEPTION
       'Closed edges would not be isolated, try ST_AddEdgeNewFaces';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid curve';
  END IF;

  --
  -- Acurve must be simple
  --
  IF NOT ST_IsSimple(acurve)
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Check for:
  --    existence of nodes
  --    nodes faces match
  -- Extract:
  --    nodes face id
  --    nodes geoms
  --
  aface := NULL;
  count := 0;
  FOR rec IN EXECUTE 'SELECT geom, containing_face, node_id FROM '
    || quote_ident(atopology) || '.node
    WHERE node_id = ' || anode ||
    ' OR node_id = ' || anothernode
  LOOP 

    IF rec.containing_face IS NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - not isolated node';
    END IF;

    IF aface IS NULL THEN
      aface := rec.containing_face;
    ELSE
      IF aface != rec.containing_face THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - nodes in different faces';
      END IF;
    END IF;

    -- Get nodes geom
    IF rec.node_id = anode THEN
      snodegeom = rec.geom;
    ELSE
      enodegeom = rec.geom;
    END IF;

    count = count+1;

  END LOOP;

  -- TODO: don't need count, can do with snodegeom/enodegeom instead..
  IF count < 2 THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  END IF;


  --
  -- l) Check that start point of acurve match start node
  -- geoms.
  -- 
  IF ST_X(snodegeom) != ST_X(ST_StartPoint(acurve)) OR
     ST_Y(snodegeom) != ST_Y(ST_StartPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  --
  -- m) Check that end point of acurve match end node
  -- geoms.
  -- 
  IF ST_X(enodegeom) != ST_X(ST_EndPoint(acurve)) OR
     ST_Y(enodegeom) != ST_Y(ST_EndPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - end node not geometry end point.';
  END IF;

  --
  -- n) Check if curve crosses (contains) any node
  -- I used _contains_ here to leave endpoints out
  -- 
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node '
    || ' WHERE geom && ' || quote_literal(acurve::text) 
    || ' AND ST_Contains(' || quote_literal(acurve::text)
    || ',geom)'
  LOOP
    RAISE EXCEPTION
      'SQL/MM Spatial exception - geometry crosses a node';
  END LOOP;

  --
  -- o) Check if curve intersects any other edge
  -- 
  FOR rec IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data
    WHERE ST_Intersects(geom, ' || quote_literal(acurve::text) || '::geometry)'
  LOOP
    RAISE EXCEPTION 'SQL/MM Spatial exception - geometry intersects an edge';
  END LOOP;

  --
  -- Get new edge id from sequence
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    edgeid = rec.nextval;
  END LOOP;

  -- TODO: this should likely be an exception instead !
  IF aface IS NULL THEN
    aface := 0;
  END IF;

  --
  -- Insert the new row
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge VALUES(' || edgeid || ',' || anode
    || ',' || anothernode || ',' || (-edgeid)
    || ',' || edgeid || ','
    || aface || ',' || aface || ','
    || quote_literal(acurve::text) || ')';

  --
  -- Update Node containing_face values
  --
  -- the nodes anode and anothernode are no more isolated
  -- because now there is an edge connecting them
  -- 
  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.node SET containing_face = NULL where (node_id ='
    || anode
    || ' OR node_id='
    || anothernode
    || ')';

  RETURN edgeid;

END
$$;


ALTER FUNCTION topology.st_addisoedge(atopology character varying, anode integer, anothernode integer, acurve public.geometry) OWNER TO postgres;

--
-- TOC entry 1462 (class 1255 OID 31202)
-- Name: st_addisonode(character varying, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_addisonode(atopology character varying, aface integer, apoint public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  nodeid integer;
  sql text;
  containingface integer;
BEGIN

  --
  -- Atopology and apoint are required
  -- 
  IF atopology IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Atopology must  be registered
  -- 
  IF NOT EXISTS(SELECT name FROM topology.topology WHERE topology.name = atopology) THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid topology name';
  END IF;
  --
  -- Apoint must be a point
  --
  IF substring(geometrytype(apoint), 1, 5) != 'POINT'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid point';
  END IF;

  --
  -- Check if a coincident node already exists
  -- 
  -- We use index AND x/y equality
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node ' ||
    'WHERE ST_Equals(geom, ' || quote_literal(apoint::text) || '::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Check if any edge crosses (intersects) this node
  -- I used _intersects_ here to include boundaries (endpoints)
  --
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge ' 
    || 'WHERE ST_Intersects(geom, ' || quote_literal(apoint::text)
    || '::geometry)'
  LOOP
    RAISE EXCEPTION
    'SQL/MM Spatial exception - edge crosses node.';
  END LOOP;

  -- retrieve the face that contains (eventually) the point
  
  --
  -- first test is to check if there is inside an mbr (more fast)
  --
  sql := 'SELECT f.face_id FROM ' 
        || quote_ident(atopology) 
        || '.face f WHERE f.face_id > 0 AND f.mbr && '
        || quote_literal(apoint::text)
        || '::geometry AND ST_Contains(topology.ST_GetFaceGeometry('
        || quote_literal(atopology) 
        || ', f.face_id), '
        || quote_literal(apoint::text)
        || '::geometry)';
  IF aface IS NOT NULL AND aface != 0 THEN
    sql := sql || ' AND f.face_id = ' || aface;
  END IF;

  EXECUTE sql INTO containingface;

  -- If aface was specified, check that it was correct
  IF aface IS NOT NULL THEN -- {
    IF aface = 0 THEN -- {
      IF containingface IS NOT NULL THEN -- {
        RAISE EXCEPTION
          'SQL/MM Spatial exception - within face % (not universe)',
          containingface;
      ELSE -- }{
        containingface := 0;
      END IF; -- }
    ELSE -- }{ -- aface != 0
      IF containingface IS NULL OR containingface != aface THEN -- {
        RAISE EXCEPTION 'SQL/MM Spatial exception - not within face';
      END IF; -- }
    END IF; -- }
  ELSE -- }{ -- aface is null
    containingface := COALESCE(containingface, 0);
  END IF; -- }

  --
  -- Insert the new row
  --
  sql := 'INSERT INTO '
      || quote_ident(atopology)
      || '.node(node_id, geom, containing_face) SELECT nextval('
      || quote_literal( quote_ident(atopology) || '.node_node_id_seq' )
      || '),'
      ||quote_literal(apoint::text)
      || '::geometry,' || containingface
      || ' RETURNING node_id';

  EXECUTE sql INTO nodeid;

  RETURN nodeid;
EXCEPTION
  -- TODO: avoid the EXCEPTION handling here ?
  WHEN INVALID_SCHEMA_NAME THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
END
$$;


ALTER FUNCTION topology.st_addisonode(atopology character varying, aface integer, apoint public.geometry) OWNER TO postgres;

--
-- TOC entry 1469 (class 1255 OID 31213)
-- Name: st_changeedgegeom(character varying, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_changeedgegeom(atopology character varying, anedge integer, acurve public.geometry) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  rng_info RECORD; -- movement range info
  oldedge RECORD;
  range GEOMETRY; -- movement range
  tmp1 GEOMETRY;
  snode_info RECORD;
  enode_info RECORD;
  sql TEXT;
  iscw BOOLEAN;
BEGIN

  --
  -- All arguments required
  -- 
  IF atopology IS NULL
     OR anedge IS NULL
     OR acurve IS NULL
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid curve';
  END IF;

  --
  -- Acurve must be a simple
  --
  IF NOT ST_IsSimple(acurve)
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Get data about existing edge
  --
  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(atopology) || '.edge_data  '
      || ' WHERE edge_id = ' || anedge
    INTO STRICT oldedge;
  EXCEPTION
    -- NOT IN THE SPECS: check given edge existance
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', anedge;
  END;

  --
  -- e) Check StartPoint consistency
  --
  IF NOT ST_Equals(ST_StartPoint(acurve), ST_StartPoint(oldedge.geom)) THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  IF oldedge.start_node = oldedge.end_node THEN -- {

    -- Not in the specs:
    -- if the edge is closed, check we didn't change winding !
    --       (should be part of isomorphism checking)
    range := ST_MakePolygon(oldedge.geom);
    iscw := ST_OrderingEquals(range, ST_ForceRHR(range));

    IF ST_NumPoints(ST_RemoveRepeatedPoints(acurve)) < 3 THEN
      RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
    END IF;
    range := ST_MakePolygon(acurve);

    IF iscw != ST_OrderingEquals(range, ST_ForceRHR(range)) THEN
      RAISE EXCEPTION 'Edge twist at node %',
        ST_AsText(ST_StartPoint(oldedge.geom));
    END IF;

  ELSE -- }{

    --
    -- f) Check EndPoint consistency
    --
    IF NOT ST_Equals(ST_EndPoint(acurve), ST_EndPoint(oldedge.geom)) THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - end node not geometry end point.';
    END IF;

  END IF; -- }

  --
  -- g) Check if curve crosses any node
  -- 
  FOR rec IN EXECUTE
    'SELECT node_id, ST_Relate(geom, '
    || quote_literal(acurve::text) || '::geometry, 2) as relate FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(acurve::text)
    || '::geometry AND node_id NOT IN ('
    || oldedge.start_node || ',' || oldedge.end_node
    || ')'
  LOOP
    IF ST_RelateMatch(rec.relate, 'T********') THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - geometry crosses a node';
    END IF;
  END LOOP;

  --
  -- h) Check if this geometry has any interaction with any existing edge
  --
  sql := 'SELECT edge_id, ST_Relate(geom,' 
    || quote_literal(acurve::text)
    || '::geometry, 2) as im FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE edge_id != ' || anedge || ' AND geom && '
    || quote_literal(acurve::text) || '::geometry';
  FOR rec IN EXECUTE sql LOOP -- {

    --RAISE DEBUG 'IM=%',rec.im;

    IF ST_RelateMatch(rec.im, 'F********') THEN
      CONTINUE; -- no interior-interior intersection
    END IF;

    IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - coincident edge %', rec.edge_id;
    END IF;

    -- NOT IN THE SPECS: geometry touches an edge
    IF ST_RelateMatch(rec.im, '1********') THEN
      RAISE EXCEPTION
        'Spatial exception - geometry intersects edge %', rec.edge_id;
    END IF;

    IF ST_RelateMatch(rec.im, 'T********') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - geometry crosses edge %', rec.edge_id;
    END IF;

  END LOOP; -- }

  --
  -- Not in the specs:
  -- Check topological isomorphism 
  --

  -- Check that the "motion range" doesn't include any node 
  --{

  sql := 'SELECT ST_Collect(geom) as nodes, '
    || 'null::geometry as r1, null::geometry as r2 FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(ST_Collect(ST_Envelope(oldedge.geom),
                                ST_Envelope(acurve))::text)
    || '::geometry AND node_id NOT IN ( '
    || oldedge.start_node || ',' || oldedge.end_node || ')';
  EXECUTE sql INTO rng_info;

  -- There's no collision if there's no nodes in the combined
  -- bbox of old and new edges.
  --
  IF NOT ST_IsEmpty(rng_info.nodes) THEN -- {


    tmp1 := ST_MakeLine(ST_EndPoint(oldedge.geom), ST_StartPoint(oldedge.geom));

    rng_info.r1 := ST_MakeLine(oldedge.geom, tmp1);
    IF ST_NumPoints(rng_info.r1) < 4 THEN
      rng_info.r1 := ST_AddPoint(rng_info.r1, ST_StartPoint(oldedge.geom));
    END IF;
    rng_info.r1 := ST_CollectionExtract(
                       ST_MakeValid(ST_MakePolygon(rng_info.r1)), 3);

    rng_info.r2 := ST_MakeLine(acurve, tmp1);
    IF ST_NumPoints(rng_info.r2) < 4 THEN
      rng_info.r2 := ST_AddPoint(rng_info.r2, ST_StartPoint(oldedge.geom));
    END IF;
    rng_info.r2 := ST_CollectionExtract(
                       ST_MakeValid(ST_MakePolygon(rng_info.r2)), 3);

    FOR rec IN WITH
      nodes AS ( SELECT * FROM ST_Dump(rng_info.nodes) ),
      inr1 AS ( SELECT path[1] FROM nodes WHERE ST_Contains(rng_info.r1, geom) ),
      inr2 AS ( SELECT path[1] FROM nodes WHERE ST_Contains(rng_info.r2, geom) )
      ( SELECT * FROM inr1
          EXCEPT
        SELECT * FROM inr2
      ) UNION 
      ( SELECT * FROM inr2
          EXCEPT
        SELECT * FROM inr1
      )
    LOOP
      RAISE EXCEPTION 'Edge motion collision at %',
                     ST_AsText(ST_GeometryN(rng_info.nodes, rec.path));
    END LOOP;

  END IF; -- }

  --} motion range checking end

  -- 
  -- Check edge adjacency before
  --{

  SELECT topology._ST_AdjacentEdges(
      atopology, oldedge.start_node, anedge
    ) as pre, NULL::integer[] as post
  INTO STRICT snode_info;

  SELECT topology._ST_AdjacentEdges(
      atopology, oldedge.end_node, -anedge
    ) as pre, NULL::integer[] as post
  INTO STRICT enode_info;

  --}

  --
  -- Update edge geometry
  --
  EXECUTE 'UPDATE ' || quote_ident(atopology) || '.edge_data '
    || ' SET geom = ' || quote_literal(acurve::text) 
    || ' WHERE edge_id = ' || anedge;

  -- 
  -- Check edge adjacency after
  --{

  snode_info.post := topology._ST_AdjacentEdges(
      atopology, oldedge.start_node, anedge
    );

  enode_info.post := topology._ST_AdjacentEdges(
      atopology, oldedge.end_node, -anedge
    );

  IF snode_info.pre != snode_info.post THEN
    RAISE EXCEPTION 'Edge changed disposition around start node %',
      oldedge.start_node;
  END IF;

  IF enode_info.pre != enode_info.post THEN
    RAISE EXCEPTION 'Edge changed disposition around end node %',
      oldedge.end_node;
  END IF;

  --}

  -- Update faces MBR of left and right faces
  -- TODO: think about ways to optimize this part, like see if
  --       the old edge geometry partecipated in the definition
  --       of the current MBR (for shrinking) or the new edge MBR
  --       would be larger than the old face MBR...
  --
  IF oldedge.left_face != 0 THEN
    sql := 'UPDATE ' || quote_ident(atopology) || '.face '
      || ' SET mbr = ' || quote_literal(
        ST_Envelope(topology.ST_GetFaceGeometry(atopology, oldedge.left_face))::text
        )
      || '::geometry WHERE face_id = ' || oldedge.left_face;
    EXECUTE sql;
  END IF;
  IF oldedge.right_face != 0 AND oldedge.right_face != oldedge.left_face THEN
    sql := 'UPDATE ' || quote_ident(atopology) || '.face '
      || ' SET mbr = ' || quote_literal(
        ST_Envelope(topology.ST_GetFaceGeometry(atopology, oldedge.right_face))::text
        )
      || '::geometry WHERE face_id = ' || oldedge.right_face;
    EXECUTE sql;
  END IF;
  

  RETURN 'Edge ' || anedge || ' changed';

END
$$;


ALTER FUNCTION topology.st_changeedgegeom(atopology character varying, anedge integer, acurve public.geometry) OWNER TO postgres;

--
-- TOC entry 1474 (class 1255 OID 31221)
-- Name: st_createtopogeo(character varying, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_createtopogeo(atopology character varying, acollection public.geometry) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  typ char(4);
  rec RECORD;
  ret int;
  nodededges GEOMETRY;
  points GEOMETRY;
  snode_id int;
  enode_id int;
  tolerance FLOAT8;
  topoinfo RECORD;
BEGIN

  IF atopology IS NULL OR acollection IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology information
  BEGIN
    SELECT * FROM topology.topology
      INTO STRICT topoinfo WHERE name = atopology;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  -- Check SRID compatibility
  IF ST_SRID(acollection) != topoinfo.SRID THEN
    RAISE EXCEPTION 'Geometry SRID (%) does not match topology SRID (%)',
      ST_SRID(acollection), topoinfo.SRID;
  END IF;

  -- Verify pre-conditions (valid, empty topology schema exists)
  BEGIN -- {

    -- Verify the topology views in the topology schema to be empty
    FOR rec in EXECUTE
      'SELECT count(*) FROM '
      || quote_ident(atopology) || '.edge_data '
      || ' UNION ' ||
      'SELECT count(*) FROM '
      || quote_ident(atopology) || '.node '
    LOOP
      IF rec.count > 0 THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-empty view';
      END IF;
    END LOOP;

    -- face check is separated as it will contain a single (world)
    -- face record
    FOR rec in EXECUTE
      'SELECT count(*) FROM '
      || quote_ident(atopology) || '.face '
    LOOP
      IF rec.count != 1 THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-empty face view';
      END IF;
    END LOOP;

  EXCEPTION
    WHEN INVALID_SCHEMA_NAME THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
    WHEN UNDEFINED_TABLE THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent view';

  END; -- }


  --
  -- Node input linework with itself
  --
  WITH components AS ( SELECT geom FROM ST_Dump(acollection) )
  SELECT ST_UnaryUnion(ST_Collect(geom)) FROM (
    SELECT geom FROM components
      WHERE ST_Dimension(geom) = 1
    UNION ALL
    SELECT ST_Boundary(geom) FROM components
      WHERE ST_Dimension(geom) = 2
  ) as linework INTO STRICT nodededges;


  --
  -- Linemerge the resulting edges, to reduce the working set
  -- NOTE: this is more of a workaround for GEOS splitting overlapping
  --       lines to each of the segments.
  --
  SELECT ST_LineMerge(nodededges) INTO STRICT nodededges;



  --
  -- Collect input points and input lines endpoints
  --
  WITH components AS ( SELECT geom FROM ST_Dump(acollection) )
  SELECT ST_Union(geom) FROM (
    SELECT geom FROM components
      WHERE ST_Dimension(geom) = 0
    UNION ALL
    SELECT ST_Boundary(geom) FROM components
      WHERE ST_Dimension(geom) = 1
  ) as nodes INTO STRICT points;


  --
  -- Further split edges by points
  -- TODO: optimize this adding ST_Split support for multiline/multipoint
  --
  FOR rec IN SELECT geom FROM ST_Dump(points)
  LOOP
    -- Use the node to split edges
    SELECT ST_Collect(geom) 
    FROM ST_Dump(ST_Split(nodededges, rec.geom))
    INTO STRICT nodededges;
  END LOOP;
  SELECT ST_UnaryUnion(nodededges) INTO STRICT nodededges;


  --
  -- Collect all nodes (from points and noded linework endpoints)
  --

  WITH edges AS ( SELECT geom FROM ST_Dump(nodededges) )
  SELECT ST_Union( -- TODO: ST_UnaryUnion ?
          COALESCE(ST_UnaryUnion(ST_Collect(geom)), 
            ST_SetSRID('POINT EMPTY'::geometry, topoinfo.SRID)),
          COALESCE(points,
            ST_SetSRID('POINT EMPTY'::geometry, topoinfo.SRID))
         )
  FROM (
    SELECT ST_StartPoint(geom) as geom FROM edges
      UNION ALL
    SELECT ST_EndPoint(geom) FROM edges
  ) as endpoints INTO points;


  --
  -- Add all nodes as isolated so that 
  -- later calls to AddEdgeModFace will tweak their being
  -- isolated or not...
  --
  FOR rec IN SELECT geom FROM ST_Dump(points)
  LOOP
    PERFORM topology.ST_AddIsoNode(atopology, 0, rec.geom);
  END LOOP;
  

  FOR rec IN SELECT geom FROM ST_Dump(nodededges)
  LOOP
    SELECT topology.GetNodeByPoint(atopology, st_startpoint(rec.geom), 0)
      INTO STRICT snode_id;
    SELECT topology.GetNodeByPoint(atopology, st_endpoint(rec.geom), 0)
      INTO STRICT enode_id;
    PERFORM topology.ST_AddEdgeModFace(atopology, snode_id, enode_id, rec.geom);
  END LOOP;

  RETURN 'Topology ' || atopology || ' populated';

END
$$;


ALTER FUNCTION topology.st_createtopogeo(atopology character varying, acollection public.geometry) OWNER TO postgres;

--
-- TOC entry 1439 (class 1255 OID 31168)
-- Name: st_geometrytype(topogeometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_geometrytype(tg topogeometry) RETURNS text
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT CASE
		WHEN type($1) = 1 THEN 'ST_MultiPoint'
		WHEN type($1) = 2 THEN 'ST_MultiLinestring'
		WHEN type($1) = 3 THEN 'ST_MultiPolygon'
		WHEN type($1) = 4 THEN 'ST_GeometryCollection'
		ELSE 'ST_Unexpected'
		END;
$_$;


ALTER FUNCTION topology.st_geometrytype(tg topogeometry) OWNER TO postgres;

--
-- TOC entry 1455 (class 1255 OID 31191)
-- Name: st_getfaceedges(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_getfaceedges(toponame character varying, face_id integer) RETURNS SETOF getfaceedges_returntype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  rec RECORD;
  bounds geometry;
  retrec topology.GetFaceEdges_ReturnType;
  n int;
  sql TEXT;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR face_id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  IF NOT EXISTS(SELECT name FROM topology.topology WHERE name = toponame)  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END IF;

  n := 1;

  -- Construct the face geometry, then for each ring of each polygon:
  sql := 'SELECT (ST_DumpRings((ST_Dump(ST_ForceRHR('
    || 'ST_BuildArea(ST_Collect(geom))))).geom)).geom FROM '
    || quote_ident(toponame) || '.edge_data WHERE left_face = '
    || face_id || ' OR right_face = ' || face_id;
  FOR rec IN EXECUTE sql 
  LOOP -- {

    -- Find the edges constituting its boundary
    bounds = ST_Boundary(rec.geom);


    sql := 'WITH er2 AS ( ' 
      || 'WITH er AS ( SELECT ' 
      || 'min(e.edge_id) over (), count(*) over () as cnt, e.edge_id, '
      || 'ST_LineLocatePoint('
      || quote_literal(bounds::text)
      || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
      || ', ST_LineLocatePoint('
      || quote_literal(bounds::text)
      || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
      || quote_ident(toponame)
      || '.edge e WHERE ( e.left_face = ' || face_id
      || ' OR e.right_face = ' || face_id
      || ') AND ST_Covers('
      || quote_literal(bounds::text)
      || ', e.geom)';
    IF face_id = 0 THEN
      sql := sql || ' ORDER BY POS ASC) ';
    ELSE
      sql := sql || ' ORDER BY POS DESC) ';
    END IF;

    -- Reorder rows so to start with the one with smaller edge_id
    sql := sql || 'SELECT row_number() over () - 1 as rn, * FROM er ) '
               || 'SELECT *, ( rn + cnt - ( select rn FROM er2 WHERE edge_id = min ) ) % cnt AS reord FROM er2 ORDER BY reord';


    --RAISE DEBUG 'SQL: %', sql;

    FOR rec IN EXECUTE sql
    LOOP


      retrec.sequence = n;
      retrec.edge = rec.edge_id;

      IF face_id = 0 THEN
        -- if this edge goes in opposite direction to the
        --       ring bounds, make it with negative orientation
        IF rec.pos2 < rec.pos THEN -- edge goes in opposite direction
          retrec.edge = -retrec.edge;
        END IF;
      ELSE
        -- if this edge goes in same direction to the
        --       ring bounds, make it with negative orientation
        IF rec.pos2 > rec.pos THEN -- edge goes in same direction
          retrec.edge = -retrec.edge;
        END IF;
      END IF;

      RETURN NEXT retrec;

      n = n+1;

    END LOOP;
  END LOOP; -- }

  RETURN;
EXCEPTION
  WHEN INVALID_SCHEMA_NAME THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
END
$$;


ALTER FUNCTION topology.st_getfaceedges(toponame character varying, face_id integer) OWNER TO postgres;

--
-- TOC entry 1461 (class 1255 OID 31201)
-- Name: st_getfacegeometry(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_getfacegeometry(toponame character varying, aface integer) RETURNS public.geometry
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  rec RECORD;
  sql TEXT;
BEGIN

  --
  -- toponame and aface are required
  -- 
  IF toponame IS NULL OR aface IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  IF NOT EXISTS(SELECT name FROM topology.topology WHERE name = toponame)  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END IF;

  IF aface = 0 THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - universal face has no geometry';
  END IF;

  BEGIN

    -- No such face
    sql := 'SELECT NOT EXISTS (SELECT * from ' || quote_ident(toponame)
      || '.face WHERE face_id = ' || aface
      || ') as none';
    EXECUTE sql INTO rec;
    IF rec.none THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent face.';
    END IF;

    --
    -- Construct face 
    -- 
    sql :=
      'SELECT ST_BuildArea(ST_Collect(geom)) as geom FROM '
      || quote_ident(toponame)
      || '.edge_data WHERE left_face = ' || aface
      || ' OR right_face = ' || aface;
    FOR rec IN EXECUTE sql
    LOOP
      RETURN rec.geom;
    END LOOP;

  EXCEPTION
    WHEN INVALID_SCHEMA_NAME THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
    WHEN UNDEFINED_TABLE THEN
      RAISE EXCEPTION 'corrupted topology "%"', toponame;
  END;

  RETURN NULL;
END
$$;


ALTER FUNCTION topology.st_getfacegeometry(toponame character varying, aface integer) OWNER TO postgres;

--
-- TOC entry 1473 (class 1255 OID 31220)
-- Name: st_inittopogeo(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_inittopogeo(atopology character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  topology_id numeric;
BEGIN
  IF atopology IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
  LOOP
    RAISE EXCEPTION 'SQL/MM Spatial exception - schema already exists';
  END LOOP;

  FOR rec IN EXECUTE 'SELECT topology.CreateTopology('
    ||quote_literal(atopology)|| ') as id'
  LOOP
    topology_id := rec.id;
  END LOOP;

  RETURN 'Topology-Geometry ' || quote_literal(atopology)
    || ' (id:' || topology_id || ') created.';
END
$$;


ALTER FUNCTION topology.st_inittopogeo(atopology character varying) OWNER TO postgres;

--
-- TOC entry 1457 (class 1255 OID 31194)
-- Name: st_modedgeheal(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_modedgeheal(toponame character varying, e1id integer, e2id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  e2rec RECORD;
  rec RECORD;
  connectededges int[];
  commonnode int;
  caseno int;
  topoid int;
  sql text;
  e2sign int;
  eidary int[];
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL OR e2id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS: see if the same edge is given twice..
  IF e1id = e2id THEN
    RAISE EXCEPTION 'Cannot heal edge % with itself, try with another', e1id;
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e2id
      INTO STRICT e2rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e2id;
    -- NOTE: checks for INVALID_SCHEMA_NAME or UNDEFINED_TABLE done before
  END;


  -- NOT IN THE SPECS: See if any of the two edges are closed.
  IF e1rec.start_node = e1rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e1id, e2id;
  END IF;
  IF e2rec.start_node = e2rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e2id, e1id;
  END IF;

  -- Find common node

  IF e1rec.end_node = e2rec.start_node THEN
    commonnode = e1rec.end_node;
    caseno = 1;
  ELSIF e1rec.end_node = e2rec.end_node THEN
    commonnode = e1rec.end_node;
    caseno = 2;
  END IF;

  -- Check if any other edge is connected to the common node
  IF commonnode IS NOT NULL THEN
    FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
      || '.edge_data WHERE ( edge_id != ' || e1id
      || ' AND edge_id != ' || e2id || ') AND ( start_node = '
      || commonnode || ' OR end_node = ' || commonnode || ' )'
    LOOP
      commonnode := NULL;
      connectededges = connectededges || rec.edge_id;
    END LOOP;
  END IF;

  IF commonnode IS NULL THEN
    IF e1rec.start_node = e2rec.start_node THEN
      commonnode = e1rec.start_node;
      caseno = 3;
    ELSIF e1rec.start_node = e2rec.end_node THEN
      commonnode = e1rec.start_node;
      caseno = 4;
    END IF;

    -- Check if any other edge is connected to the common node
    IF commonnode IS NOT NULL THEN
      FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
        || '.edge_data WHERE ( edge_id != ' || e1id
        || ' AND edge_id != ' || e2id || ') AND ( start_node = '
        || commonnode || ' OR end_node = ' || commonnode || ' )'
      LOOP
        commonnode := NULL;
        connectededges = connectededges || rec.edge_id;
      END LOOP;
    END IF;
  END IF;

  IF commonnode IS NULL THEN
    IF connectededges IS NOT NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - other edges connected (%)', array_to_string(connectededges, ',');
    ELSE
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-connected edges';
    END IF;
  END IF;

  -- NOT IN THE SPECS:
  -- check if any topo_geom is defined only by one of the
  -- input edges. In such case there would be no way to adapt
  -- the definition in case of healing, so we'd have to bail out
  eidary = ARRAY[e1id, e2id];
  sql := 'SELECT t.* from ('
    || 'SELECT r.topogeo_id, r.layer_id'
    || ', l.schema_name, l.table_name, l.feature_column'
    || ', array_agg(abs(r.element_id)) as elems '
    || 'FROM topology.layer l INNER JOIN '
    || quote_ident(toponame)
    || '.relation r ON (l.layer_id = r.layer_id) '
    || 'WHERE l.level = 0 AND l.feature_type = 2 '
    || ' AND l.topology_id = ' || topoid
    || ' AND abs(r.element_id) IN (' || e1id || ',' || e2id || ') '
    || 'group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
    || ' l.feature_column ) t WHERE NOT t.elems @> '
    || quote_literal(eidary);
  --RAISE DEBUG 'SQL: %', sql;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing edges % and %',
          rec.topogeo_id, rec.layer_id,
          rec.schema_name, rec.table_name, rec.feature_column,
          e1id, e2id;
  END LOOP;

  -- Update data of the first edge {
  rec := e1rec;
  IF caseno = 1 THEN -- e1.end = e2.start
    rec.geom = ST_MakeLine(e1rec.geom, e2rec.geom);
    rec.end_node = e2rec.end_node;
    rec.next_left_edge = e2rec.next_left_edge;
    e2sign = 1;
  ELSIF caseno = 2 THEN -- e1.end = e2.end
    rec.geom = ST_MakeLine(e1rec.geom, st_reverse(e2rec.geom));
    rec.end_node = e2rec.start_node;
    rec.next_left_edge = e2rec.next_right_edge;
    e2sign = -1;
  ELSIF caseno = 3 THEN -- e1.start = e2.start
    rec.geom = ST_MakeLine(st_reverse(e2rec.geom), e1rec.geom);
    rec.start_node = e2rec.end_node;
    rec.next_right_edge = e2rec.next_left_edge;
    e2sign = -1;
  ELSIF caseno = 4 THEN -- e1.start = e2.end
    rec.geom = ST_MakeLine(e2rec.geom, e1rec.geom);
    rec.start_node = e2rec.start_node;
    rec.next_right_edge = e2rec.next_right_edge;
    e2sign = 1;
  END IF;
  EXECUTE 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET geom = ' || quote_literal(rec.geom::text)
    || ', start_node = ' || rec.start_node
    || ', end_node = ' || rec.end_node
    || ', next_left_edge = ' || rec.next_left_edge
    || ', abs_next_left_edge = ' || abs(rec.next_left_edge)
    || ', next_right_edge = ' || rec.next_right_edge
    || ', abs_next_right_edge = ' || abs(rec.next_right_edge)
    || ' WHERE edge_id = ' || e1id;
  -- End of first edge update }

  -- Update next_left_edge/next_right_edge for
  -- any edge having them still pointing at the edge being removed (e2id)
  --
  -- NOTE:
  -- *(next_XXX_edge/e2id) serves the purpose of extracting existing
  -- sign from the value, while *e2sign changes that sign again if we
  -- reverted edge2 direction
  --
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || e1id
    || ', next_left_edge = ' || e2sign*e1id
    || '*(next_left_edge/'
    || e2id || ')  WHERE abs_next_left_edge = ' || e2id;
  IF e2rec.start_node = commonnode THEN
    sql := sql || ' AND end_node = ' || e2rec.end_node;
  ELSE
    sql := sql || ' AND end_node = ' || e2rec.start_node;
  END IF;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || e1id
    || ', next_right_edge = ' || e2sign*e1id
    || '*(next_right_edge/'
    || e2id || ') WHERE abs_next_right_edge = ' || e2id;
  IF e2rec.start_node = commonnode THEN
    sql := sql || ' AND start_node = ' || e2rec.end_node;
  ELSE
    sql := sql || ' AND start_node = ' || e2rec.start_node;
  END IF;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  -- Delete the second edge
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e2id;

  -- Delete the common node 
  BEGIN
    EXECUTE 'DELETE FROM ' || quote_ident(toponame)
            || '.node WHERE node_id = ' || commonnode;
    EXCEPTION
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing node table)',
          toponame;
  END;

  --
  -- NOT IN THE SPECS:
  -- Drop composition rows involving second
  -- edge, as the first edge took its space,
  -- and all affected TopoGeom have been previously checked
  -- for being composed by both edges.
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.relation r USING topology.layer l '
    || 'WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  RETURN commonnode;
END
$$;


ALTER FUNCTION topology.st_modedgeheal(toponame character varying, e1id integer, e2id integer) OWNER TO postgres;

--
-- TOC entry 1466 (class 1255 OID 31209)
-- Name: st_modedgesplit(character varying, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_modedgesplit(atopology character varying, anedge integer, apoint public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldedge RECORD;
  rec RECORD;
  tmp integer;
  topoid integer;
  nodeid integer;
  nodepos float8;
  newedgeid integer;
  newedge1 geometry;
  newedge2 geometry;
  query text;
  ok BOOL;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL OR anedge IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR oldedge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check that given point is Within(anedge.geom)
  -- 
  IF NOT ST_Within(apoint, oldedge.geom) THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - point not on edge';
  END IF;

  --
  -- Check if a coincident node already exists
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node ' ||
    'WHERE geom && '
    || quote_literal(apoint::text) || '::geometry'
    ||' AND ST_X(geom) = ST_X('
    || quote_literal(apoint::text) || '::geometry)'
    ||' AND ST_Y(geom) = ST_Y('
    ||quote_literal(apoint::text)||'::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Get new node id
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.node_node_id_seq'')'
  LOOP
    nodeid = rec.nextval;
  END LOOP;

  --RAISE NOTICE 'Next node id = % ', nodeid;

  --
  -- Add the new node 
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.node(node_id, geom) 
    VALUES('||nodeid||','||quote_literal(apoint::text)||
    ')';

  --
  -- Compute new edge
  --
  newedge2 := ST_Split(oldedge.geom, apoint);
  newedge1 := ST_GeometryN(newedge2, 1);
  newedge2 := ST_GeometryN(newedge2, 2);

  --
  -- Get ids for the new edge
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    newedgeid = rec.nextval;
  END LOOP;


  --
  -- Insert the new edge
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge '
    || '(edge_id, start_node, end_node,'
    || 'next_left_edge, next_right_edge,'
    || 'left_face, right_face, geom) '
    || 'VALUES('
    || newedgeid
    || ',' || nodeid
    || ',' || oldedge.end_node
    || ',' || COALESCE(                      -- next_left_edge
                NULLIF(
                  oldedge.next_left_edge,
                  -anedge
                ),
                -newedgeid
              )
    || ',' || -anedge                        -- next_right_edge
    || ',' || oldedge.left_face              -- left_face
    || ',' || oldedge.right_face             -- right_face
    || ',' || quote_literal(newedge2::text)  -- geom
    ||')';

  --
  -- Update the old edge
  --
  EXECUTE 'UPDATE ' || quote_ident(atopology) || '.edge_data '
    || ' SET geom = ' || quote_literal(newedge1::text)
    || ','
    || ' next_left_edge = ' || newedgeid
    || ', abs_next_left_edge = ' || newedgeid
    || ','
    || ' end_node = ' || nodeid
    || ' WHERE edge_id = ' || anedge;


  --
  -- Update all next edge references to match new layout
  --

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_right_edge = '
    || -newedgeid 
    || ','
    || ' abs_next_right_edge = ' || newedgeid
    || ' WHERE edge_id != ' || newedgeid
    || ' AND next_right_edge = ' || -anedge
    || ' AND start_node = ' || oldedge.end_node;

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET '
    || ' next_left_edge = ' || -newedgeid
    || ','
    || ' abs_next_left_edge = ' || newedgeid
    || ' WHERE edge_id != ' || newedgeid
    || ' AND next_left_edge = ' || -anedge
    || ' AND end_node = ' || oldedge.end_node;

  --
  -- Update references in the Relation table.
  -- We only take into considerations non-hierarchical
  -- TopoGeometry here, for obvious reasons.
  --
  FOR rec IN EXECUTE 'SELECT r.* FROM '
    || quote_ident(atopology)
    || '.relation r, topology.layer l '
    || ' WHERE '
    || ' l.topology_id = ' || topoid
    || ' AND l.level = 0 '
    || ' AND l.layer_id = r.layer_id '
    || ' AND abs(r.element_id) = ' || anedge
    || ' AND r.element_type = 2'
  LOOP
    --RAISE NOTICE 'TopoGeometry % in layer % contains the edge being split (%) - updating to add new edge %', rec.topogeo_id, rec.layer_id, anedge, newedgeid;

    -- Add new reference to edge1
    IF rec.element_id < 0 THEN
      tmp = -newedgeid;
    ELSE
      tmp = newedgeid;
    END IF;
    query = 'INSERT INTO ' || quote_ident(atopology)
      || '.relation '
      || ' VALUES( '
      || rec.topogeo_id
      || ','
      || rec.layer_id
      || ','
      || tmp
      || ','
      || rec.element_type
      || ')';

    --RAISE NOTICE '%', query;
    EXECUTE query;
  END LOOP;

  --RAISE NOTICE 'Edge % split in edges % and % by node %',
  --  anedge, anedge, newedgeid, nodeid;

  RETURN nodeid; 
END
$$;


ALTER FUNCTION topology.st_modedgesplit(atopology character varying, anedge integer, apoint public.geometry) OWNER TO postgres;

--
-- TOC entry 1463 (class 1255 OID 31203)
-- Name: st_moveisonode(character varying, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_moveisonode(atopology character varying, anode integer, apoint public.geometry) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
BEGIN

  --
  -- All arguments are required
  -- 
  IF atopology IS NULL OR anode IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Apoint must be a point
  --
  IF substring(geometrytype(apoint), 1, 5) != 'POINT'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid point';
  END IF;

  --
  -- Check node isolation.
  -- 
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge ' ||
    ' WHERE start_node =  ' || anode ||
    ' OR end_node = ' || anode 
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - not isolated node';
  END LOOP;

  --
  -- Check if a coincident node already exists
  -- 
  -- We use index AND x/y equality
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node ' ||
    'WHERE geom && ' || quote_literal(apoint::text) || '::geometry'
    ||' AND ST_X(geom) = ST_X('||quote_literal(apoint::text)||'::geometry)'
    ||' AND ST_Y(geom) = ST_Y('||quote_literal(apoint::text)||'::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Check if any edge crosses (intersects) this node
  -- I used _intersects_ here to include boundaries (endpoints)
  --
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge ' 
    || 'WHERE geom && ' || quote_literal(apoint::text) 
    || ' AND ST_Intersects(geom, ' || quote_literal(apoint::text)
    || '::geometry)'
  LOOP
    RAISE EXCEPTION
    'SQL/MM Spatial exception - edge crosses node.';
  END LOOP;

  --
  -- Update node point
  --
  EXECUTE 'UPDATE ' || quote_ident(atopology) || '.node '
    || ' SET geom = ' || quote_literal(apoint::text) 
    || ' WHERE node_id = ' || anode;

  RETURN 'Isolated Node ' || anode || ' moved to location '
    || ST_X(apoint) || ',' || ST_Y(apoint);
END
$$;


ALTER FUNCTION topology.st_moveisonode(atopology character varying, anode integer, apoint public.geometry) OWNER TO postgres;

--
-- TOC entry 1456 (class 1255 OID 31192)
-- Name: st_newedgeheal(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_newedgeheal(toponame character varying, e1id integer, e2id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  e2rec RECORD;
  rec RECORD;
  newedgeid int;
  connectededges int[];
  commonnode int;
  caseno int;
  topoid int;
  sql text;
  e2sign int;
  eidary int[];
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL OR e2id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS: see if the same edge is given twice..
  IF e1id = e2id THEN
    RAISE EXCEPTION 'Cannot heal edge % with itself, try with another', e1id;
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e2id
      INTO STRICT e2rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e2id;
    -- NOTE: checks for INVALID_SCHEMA_NAME or UNDEFINED_TABLE done before
  END;


  -- NOT IN THE SPECS: See if any of the two edges are closed.
  IF e1rec.start_node = e1rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e1id, e2id;
  END IF;
  IF e2rec.start_node = e2rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e2id, e1id;
  END IF;

  -- Find common node

  IF e1rec.end_node = e2rec.start_node THEN
    commonnode = e1rec.end_node;
    caseno = 1;
  ELSIF e1rec.end_node = e2rec.end_node THEN
    commonnode = e1rec.end_node;
    caseno = 2;
  END IF;

  -- Check if any other edge is connected to the common node
  IF commonnode IS NOT NULL THEN
    FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
      || '.edge_data WHERE ( edge_id != ' || e1id
      || ' AND edge_id != ' || e2id || ') AND ( start_node = '
      || commonnode || ' OR end_node = ' || commonnode || ' )'
    LOOP
      commonnode := NULL;
      connectededges = connectededges || rec.edge_id;
    END LOOP;
  END IF;

  IF commonnode IS NULL THEN
    IF e1rec.start_node = e2rec.start_node THEN
      commonnode = e1rec.start_node;
      caseno = 3;
    ELSIF e1rec.start_node = e2rec.end_node THEN
      commonnode = e1rec.start_node;
      caseno = 4;
    END IF;

    -- Check if any other edge is connected to the common node
    IF commonnode IS NOT NULL THEN
      FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
        || '.edge_data WHERE ( edge_id != ' || e1id
        || ' AND edge_id != ' || e2id || ') AND ( start_node = '
        || commonnode || ' OR end_node = ' || commonnode || ' )'
      LOOP
        commonnode := NULL;
        connectededges = connectededges || rec.edge_id;
      END LOOP;
    END IF;
  END IF;

  IF commonnode IS NULL THEN
    IF connectededges IS NOT NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - other edges connected (%)', array_to_string(connectededges, ',');
    ELSE
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-connected edges';
    END IF;
  END IF;

  -- NOT IN THE SPECS:
  -- check if any topo_geom is defined only by one of the
  -- input edges. In such case there would be no way to adapt
  -- the definition in case of healing, so we'd have to bail out
  eidary = ARRAY[e1id, e2id];
  sql := 'SELECT t.* from ('
    || 'SELECT r.topogeo_id, r.layer_id'
    || ', l.schema_name, l.table_name, l.feature_column'
    || ', array_agg(abs(r.element_id)) as elems '
    || 'FROM topology.layer l INNER JOIN '
    || quote_ident(toponame)
    || '.relation r ON (l.layer_id = r.layer_id) '
    || 'WHERE l.level = 0 AND l.feature_type = 2 '
    || ' AND l.topology_id = ' || topoid
    || ' AND abs(r.element_id) IN (' || e1id || ',' || e2id || ') '
    || 'group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
    || ' l.feature_column ) t WHERE NOT t.elems @> '
    || quote_literal(eidary);
  --RAISE DEBUG 'SQL: %', sql;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing edges % and %',
          rec.topogeo_id, rec.layer_id,
          rec.schema_name, rec.table_name, rec.feature_column,
          e1id, e2id;
  END LOOP;

  -- Create new edge {
  rec := e1rec;
  IF caseno = 1 THEN -- e1.end = e2.start
    rec.geom = ST_MakeLine(e1rec.geom, e2rec.geom);
    rec.end_node = e2rec.end_node;
    rec.next_left_edge = e2rec.next_left_edge;
    e2sign = 1;
  ELSIF caseno = 2 THEN -- e1.end = e2.end
    rec.geom = ST_MakeLine(e1rec.geom, st_reverse(e2rec.geom));
    rec.end_node = e2rec.start_node;
    rec.next_left_edge = e2rec.next_right_edge;
    e2sign = -1;
  ELSIF caseno = 3 THEN -- e1.start = e2.start
    rec.geom = ST_MakeLine(st_reverse(e2rec.geom), e1rec.geom);
    rec.start_node = e2rec.end_node;
    rec.next_right_edge = e2rec.next_left_edge;
    e2sign = -1;
  ELSIF caseno = 4 THEN -- e1.start = e2.end
    rec.geom = ST_MakeLine(e2rec.geom, e1rec.geom);
    rec.start_node = e2rec.start_node;
    rec.next_right_edge = e2rec.next_right_edge;
    e2sign = 1;
  END IF;
  -- }

  -- Insert new edge {
  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(toponame) || '.edge_data_edge_id_seq'
    ) || ')' INTO STRICT newedgeid;
  EXECUTE 'INSERT INTO ' || quote_ident(toponame)
    || '.edge VALUES(' || newedgeid
    || ',' || rec.start_node
    || ',' || rec.end_node
    || ',' || rec.next_left_edge
    || ',' || rec.next_right_edge
    || ',' || rec.left_face
    || ',' || rec.right_face
    || ',' || quote_literal(rec.geom::text)
    || ')';
  -- End of new edge insertion }

  -- Update next_left_edge/next_right_edge for
  -- any edge having them still pointing at the edges being removed
  -- (e2id)
  --
  -- NOTE:
  -- *(next_XXX_edge/e2id) serves the purpose of extracting existing
  -- sign from the value, while *e2sign changes that sign again if we
  -- reverted edge2 direction
  --
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || newedgeid
    || ', next_left_edge = ' || e2sign*newedgeid
    || '*(next_left_edge/'
    || e2id || ')  WHERE abs_next_left_edge = ' || e2id;
  IF e2rec.start_node = commonnode THEN
    sql := sql || ' AND end_node = ' || e2rec.end_node;
  ELSE
    sql := sql || ' AND end_node = ' || e2rec.start_node;
  END IF;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || newedgeid
    || ', next_right_edge = ' || e2sign*newedgeid
    || '*(next_right_edge/'
    || e2id || ') WHERE abs_next_right_edge = ' || e2id;
  IF e2rec.start_node = commonnode THEN
    sql := sql || ' AND start_node = ' || e2rec.end_node;
  ELSE
    sql := sql || ' AND start_node = ' || e2rec.start_node;
  END IF;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  -- New edge has the same direction as old edge 1
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || newedgeid
    || ', next_left_edge = ' || newedgeid
    || '*(next_left_edge/'
    || e1id || ')  WHERE abs_next_left_edge = ' || e1id;
  IF e1rec.start_node = commonnode THEN
    sql := sql || ' AND end_node = ' || e1rec.end_node;
  ELSE
    sql := sql || ' AND end_node = ' || e1rec.start_node;
  END IF;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || newedgeid
    || ', next_right_edge = ' || newedgeid
    || '*(next_right_edge/'
    || e1id || ') WHERE abs_next_right_edge = ' || e1id;
  IF e1rec.start_node = commonnode THEN
    sql := sql || ' AND start_node = ' || e1rec.end_node;
  ELSE
    sql := sql || ' AND start_node = ' || e1rec.start_node;
  END IF;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  --
  -- NOT IN THE SPECS:
  -- Replace composition rows involving the two
  -- edges as one involving the new edge.
  -- It takes a DELETE and an UPDATE to do all
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.relation r USING topology.layer l '
    || 'WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.relation r '
    || ' SET element_id = ' || newedgeid || '*(element_id/'
    || e1id
    || ') FROM topology.layer l WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e1id
  ;
  EXECUTE sql;


  -- Delete both edges
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e2id;
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;

  -- Delete the common node 
  BEGIN
    EXECUTE 'DELETE FROM ' || quote_ident(toponame)
            || '.node WHERE node_id = ' || commonnode;
    EXCEPTION
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing node table)',
          toponame;
  END;

  RETURN newedgeid;
END
$$;


ALTER FUNCTION topology.st_newedgeheal(toponame character varying, e1id integer, e2id integer) OWNER TO postgres;

--
-- TOC entry 1465 (class 1255 OID 31207)
-- Name: st_newedgessplit(character varying, integer, public.geometry); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_newedgessplit(atopology character varying, anedge integer, apoint public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldedge RECORD;
  rec RECORD;
  tmp integer;
  topoid integer;
  nodeid integer;
  nodepos float8;
  edgeid1 integer;
  edgeid2 integer;
  edge1 geometry;
  edge2 geometry;
  ok BOOL;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL OR anedge IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;
  
  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR oldedge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check that given point is Within(anedge.geom)
  -- 
  IF NOT ST_Within(apoint, oldedge.geom) THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - point not on edge';
  END IF;

  --
  -- Check if a coincident node already exists
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node '
    || 'WHERE geom && '
    || quote_literal(apoint::text) || '::geometry'
    || ' AND ST_X(geom) = ST_X('
    || quote_literal(apoint::text) || '::geometry)'
    || ' AND ST_Y(geom) = ST_Y('
    || quote_literal(apoint::text) || '::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Get new node id
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.node_node_id_seq'')'
  LOOP
    nodeid = rec.nextval;
  END LOOP;

  --RAISE NOTICE 'Next node id = % ', nodeid;

  --
  -- Add the new node 
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.node(node_id, geom) 
    VALUES(' || nodeid || ','
    || quote_literal(apoint::text)
    || ')';

  --
  -- Delete the old edge
  --
  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.edge_data '
    || ' WHERE edge_id = ' || anedge;

  --
  -- Compute new edges
  --
  edge2 := ST_Split(oldedge.geom, apoint);
  edge1 := ST_GeometryN(edge2, 1);
  edge2 := ST_GeometryN(edge2, 2);

  --
  -- Get ids for the new edges 
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    edgeid1 = rec.nextval;
  END LOOP;
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    edgeid2 = rec.nextval;
  END LOOP;


  --RAISE NOTICE 'EdgeId1 % EdgeId2 %', edgeid1, edgeid2;

  --RAISE DEBUG 'oldedge.next_left_edge: %', oldedge.next_left_edge;
  --RAISE DEBUG 'oldedge.next_right_edge: %', oldedge.next_right_edge;

  --
  -- Insert the two new edges
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge VALUES('
    || edgeid1                                -- edge_id
    || ',' || oldedge.start_node              -- start_node
    || ',' || nodeid                          -- end_node
    || ',' || edgeid2                         -- next_left_edge
    || ',' || CASE                            -- next_right_edge
               WHEN 
                oldedge.next_right_edge = anedge
               THEN edgeid1
               WHEN
                oldedge.next_right_edge = -anedge
               THEN -edgeid2
               ELSE oldedge.next_right_edge
              END
    || ',' || oldedge.left_face               -- left_face
    || ',' || oldedge.right_face              -- right_face
    || ',' || quote_literal(edge1::text)      -- geom
    ||')';

  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge VALUES('
    || edgeid2                                -- edge_id
    || ',' || nodeid                          -- start_node
    || ',' || oldedge.end_node                -- end_node
    || ',' || CASE                            -- next_left_edge
               WHEN 
                oldedge.next_left_edge =
                -anedge
               THEN -edgeid2
               WHEN 
                oldedge.next_left_edge =
                anedge
               THEN edgeid1
               ELSE oldedge.next_left_edge
              END
    || ',' || -edgeid1                        -- next_right_edge
    || ',' || oldedge.left_face               -- left_face
    || ',' || oldedge.right_face              -- right_face
    || ',' || quote_literal(edge2::text)      -- geom
    ||')';

  --
  -- Update all next edge references to match new layout
  --

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_right_edge = '
    || edgeid2
    || ','
    || ' abs_next_right_edge = ' || edgeid2
    || ' WHERE next_right_edge = ' || anedge
    || ' AND start_node = ' || oldedge.start_node
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;
  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_right_edge = '
    || -edgeid1
    || ','
    || ' abs_next_right_edge = ' || edgeid1
    || ' WHERE next_right_edge = ' || -anedge
    || ' AND start_node = ' || oldedge.end_node
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_left_edge = '
    || edgeid1
    || ','
    || ' abs_next_left_edge = ' || edgeid1
    || ' WHERE next_left_edge = ' || anedge
    || ' AND end_node = ' || oldedge.start_node
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;
  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET '
    || ' next_left_edge = ' || -edgeid2
    || ','
    || ' abs_next_left_edge = ' || edgeid2
    || ' WHERE next_left_edge = ' || -anedge
    || ' AND end_node = ' || oldedge.end_node
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;

  --
  -- Update references in the Relation table.
  -- We only take into considerations non-hierarchical
  -- TopoGeometry here, for obvious reasons.
  --
  FOR rec IN EXECUTE 'SELECT r.* FROM '
    || quote_ident(atopology)
    || '.relation r, topology.layer l '
    || ' WHERE '
    || ' l.topology_id = ' || topoid
    || ' AND l.level = 0 '
    || ' AND l.layer_id = r.layer_id '
    || ' AND abs(r.element_id) = ' || anedge
    || ' AND r.element_type = 2'
  LOOP
    --RAISE NOTICE 'TopoGeometry % in layer % contains the edge being split', rec.topogeo_id, rec.layer_id;

    -- Delete old reference
    EXECUTE 'DELETE FROM ' || quote_ident(atopology)
      || '.relation '
      || ' WHERE '
      || 'layer_id = ' || rec.layer_id
      || ' AND '
      || 'topogeo_id = ' || rec.topogeo_id
      || ' AND '
      || 'element_type = ' || rec.element_type
      || ' AND '
      || 'abs(element_id) = ' || anedge;

    -- Add new reference to edge1
    IF rec.element_id < 0 THEN
      tmp = -edgeid1;
    ELSE
      tmp = edgeid1;
    END IF;
    EXECUTE 'INSERT INTO ' || quote_ident(atopology)
      || '.relation '
      || ' VALUES( '
      || rec.topogeo_id
      || ','
      || rec.layer_id
      || ','
      || tmp
      || ','
      || rec.element_type
      || ')';

    -- Add new reference to edge2
    IF rec.element_id < 0 THEN
      tmp = -edgeid2;
    ELSE
      tmp = edgeid2;
    END IF;
    EXECUTE 'INSERT INTO ' || quote_ident(atopology)
      || '.relation '
      || ' VALUES( '
      || rec.topogeo_id
      || ','
      || rec.layer_id
      || ','
      || tmp
      || ','
      || rec.element_type
      || ')';
      
  END LOOP;

  --RAISE NOTICE 'Edge % split in edges % and % by node %',
  --  anedge, edgeid1, edgeid2, nodeid;

  RETURN nodeid; 
END
$$;


ALTER FUNCTION topology.st_newedgessplit(atopology character varying, anedge integer, apoint public.geometry) OWNER TO postgres;

--
-- TOC entry 1460 (class 1255 OID 31199)
-- Name: st_remedgemodface(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_remedgemodface(toponame character varying, e1id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  rec RECORD;
  fidary int[];
  topoid int;
  sql text;
  floodfaceid int;
  elink int;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  -- NOT IN THE SPECS:
  -- Check that no TopoGeometry references the edge being removed
  PERFORM topology._ST_RemEdgeCheck(toponame, topoid, e1id, e1rec.left_face, e1rec.right_face);

  -- Update next_left_edge and next_right_edge face
  -- for all edges bounding the new face
  RAISE NOTICE 'Updating next_{right,left}_face of ring edges...';

  -- TODO: reduce the following to 2 UPDATE rather than 4

  -- Update next_left_edge of previous edges in left face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge < 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge > 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  -- Update next_right_edge of previous edges in right face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge < 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge > 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  IF e1rec.left_face = e1rec.right_face THEN -- {

    floodfaceid = e1rec.left_face; 

  ELSE -- }{

    IF e1rec.left_face = 0 OR e1rec.right_face = 0 THEN -- {

      --
      -- We won't add any new face, but rather let the universe
      -- flood the removed face.
      --

      floodfaceid = 0;

    ELSE -- }{

      -- we choose right face as the face that will remain
      -- to be symmetric with ST_AddEdgeModFace 
      floodfaceid = e1rec.right_face;

      sql := 'UPDATE '
        || quote_ident(toponame)
        || '.face SET mbr = (SELECT '
        -- minimum bounding rectangle is the union of the old faces mbr
        -- (doing this without GEOS would be faster)
        || 'ST_Envelope(ST_Union(mbr)) FROM '
        || quote_ident(toponame)
        || '.face WHERE face_id IN (' 
        || e1rec.left_face || ',' || e1rec.right_face 
        || ') ) WHERE face_id = ' || floodfaceid ;
      EXECUTE sql;

    END IF; -- }

    -- Update left_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET left_face = ' || floodfaceid 
      || ' WHERE left_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update right_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET right_face = ' || floodfaceid 
      || ' WHERE right_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update containing_face for all nodes still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.node SET containing_face = ' || floodfaceid 
      || ' WHERE containing_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- NOT IN THE SPECS:
    -- Replace composition rows involving the two
    -- faces as one involving the new face.
    -- It takes a single DELETE to do that.
    sql := 'DELETE FROM ' || quote_ident(toponame)
      || '.relation r USING topology.layer l '
      || 'WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND abs(r.element_id) IN ('
      || e1rec.left_face || ',' || e1rec.right_face
      || ') AND abs(r.element_id) != '
      || floodfaceid; -- could be optimized..
    EXECUTE sql;

  END IF; -- } two faces healed...

  -- Delete the edge
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;
  EXECUTE sql;

  -- Check if any of the edge nodes remains isolated, 
  -- set containing_face  = floodfaceid in that case
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.node n SET containing_face = ' || floodfaceid
    || ' WHERE node_id IN ('
    || e1rec.start_node || ','
    || e1rec.end_node || ') AND NOT EXISTS (SELECT edge_id FROM '
    || quote_ident(toponame)
    || '.edge_data WHERE start_node = n.node_id OR end_node = n.node_id)';
  EXECUTE sql;

  IF e1rec.right_face != e1rec.left_face THEN -- {

    -- Delete left face, if not universe and not "flood" face
    IF e1rec.left_face != 0 AND e1rec.left_face != floodfaceid
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.left_face; 
      EXECUTE sql;
    END IF;

    -- Delete right face, if not universe and not "flood" face
    IF e1rec.right_face != 0 AND e1rec.right_face != floodfaceid
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.right_face;
      EXECUTE sql;
    END IF;

  END IF; -- }

  RETURN floodfaceid;
END
$$;


ALTER FUNCTION topology.st_remedgemodface(toponame character varying, e1id integer) OWNER TO postgres;

--
-- TOC entry 1459 (class 1255 OID 31197)
-- Name: st_remedgenewface(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_remedgenewface(toponame character varying, e1id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  rec RECORD;
  fidary int[];
  topoid int;
  sql text;
  newfaceid int;
  newfacecreated bool;
  elink int;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  -- NOT IN THE SPECS:
  -- Check that no TopoGeometry references the edge being removed
  PERFORM topology._ST_RemEdgeCheck(toponame, topoid, e1id, e1rec.left_face, e1rec.right_face);

  -- Update next_left_edge and next_right_edge face
  -- for all edges bounding the new face
  RAISE NOTICE 'Updating next_{right,left}_face of ring edges...';

  -- TODO: reduce the following to 2 UPDATE rather than 4

  -- Update next_left_edge of previous edges in left face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge < 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge > 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  -- Update next_right_edge of previous edges in right face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge < 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge > 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  IF e1rec.left_face = e1rec.right_face THEN -- {

    newfaceid := e1rec.left_face; -- TODO: or what should we return ?
    newfacecreated := false;

  ELSE -- }{

    IF e1rec.left_face = 0 OR e1rec.right_face = 0 THEN -- {

      --
      -- We won't add any new face, but rather let the universe
      -- flood the removed face.
      --

      newfaceid := 0;
      newfacecreated := false;

    ELSE -- }{

      --
      -- Insert the new face 
      --

      sql := 'SELECT nextval(' || quote_literal(
          quote_ident(toponame) || '.face_face_id_seq'
        ) || ')';

      EXECUTE sql INTO STRICT newfaceid;
      newfacecreated := true;

      sql := 'INSERT INTO '
        || quote_ident(toponame)
        || '.face(face_id, mbr) SELECT '
        -- face_id
        || newfaceid  || ', '
        -- minimum bounding rectangle is the union of the old faces mbr
        -- (doing this without GEOS would be faster)
        || 'ST_Envelope(ST_Union(mbr)) FROM '
        || quote_ident(toponame)
        || '.face WHERE face_id IN (' 
        || e1rec.left_face || ',' || e1rec.right_face 
        || ')';
      EXECUTE sql;

    END IF; -- }

    -- Update left_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET left_face = ' || newfaceid 
      || ' WHERE left_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update right_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET right_face = ' || newfaceid 
      || ' WHERE right_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update containing_face for all nodes still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.node SET containing_face = ' || newfaceid 
      || ' WHERE containing_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- NOT IN THE SPECS:
    -- Replace composition rows involving the two
    -- faces as one involving the new face.
    -- It takes a DELETE and an UPDATE to do all
    sql := 'DELETE FROM ' || quote_ident(toponame)
      || '.relation r USING topology.layer l '
      || 'WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
      || e1rec.left_face;
    EXECUTE sql;
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.relation r '
      || ' SET element_id = ' || newfaceid 
      || ' FROM topology.layer l WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND r.element_id = '
      || e1rec.right_face;
    EXECUTE sql;

  END IF; -- } two faces healed...

  -- Delete the edge
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;
  EXECUTE sql;

  -- Check if any of the edge nodes remains isolated, 
  -- set containing_face  = newfaceid in that case
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.node n SET containing_face = ' || newfaceid
    || ' WHERE node_id IN ('
    || e1rec.start_node || ','
    || e1rec.end_node || ') AND NOT EXISTS (SELECT edge_id FROM '
    || quote_ident(toponame)
    || '.edge_data WHERE start_node = n.node_id OR end_node = n.node_id)';
  EXECUTE sql;

  IF e1rec.right_face != e1rec.left_face THEN -- {

    -- Delete left face, if not universe
    IF e1rec.left_face != 0 THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.left_face; 
      EXECUTE sql;
    END IF;

    -- Delete right face, if not universe
    IF e1rec.right_face != 0
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.right_face;
      EXECUTE sql;
    END IF;

  END IF; -- }

  IF newfacecreated THEN
    RETURN newfaceid;
  ELSE
    RETURN NULL; -- -newfaceid;
  END IF;
END
$$;


ALTER FUNCTION topology.st_remedgenewface(toponame character varying, e1id integer) OWNER TO postgres;

--
-- TOC entry 1423 (class 1255 OID 31205)
-- Name: st_remisonode(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_remisonode(character varying, integer) RETURNS text
    LANGUAGE sql
    AS $_$
  SELECT topology.ST_RemoveIsoNode($1, $2)
$_$;


ALTER FUNCTION topology.st_remisonode(character varying, integer) OWNER TO postgres;

--
-- TOC entry 1464 (class 1255 OID 31206)
-- Name: st_removeisoedge(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_removeisoedge(atopology character varying, anedge integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  edge RECORD;
  rec RECORD;
  ok BOOL;
BEGIN

  --
  -- Atopology and anedge are required
  -- 
  IF atopology IS NULL OR anedge IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR edge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check node isolation
  -- 
  IF edge.left_face != edge.right_face THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - not isolated edge';
  END IF;

  FOR rec IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' 
    || ' WHERE edge_id !=  ' || anedge
    || ' AND ( start_node = ' || edge.start_node
    || ' OR start_node = ' || edge.end_node
    || ' OR end_node = ' || edge.start_node
    || ' OR end_node = ' || edge.end_node
    || ' ) '
  LOOP
    RAISE EXCEPTION
      'SQL/MM Spatial exception - not isolated edge';
  END LOOP;

  --
  -- Delete the edge
  --
  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.edge_data '
    || ' WHERE edge_id = ' || anedge;

  RETURN 'Isolated edge ' || anedge || ' removed';
END
$$;


ALTER FUNCTION topology.st_removeisoedge(atopology character varying, anedge integer) OWNER TO postgres;

--
-- TOC entry 1416 (class 1255 OID 31204)
-- Name: st_removeisonode(character varying, integer); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_removeisonode(atopology character varying, anode integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
BEGIN

  --
  -- Atopology and apoint are required
  -- 
  IF atopology IS NULL OR anode IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Check node isolation.
  -- 
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE start_node =  ' || anode ||
    ' OR end_node = ' || anode 
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - not isolated node';
  END LOOP;

  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.node '
    || ' WHERE node_id = ' || anode;

  RETURN 'Isolated node ' || anode || ' removed';
END
$$;


ALTER FUNCTION topology.st_removeisonode(atopology character varying, anode integer) OWNER TO postgres;

--
-- TOC entry 1431 (class 1255 OID 31170)
-- Name: st_simplify(topogeometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION st_simplify(tg topogeometry, tolerance double precision) RETURNS public.geometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  topology_info RECORD;
  layer_info RECORD;
  child_layer_info RECORD;
  geom geometry;
  sql TEXT;
BEGIN

  -- Get topology information
  SELECT id, name FROM topology.topology
    INTO topology_info
    WHERE id = tg.topology_id;
  IF NOT FOUND THEN
      RAISE EXCEPTION 'No topology with id "%" in topology.topology', tg.topology_id;
  END IF;

  -- Get layer info
  SELECT * FROM topology.layer
    WHERE topology_id = tg.topology_id
    AND layer_id = tg.layer_id
    INTO layer_info;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Could not find TopoGeometry layer % in topology %', tg.layer_id, tg.topology_id;
  END IF;

  --
  -- If this feature layer is on any level > 0 we will
  -- compute the topological union of all simplified child
  -- features in fact recursing.
  --
  IF layer_info.level > 0 THEN -- {

    -- Get child layer info
    SELECT * FROM topology.layer WHERE layer_id = layer_info.child_id
      AND topology_id = tg.topology_id
      INTO child_layer_info;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Invalid layer % in topology % (unexistent child layer %)', tg.layer_id, tg.topology_id, layer_info.child_id;
    END IF;

    sql := 'SELECT st_multi(st_union(topology.ST_Simplify('
      || quote_ident(child_layer_info.feature_column)
      || ',' || tolerance || '))) as geom FROM '
      || quote_ident(child_layer_info.schema_name) || '.'
      || quote_ident(child_layer_info.table_name)
      || ', ' || quote_ident(topology_info.name) || '.relation pr'
      || ' WHERE '
      || ' pr.topogeo_id = ' || tg.id
      || ' AND '
      || ' pr.layer_id = ' || tg.layer_id
      || ' AND '
      || ' id('||quote_ident(child_layer_info.feature_column)
      || ') = pr.element_id '
      || ' AND '
      || 'layer_id('||quote_ident(child_layer_info.feature_column)
      || ') = pr.element_type ';
    RAISE DEBUG '%', sql;
    EXECUTE sql INTO geom;

  ELSIF tg.type = 3 THEN -- [multi]polygon -- }{

    -- TODO: use ST_GetFaceEdges
    -- TODO: is st_unaryunion needed?
    sql := 'SELECT st_multi(st_unaryunion(ST_BuildArea(ST_Node(ST_Collect(ST_Simplify(geom, '
      || tolerance || ')))))) as geom FROM '
      || quote_ident(topology_info.name)
      || '.edge_data e, '
      || quote_ident(topology_info.name)
      || '.relation r WHERE ( e.left_face = r.element_id'
      || ' OR e.right_face = r.element_id )'
      || ' AND r.topogeo_id = ' || tg.id
      || ' AND r.layer_id = ' || tg.layer_id
      || ' AND element_type = 3 ';
    RAISE DEBUG '%', sql;
    EXECUTE sql INTO geom;


  ELSIF tg.type = 2 THEN -- [multi]line -- }{

    sql := 
      'SELECT st_multi(ST_LineMerge(ST_Node(ST_Collect(ST_Simplify(e.geom,'
      || tolerance || '))))) as g FROM '
      || quote_ident(topology_info.name) || '.edge e, '
      || quote_ident(topology_info.name) || '.relation r '
      || ' WHERE r.topogeo_id = ' || tg.id
      || ' AND r.layer_id = ' || tg.layer_id
      || ' AND r.element_type = 2 '
      || ' AND abs(r.element_id) = e.edge_id';
    EXECUTE sql INTO geom;
  
  ELSIF tg.type = 1 THEN -- [multi]point -- }{

    -- Can't simplify points... 
    geom := topology.Geometry(tg);

  ELSIF tg.type = 4 THEN -- mixed collection -- }{

   sql := 'WITH areas AS ( '
      || 'SELECT st_multi(st_union(ST_BuildArea(ST_Node(ST_Collect(ST_Simplify(geom, '
      || tolerance || ')))) as geom FROM '
      || quote_ident(topology_info.name)
      || '.edge_data e, '
      || quote_ident(topology_info.name)
      || '.relation r WHERE ( e.left_face = r.element_id'
      || ' OR e.right_face = r.element_id )'
      || ' AND r.topogeo_id = ' || tg.id
      || ' AND r.layer_id = ' || tg.layer_id
      || ' AND element_type = 3 ), '
      || 'lines AS ( '
      || 'SELECT st_multi(ST_LineMerge(ST_Collect(ST_Simplify(e.geom,'
      || tolerance || ')))) as g FROM '
      || quote_ident(topology_info.name) || '.edge e, '
      || quote_ident(topology_info.name) || '.relation r '
      || ' WHERE r.topogeo_id = ' || tg.id
      || ' AND r.layer_id = ' || tg.layer_id
      || ' AND r.element_type = 2 '
      || ' AND abs(r.element_id) = e.edge_id ), '
      || ' points as ( SELECT st_union(n.geom) as g FROM '
      || quote_ident(topology_info.name) || '.node n, '
      || quote_ident(topology_info.name) || '.relation r '
      || ' WHERE r.topogeo_id = ' || tg.id
      || ' AND r.layer_id = ' || tg.layer_id
      || ' AND r.element_type = 1 '
      || ' AND r.element_id = n.node_id ), '
      || ' un as ( SELECT g FROM areas UNION ALL SELECT g FROM lines '
      || '          UNION ALL SELECT g FROM points ) '
      || 'SELECT ST_Multi(ST_Collect(g)) FROM un';
    EXECUTE sql INTO geom;

  ELSE -- }{

    RAISE EXCEPTION 'Invalid TopoGeometries (unknown type %)', tg.type;

  END IF; -- }

  RETURN geom;

END
$$;


ALTER FUNCTION topology.st_simplify(tg topogeometry, tolerance double precision) OWNER TO postgres;

--
-- TOC entry 1437 (class 1255 OID 31165)
-- Name: topoelementarray_append(topoelementarray, topoelement); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION topoelementarray_append(topoelementarray, topoelement) RETURNS topoelementarray
    LANGUAGE sql IMMUTABLE
    AS $_$
	SELECT CASE
		WHEN $1 IS NULL THEN
			topology.TopoElementArray('{' || $2::text || '}')
		ELSE
			topology.TopoElementArray($1::int[][]||$2::int[])
		END;
$_$;


ALTER FUNCTION topology.topoelementarray_append(topoelementarray, topoelement) OWNER TO postgres;

--
-- TOC entry 1435 (class 1255 OID 31163)
-- Name: topogeo_addgeometry(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION topogeo_addgeometry(atopology character varying, ageom public.geometry, tolerance double precision DEFAULT 0) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	RAISE EXCEPTION 'TopoGeo_AddGeometry not implemented yet';
END
$$;


ALTER FUNCTION topology.topogeo_addgeometry(atopology character varying, ageom public.geometry, tolerance double precision) OWNER TO postgres;

--
-- TOC entry 1433 (class 1255 OID 31160)
-- Name: topogeo_addlinestring(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION topogeo_addlinestring(atopology character varying, aline public.geometry, tolerance double precision DEFAULT 0) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  rec2 RECORD;
  sql TEXT;
  set1 GEOMETRY;
  set2 GEOMETRY;
  snapped GEOMETRY;
  noded GEOMETRY;
  start_node INTEGER;
  end_node INTEGER;
  id INTEGER; 
  inodes GEOMETRY;
  iedges GEOMETRY;
  tol float8;
BEGIN

  -- 0. Check arguments
  IF geometrytype(aline) != 'LINESTRING' THEN
    RAISE EXCEPTION 'Invalid geometry type (%) passed to TopoGeo_AddLinestring, expected LINESTRING', geometrytype(aline);
  END IF;

  -- Get tolerance, if 0 was given
  tol := COALESCE( NULLIF(tolerance, 0), topology._st_mintolerance(atopology, aline) );

  -- 1. Self-node
  noded := ST_UnaryUnion(aline);

  -- 2. Node to edges falling within tol distance
  sql := 'WITH nearby AS ( SELECT e.geom FROM '
    || quote_ident(atopology) 
    || '.edge e WHERE ST_DWithin(e.geom, '
    || quote_literal(noded::text)
    || '::geometry, '
    || tol || ') ) SELECT st_collect(geom) FROM nearby;';
  EXECUTE sql INTO iedges;
  IF iedges IS NOT NULL THEN


    snapped := ST_Snap(noded, iedges, tol);

    noded := ST_Difference(snapped, iedges);

    set1 := ST_Intersection(snapped, iedges);

    set2 := ST_LineMerge(set1);

    noded := ST_Union(noded, set2);

  END IF;

  -- 2.1. Node with existing nodes within tol
  -- TODO: check if we should be only considering _isolated_ nodes!
  sql := 'WITH nearby AS ( SELECT n.geom FROM '
    || quote_ident(atopology) 
    || '.node n WHERE ST_DWithin(n.geom, '
    || quote_literal(noded::text)
    || '::geometry, '
    || tol || ') ) SELECT st_collect(geom) FROM nearby;';
  EXECUTE sql INTO inodes;

  IF inodes IS NOT NULL THEN -- {

    -- TODO: consider snapping once against all elements
    ---      (rather than once with edges and once with nodes)
    noded := ST_Snap(noded, inodes, tol);

    FOR rec IN SELECT (ST_Dump(inodes)).geom
    LOOP
        -- Use the node to split edges
        SELECT ST_Collect(geom) 
        FROM ST_Dump(ST_Split(noded, rec.geom))
        INTO STRICT noded;
    END LOOP;

    -- re-node to account for ST_Snap introduced self-intersections
    -- See http://trac.osgeo.org/postgis/ticket/1714
    -- TODO: consider running UnaryUnion once after all noding 
    noded := ST_UnaryUnion(noded);
  END IF; -- }

  -- 3. For each (now-noded) segment, insert an edge
  FOR rec IN SELECT (ST_Dump(noded)).geom LOOP

    -- TODO: skip point elements ?


    start_node := topology.TopoGeo_AddPoint(atopology,
                                          ST_StartPoint(rec.geom),
                                          tol);

    end_node := topology.TopoGeo_AddPoint(atopology,
                                        ST_EndPoint(rec.geom),
                                        tol);

    -- Added endpoints may have drifted due to tolerance, so
    -- we need to re-snap the edge to the new nodes before adding it
    sql := 'SELECT n1.geom as sn, n2.geom as en FROM ' || quote_ident(atopology)
      || '.node n1, ' || quote_ident(atopology)
      || '.node n2 WHERE n1.node_id = '
      || start_node || ' AND n2.node_id = ' || end_node;

    EXECUTE sql INTO STRICT rec2;

    snapped := ST_SetPoint(
                 ST_SetPoint(rec.geom, ST_NPoints(rec.geom)-1, rec2.en),
                 0, rec2.sn);

    
    snapped := ST_CollectionExtract(ST_MakeValid(snapped), 2);


    -- Check if the so-snapped edge collapsed (see #1650)
    IF ST_IsEmpty(snapped) THEN
      CONTINUE;
    END IF;

    -- Check if the so-snapped edge _now_ exists
    sql := 'SELECT edge_id FROM ' || quote_ident(atopology)
      || '.edge_data WHERE ST_Equals(geom, ' || quote_literal(snapped::text)
      || '::geometry)';
    EXECUTE sql INTO id;
    IF id IS NULL THEN
      id := topology.ST_AddEdgeModFace(atopology, start_node, end_node,
                                       snapped);
    ELSE
    END IF;

    RETURN NEXT id;

  END LOOP;

  RETURN;
END
$$;


ALTER FUNCTION topology.topogeo_addlinestring(atopology character varying, aline public.geometry, tolerance double precision) OWNER TO postgres;

--
-- TOC entry 1432 (class 1255 OID 31159)
-- Name: topogeo_addpoint(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION topogeo_addpoint(atopology character varying, apoint public.geometry, tolerance double precision DEFAULT 0) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  id integer;
  rec RECORD;
  sql text;
  prj GEOMETRY;
  snapedge GEOMETRY;
  snaptol FLOAT8;
  tol FLOAT8;
  z FLOAT8;
BEGIN

  -- 0. Check arguments
  IF geometrytype(apoint) != 'POINT' THEN
    RAISE EXCEPTION 'Invalid geometry type (%) passed to TopoGeo_AddPoint, expected POINT', geometrytype(apoint);
  END IF;

  -- Get tolerance, if 0 was given
  tol := COALESCE( NULLIF(tolerance, 0), topology._st_mintolerance(atopology, apoint) );

  -- 1. Check if any existing node is closer than the given precision
  --    and if so pick the closest
  sql := 'SELECT a.node_id FROM ' 
    || quote_ident(atopology) 
    || '.node as a WHERE ST_DWithin(a.geom,'
    || quote_literal(apoint::text) || '::geometry,'
    || tol || ') AND ST_Distance('
    || quote_literal(apoint::text)
    || '::geometry, a.geom) < ' || tol || ' ORDER BY ST_Distance('
    || quote_literal(apoint::text)
    || '::geometry, a.geom) LIMIT 1;';
  EXECUTE sql INTO id;
  IF id IS NOT NULL THEN
    RETURN id;
  END IF;


  -- 2. Check if any existing edge falls within tolerance
  --    and if so split it by a point projected on it
  sql := 'SELECT a.edge_id, a.geom FROM ' 
    || quote_ident(atopology) 
    || '.edge as a WHERE ST_DWithin(a.geom,'
    || quote_literal(apoint::text) || '::geometry,'
    || tol || ') ORDER BY ST_Distance('
    || quote_literal(apoint::text)
    || '::geometry, a.geom) LIMIT 1;';
  EXECUTE sql INTO rec;
  IF rec IS NOT NULL THEN
    -- project point to line, split edge by point
    prj := ST_ClosestPoint(rec.geom, apoint);
    -- This is a workaround for ClosestPoint lack of Z support:
    -- http://trac.osgeo.org/postgis/ticket/2033
    z := ST_Z(apoint);
    IF z IS NOT NULL THEN
      prj := ST_Translate(ST_Force_3DZ(prj), 0, 0, z); -- no ST_SetZ ...
    END IF;
    IF NOT ST_Contains(rec.geom, prj) THEN
      -- The tolerance must be big enough for snapping to happen
      -- and small enough to snap only to the projected point.
      -- Unfortunately ST_Distance returns 0 because it also uses
      -- a projected point internally, so we need another way.
      snaptol := topology._st_mintolerance(prj);
      snapedge := ST_Snap(rec.geom, prj, snaptol);

      -- Snapping currently snaps the first point below tolerance
      -- so may possibly move first point. See ticket #1631
      IF NOT ST_Equals(ST_StartPoint(rec.geom), ST_StartPoint(snapedge))
      THEN
        snapedge := ST_MakeLine(ST_StartPoint(rec.geom), snapedge);
      END IF;

      PERFORM topology.ST_ChangeEdgeGeom(atopology, rec.edge_id, snapedge);
    END IF;
    id := topology.ST_ModEdgeSplit(atopology, rec.edge_id, prj);
  ELSE
    id := topology.ST_AddIsoNode(atopology, NULL, apoint);
  END IF;

  RETURN id;
END
$$;


ALTER FUNCTION topology.topogeo_addpoint(atopology character varying, apoint public.geometry, tolerance double precision) OWNER TO postgres;

--
-- TOC entry 1434 (class 1255 OID 31162)
-- Name: topogeo_addpolygon(character varying, public.geometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION topogeo_addpolygon(atopology character varying, apoly public.geometry, tolerance double precision DEFAULT 0) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  boundary GEOMETRY;
  fgeom GEOMETRY;
  rec RECORD;
  edges INTEGER[];
  sql TEXT;
  tol FLOAT8;
BEGIN

  -- 0. Check arguments
  IF geometrytype(apoly) != 'POLYGON' THEN
    RAISE EXCEPTION 'Invalid geometry type (%) passed to TopoGeo_AddPolygon, expected POLYGON', geometrytype(apoly);
  END IF;

  -- Get tolerance, if 0 was given
  tol := COALESCE( NULLIF(tolerance, 0), topology._st_mintolerance(atopology, apoly) );

  -- 1. Extract boundary
  boundary := ST_Boundary(apoly);

  -- 2. Add boundaries as edges
  FOR rec IN SELECT (ST_Dump(boundary)).geom LOOP
    edges := array_cat(edges, array_agg(x)) FROM ( select topology.TopoGeo_addLinestring(atopology, rec.geom, tol) as x ) as foo;
  END LOOP;

  -- 3. Find faces covered by input polygon
  --    NOTE: potential snapping changed polygon edges
  sql := 'SELECT f.face_id FROM ' || quote_ident(atopology)
    || '.face f WHERE f.mbr && '
    || quote_literal(apoly::text)
    || '::geometry';
  FOR rec IN EXECUTE sql LOOP
    -- check for actual containment
    fgeom := ST_PointOnSurface(topology.ST_GetFaceGeometry(atopology, rec.face_id));
    IF NOT ST_Covers(apoly, fgeom) THEN
      CONTINUE;
    END IF;
    RETURN NEXT rec.face_id;
  END LOOP;

END
$$;


ALTER FUNCTION topology.topogeo_addpolygon(atopology character varying, apoly public.geometry, tolerance double precision) OWNER TO postgres;

--
-- TOC entry 1417 (class 1255 OID 31144)
-- Name: topologysummary(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION topologysummary(atopology character varying) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
  rec RECORD;
  rec2 RECORD;
  var_topology_id integer;
  n int4;
  missing int4;
  sql text;
  ret text;
  tgcount int4;
BEGIN

  ret := 'Topology ' || quote_ident(atopology) ;

  BEGIN
    SELECT * FROM topology.topology WHERE name = atopology INTO STRICT rec;
    -- TODO: catch <no_rows> to give a nice error message
    var_topology_id := rec.id;

    ret := ret || ' (id ' || rec.id || ', '
               || 'SRID ' || rec.srid || ', '
               || 'precision ' || rec.precision;
    IF rec.hasz THEN ret := ret || ', has Z'; END IF;
    ret := ret || E')\n';
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ret := ret || E' (unregistered)\n';
  END;

  BEGIN
    EXECUTE 'SELECT count(*) FROM ' || quote_ident(atopology)
      || '.node ' INTO STRICT n;
    ret = ret || n || ' nodes, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      IF NOT EXISTS (
          SELECT * FROM pg_catalog.pg_namespace WHERE nspname = atopology
         )
      THEN
        ret = ret || 'missing schema';
        RETURN ret; 
      ELSE
        ret = ret || 'missing nodes, ';
      END IF;
  END;

  BEGIN
    EXECUTE 'SELECT count(*) FROM ' || quote_ident(atopology)
      || '.edge' INTO STRICT n;
    ret = ret || n || ' edges, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'missing edges, ';
  END;

  BEGIN
    EXECUTE 'SELECT count(*) FROM ' || quote_ident(atopology)
      || '.face' INTO STRICT n;
    ret = ret || greatest(n-1,0) || ' faces, '; -- -1 is face=0
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'missing faces, ';
  END;

  BEGIN
    EXECUTE 'SELECT count(distinct layer_id) AS ln, '
      || 'count(distinct (layer_id,topogeo_id)) AS tn FROM '
      || quote_ident(atopology) || '.relation' INTO STRICT rec;
    tgcount := rec.tn;
    ret = ret || rec.tn || ' topogeoms in ' || rec.ln || E' layers\n';
  EXCEPTION
    WHEN UNDEFINED_TABLE THEN
      ret = ret || E'missing relations\n';
    WHEN UNDEFINED_COLUMN THEN
      ret = ret || E'corrupted relations\n';
  END;

  -- print information about registered layers
  FOR rec IN SELECT * FROM topology.layer l
    WHERE l.topology_id = var_topology_id
    ORDER by layer_id
  LOOP -- {
    ret = ret || 'Layer ' || rec.layer_id || ', type ';
    CASE
      WHEN rec.feature_type = 1 THEN
        ret = ret || 'Puntal';
      WHEN rec.feature_type = 2 THEN
        ret = ret || 'Lineal';
      WHEN rec.feature_type = 3 THEN
        ret = ret || 'Polygonal';
      WHEN rec.feature_type = 4 THEN
        ret = ret || 'Mixed';
      ELSE 
        ret = ret || '???';
    END CASE;

    ret = ret || ' (' || rec.feature_type || '), ';

    BEGIN

      EXECUTE 'SELECT count(*) FROM ( SELECT DISTINCT topogeo_id FROM '
        || quote_ident(atopology)
        || '.relation r WHERE r.layer_id = ' || rec.layer_id
        || ' ) foo ' INTO STRICT n;

      ret = ret || n || ' topogeoms' || E'\n';

    EXCEPTION WHEN UNDEFINED_TABLE OR UNDEFINED_COLUMN THEN
      n := NULL;
      ret = ret || 'X topogeoms' || E'\n';
    END;

      IF rec.level > 0 THEN
        ret = ret || ' Hierarchy level ' || rec.level 
                  || ', child layer ' || rec.child_id || E'\n';
      END IF;

      ret = ret || ' Deploy: ';
      IF rec.feature_column != '' THEN
        ret = ret || quote_ident(rec.schema_name) || '.'
                  || quote_ident(rec.table_name) || '.'
                  || quote_ident(rec.feature_column);

        IF n > 0 THEN
          sql := 'SELECT count(*) FROM ( SELECT topogeo_id FROM '
            || quote_ident(atopology)
            || '.relation r WHERE r.layer_id = ' || rec.layer_id
            || ' EXCEPT SELECT DISTINCT id('
            || quote_ident(rec.feature_column) || ') FROM '
            || quote_ident(rec.schema_name) || '.'
            || quote_ident(rec.table_name) || ') as foo';
          BEGIN
            EXECUTE sql INTO STRICT missing;
            IF missing > 0 THEN
              ret = ret || ' (' || missing || ' missing topogeoms)';
            END IF;
          EXCEPTION
            WHEN UNDEFINED_TABLE THEN
              ret = ret || ' ( unexistent table )';
            WHEN UNDEFINED_COLUMN THEN
              ret = ret || ' ( unexistent column )';
          END;
        END IF;
        ret = ret || E'\n';

      ELSE
        ret = ret || E'NONE (detached)\n';
      END IF;

  END LOOP; -- }

  -- print information about unregistered layers containing topogeoms
  IF tgcount > 0 THEN -- {

    sql := 'SELECT layer_id FROM '
        || quote_ident(atopology) || '.relation EXCEPT SELECT layer_id'
        || ' FROM topology.layer WHERE topology_id = $1 ORDER BY layer_id';
    --RAISE DEBUG '%', sql;
    FOR rec IN  EXECUTE sql USING var_topology_id
    LOOP -- {
      ret = ret || 'Layer ' || rec.layer_id::text || ', UNREGISTERED, ';

      EXECUTE 'SELECT count(*) FROM ( SELECT DISTINCT topogeo_id FROM '
        || quote_ident(atopology)
        || '.relation r WHERE r.layer_id = ' || rec.layer_id
        || ' ) foo ' INTO STRICT n;

      ret = ret || n || ' topogeoms' || E'\n';

    END LOOP; -- }

  END IF; -- }

  RETURN ret;
END
$_$;


ALTER FUNCTION topology.topologysummary(atopology character varying) OWNER TO postgres;

--
-- TOC entry 1443 (class 1255 OID 31172)
-- Name: totopogeom(public.geometry, topogeometry, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION totopogeom(ageom public.geometry, tg topogeometry, atolerance double precision DEFAULT 0) RETURNS topogeometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  layer_info RECORD;
  topology_info RECORD;
  rec RECORD;
  rec2 RECORD;
  elem INT[];
  elems INT[][];
  sql TEXT;
  typ TEXT;
  tolerance FLOAT8;
  alayer INT;
  atopology TEXT;
BEGIN

  RAISE NOTICE 'TopoGeometry is "%", its topology_id is "%"', tg, topology_id(tg);

  -- Get topology information
  SELECT id, name FROM topology.topology
    INTO topology_info
    WHERE id = topology_id(tg);
  IF NOT FOUND THEN
    RAISE EXCEPTION 'No topology with id "%" in topology.topology',
                    topology_id(tg);
  END IF;

  alayer := layer_id(tg);
  atopology := topology_info.name;


  -- Get tolerance, if 0 was given
  tolerance := COALESCE( NULLIF(atolerance, 0), topology._st_mintolerance(topology_info.name, ageom) );

  -- Get layer information
  BEGIN
    SELECT *, CASE
      WHEN feature_type = 1 THEN 'puntal'
      WHEN feature_type = 2 THEN 'lineal'
      WHEN feature_type = 3 THEN 'areal'
      WHEN feature_type = 4 THEN 'mixed'
      ELSE 'unexpected_'||feature_type
      END as typename
    FROM topology.layer l
      INTO STRICT layer_info
      WHERE l.layer_id = layer_id(tg)
      AND l.topology_id = topology_info.id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'No layer with id "%" in topology "%"',
        alayer, atopology;
  END;

  -- Can't convert to a hierarchical topogeometry
  IF layer_info.level > 0 THEN
      RAISE EXCEPTION 'Layer "%" of topology "%" is hierarchical, cannot convert a simple geometry to it.',
        alayer, atopology;
  END IF;


  -- 
  -- Check type compatibility and set TopoGeometry type
  -- 1:puntal, 2:lineal, 3:areal, 4:collection
  --
  typ = geometrytype(ageom);
  IF typ = 'GEOMETRYCOLLECTION' THEN
    --  A collection can only go to collection layer
    IF layer_info.feature_type != 4 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold a collection feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg.type := 4;
  ELSIF typ = 'POINT' OR typ = 'MULTIPOINT' THEN -- puntal
    --  A point can go in puntal or collection layer
    IF layer_info.feature_type != 4 and layer_info.feature_type != 1 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold a puntal feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg.type := 1;
  ELSIF typ = 'LINESTRING' or typ = 'MULTILINESTRING' THEN -- lineal
    --  A line can go in lineal or collection layer
    IF layer_info.feature_type != 4 and layer_info.feature_type != 2 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold a lineal feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg.type := 2;
  ELSIF typ = 'POLYGON' OR typ = 'MULTIPOLYGON' THEN -- areal
    --  An area can go in areal or collection layer
    IF layer_info.feature_type != 4 and layer_info.feature_type != 3 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold an areal feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg.type := 3;
  ELSE
      -- Should never happen
      RAISE EXCEPTION
        'Unexpected feature dimension %', ST_Dimension(ageom);
  END IF;

  -- Now that we have an empty topogeometry, we loop over distinct components 
  -- and add them to the definition of it. We add them as soon
  -- as possible so that each element can further edit the
  -- definition by splitting
  FOR rec IN SELECT id(tg), alayer as lyr,
    geom, ST_Dimension(geom) as dims
    FROM (SELECT (ST_Dump(ageom)).geom) as f
    WHERE NOT ST_IsEmpty(geom)
  LOOP
    FOR rec2 IN SELECT CASE
       WHEN rec.dims = 0 THEN
         topology.topogeo_addPoint(atopology, rec.geom, tolerance)
       WHEN rec.dims = 1 THEN
         topology.topogeo_addLineString(atopology, rec.geom, tolerance)
       WHEN rec.dims = 2 THEN
         topology.topogeo_addPolygon(atopology, rec.geom, tolerance)
       END as primitive
    LOOP
      elem := ARRAY[rec.dims+1, rec2.primitive];
      IF elems @> ARRAY[elem] THEN
      ELSE
        elems := elems || elem;
        -- TODO: consider use a single INSERT statement for the whole thing
        sql := 'INSERT INTO ' || quote_ident(atopology)
            || '.relation(topogeo_id, layer_id, element_type, element_id) VALUES ('
            || rec.id || ',' || rec.lyr || ',' || rec.dims+1
            || ',' || rec2.primitive || ')'
            -- NOTE: we're avoiding duplicated rows here
            || ' EXCEPT SELECT ' || rec.id || ', ' || rec.lyr
            || ', element_type, element_id FROM '
            || quote_ident(topology_info.name)
            || '.relation WHERE layer_id = ' || rec.lyr
            || ' AND topogeo_id = ' || rec.id;
        EXECUTE sql;
      END IF;
    END LOOP;
  END LOOP;

  RETURN tg;

END
$$;


ALTER FUNCTION topology.totopogeom(ageom public.geometry, tg topogeometry, atolerance double precision) OWNER TO postgres;

--
-- TOC entry 1442 (class 1255 OID 31171)
-- Name: totopogeom(public.geometry, character varying, integer, double precision); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION totopogeom(ageom public.geometry, atopology character varying, alayer integer, atolerance double precision DEFAULT 0) RETURNS topogeometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  layer_info RECORD;
  topology_info RECORD;
  rec RECORD;
  rec2 RECORD;
  tg topology.TopoGeometry;
  elems INT[][];
  elem INT[];
  sql TEXT;
  typ TEXT;
BEGIN

  -- Get topology information
  BEGIN
    SELECT *
    FROM topology.topology
      INTO STRICT topology_info WHERE name = atopology;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'No topology with name "%" in topology.topology',
        atopology;
  END;

  -- Get layer information
  BEGIN
    SELECT *, CASE
      WHEN feature_type = 1 THEN 'puntal'
      WHEN feature_type = 2 THEN 'lineal'
      WHEN feature_type = 3 THEN 'areal'
      WHEN feature_type = 4 THEN 'mixed'
      ELSE 'unexpected_'||feature_type
      END as typename
    FROM topology.layer l
      INTO STRICT layer_info
      WHERE l.layer_id = alayer
      AND l.topology_id = topology_info.id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'No layer with id "%" in topology "%"',
        alayer, atopology;
  END;

  -- Can't convert to a hierarchical topogeometry
  IF layer_info.level > 0 THEN
      RAISE EXCEPTION 'Layer "%" of topology "%" is hierarchical, cannot convert to it.',
        alayer, atopology;
  END IF;


  -- 
  -- Check type compatibility and create empty TopoGeometry
  -- 1:puntal, 2:lineal, 3:areal, 4:collection
  --
  typ = geometrytype(ageom);
  IF typ = 'GEOMETRYCOLLECTION' THEN
    --  A collection can only go collection layer
    IF layer_info.feature_type != 4 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold a collection feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg := topology.CreateTopoGeom(atopology, 4, alayer);
  ELSIF typ = 'POINT' OR typ = 'MULTIPOINT' THEN -- puntal
    --  A point can go in puntal or collection layer
    IF layer_info.feature_type != 4 and layer_info.feature_type != 1 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold a puntal feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg := topology.CreateTopoGeom(atopology, 1, alayer);
  ELSIF typ = 'LINESTRING' or typ = 'MULTILINESTRING' THEN -- lineal
    --  A line can go in lineal or collection layer
    IF layer_info.feature_type != 4 and layer_info.feature_type != 2 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold a lineal feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg := topology.CreateTopoGeom(atopology, 2, alayer);
  ELSIF typ = 'POLYGON' OR typ = 'MULTIPOLYGON' THEN -- areal
    --  An area can go in areal or collection layer
    IF layer_info.feature_type != 4 and layer_info.feature_type != 3 THEN
      RAISE EXCEPTION
        'Layer "%" of topology "%" is %, cannot hold an areal feature.',
        layer_info.layer_id, topology_info.name, layer_info.typename;
    END IF;
    tg := topology.CreateTopoGeom(atopology, 3, alayer);
  ELSE
      -- Should never happen
      RAISE EXCEPTION
        'Unsupported feature type %', typ;
  END IF;

  tg := topology.toTopoGeom(ageom, tg, atolerance);

  RETURN tg;

END
$$;


ALTER FUNCTION topology.totopogeom(ageom public.geometry, atopology character varying, alayer integer, atolerance double precision) OWNER TO postgres;

--
-- TOC entry 1410 (class 1255 OID 31136)
-- Name: validatetopology(character varying); Type: FUNCTION; Schema: topology; Owner: postgres
--

CREATE FUNCTION validatetopology(toponame character varying) RETURNS SETOF validatetopology_returntype
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  retrec topology.ValidateTopology_ReturnType;
  rec RECORD;
  rec2 RECORD;
  i integer;
  invalid_edges integer[];
  invalid_faces integer[];
  sql text;
BEGIN

  -- Check for coincident nodes
  FOR rec IN EXECUTE 'SELECT a.node_id as id1, b.node_id as id2 FROM '
    || quote_ident(toponame) || '.node a, '
    || quote_ident(toponame) || '.node b '
    || 'WHERE a.node_id < b.node_id '
    || ' AND ST_DWithin(a.geom, b.geom, 0)' -- NOTE: see #1625 and #1789
  LOOP
    retrec.error = 'coincident nodes';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge crossed nodes
  -- TODO: do this in the single edge loop
  FOR rec IN EXECUTE 'SELECT n.node_id as id1, e.edge_id as id2 FROM '
    || quote_ident(toponame) || '.node n, '
    || quote_ident(toponame) || '.edge e '
    || 'WHERE e.start_node != n.node_id '
    || 'AND e.end_node != n.node_id '
    || 'AND ST_Within(n.geom, e.geom)'
  LOOP
    retrec.error = 'edge crosses node';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Scan all edges 
  FOR rec IN EXECUTE 'SELECT e.geom, e.edge_id as id1, e.left_face, e.right_face FROM '
    || quote_ident(toponame) || '.edge e ORDER BY edge_id'
  LOOP

    -- Any invalid edge becomes a cancer for higher level complexes
    IF NOT ST_IsValid(rec.geom) THEN

      retrec.error = 'invalid edge';
      retrec.id1 = rec.id1;
      retrec.id2 = NULL;
      RETURN NEXT retrec;
      invalid_edges := array_append(invalid_edges, rec.id1);

      IF invalid_faces IS NULL OR NOT rec.left_face = ANY ( invalid_faces )
      THEN
        invalid_faces := array_append(invalid_faces, rec.left_face);
      END IF;

      IF rec.right_face != rec.left_face AND ( invalid_faces IS NULL OR
            NOT rec.right_face = ANY ( invalid_faces ) )
      THEN
        invalid_faces := array_append(invalid_faces, rec.right_face);
      END IF;

      CONTINUE;

    END IF;

    IF NOT ST_IsSimple(rec.geom) THEN
      retrec.error = 'edge not simple';
      retrec.id1 = rec.id1;
      retrec.id2 = NULL;
      RETURN NEXT retrec;
    END IF;

  END LOOP;

  -- Check for edge crossing
  sql := 'SELECT e1.edge_id as id1, e2.edge_id as id2, '
    || ' e1.geom as g1, e2.geom as g2, '
    || 'ST_Relate(e1.geom, e2.geom) as im FROM '
    || quote_ident(toponame) || '.edge e1, '
    || quote_ident(toponame) || '.edge e2 '
    || 'WHERE e1.edge_id < e2.edge_id '
    || ' AND e1.geom && e2.geom ';
  IF invalid_edges IS NOT NULL THEN
    sql := sql || ' AND NOT e1.edge_id = ANY ('
               || quote_literal(invalid_edges) || ')'
               || ' AND NOT e2.edge_id = ANY ('
               || quote_literal(invalid_edges) || ')';
  END IF;

  FOR rec IN EXECUTE sql
  LOOP
    IF ST_RelateMatch(rec.im, 'FF1F**1*2') THEN
      CONTINUE; -- no interior intersection
    END IF;

    --
    -- Closed lines have no boundary, so endpoint
    -- intersection would be considered interior
    -- See http://trac.osgeo.org/postgis/ticket/770
    -- See also full explanation in topology.AddEdge
    --

    IF ST_RelateMatch(rec.im, 'FF10F01F2') THEN
      -- first line (g1) is open, second (g2) is closed
      -- first boundary has puntual intersection with second interior
      --
      -- compute intersection, check it equals second endpoint
      IF ST_Equals(ST_Intersection(rec.g2, rec.g1),
                   ST_StartPoint(rec.g2))
      THEN
        CONTINUE;
      END IF;
    END IF;

    IF ST_RelateMatch(rec.im, 'F01FFF102') THEN
      -- second line (g2) is open, first (g1) is closed
      -- second boundary has puntual intersection with first interior
      -- 
      -- compute intersection, check it equals first endpoint
      IF ST_Equals(ST_Intersection(rec.g2, rec.g1),
                   ST_StartPoint(rec.g1))
      THEN
        CONTINUE;
      END IF;
    END IF;

    IF ST_RelateMatch(rec.im, '0F1FFF1F2') THEN
      -- both lines are closed (boundary intersects nothing)
      -- they have puntual intersection between interiors
      -- 
      -- compute intersection, check it's a single point
      -- and equals first StartPoint _and_ second StartPoint
      IF ST_Equals(ST_Intersection(rec.g1, rec.g2),
                   ST_StartPoint(rec.g1)) AND
         ST_Equals(ST_StartPoint(rec.g1), ST_StartPoint(rec.g2))
      THEN
        CONTINUE;
      END IF;
    END IF;

    retrec.error = 'edge crosses edge';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge start_node geometry mis-match
  -- TODO: move this in the first edge table scan 
  FOR rec IN EXECUTE 'SELECT e.edge_id as id1, n.node_id as id2 FROM '
    || quote_ident(toponame) || '.edge e, '
    || quote_ident(toponame) || '.node n '
    || 'WHERE e.start_node = n.node_id '
    || 'AND NOT ST_Equals(ST_StartPoint(e.geom), n.geom)'
  LOOP
    retrec.error = 'edge start node geometry mis-match';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge end_node geometry mis-match
  -- TODO: move this in the first edge table scan 
  FOR rec IN EXECUTE 'SELECT e.edge_id as id1, n.node_id as id2 FROM '
    || quote_ident(toponame) || '.edge e, '
    || quote_ident(toponame) || '.node n '
    || 'WHERE e.end_node = n.node_id '
    || 'AND NOT ST_Equals(ST_EndPoint(e.geom), n.geom)'
  LOOP
    retrec.error = 'edge end node geometry mis-match';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for faces w/out edges
  FOR rec IN EXECUTE 'SELECT face_id as id1 FROM '
    || quote_ident(toponame) || '.face '
    || 'WHERE face_id > 0 EXCEPT ( SELECT left_face FROM '
    || quote_ident(toponame) || '.edge '
    || ' UNION SELECT right_face FROM '
    || quote_ident(toponame) || '.edge '
    || ')'
  LOOP
    retrec.error = 'face without edges';
    retrec.id1 = rec.id1;
    retrec.id2 = NULL;
    RETURN NEXT retrec;
  END LOOP;

  -- Now create a temporary table to construct all face geometries
  -- for checking their consistency

  sql := 'CREATE TEMP TABLE face_check ON COMMIT DROP AS '
    || 'SELECT face_id, topology.ST_GetFaceGeometry('
    || quote_literal(toponame) || ', face_id) as geom, mbr FROM '
    || quote_ident(toponame) || '.face WHERE face_id > 0';
  IF invalid_faces IS NOT NULL THEN
    sql := sql || ' AND NOT face_id = ANY ('
               || quote_literal(invalid_faces) || ')';
  END IF;
  EXECUTE sql;

  -- Build a gist index on geom
  EXECUTE 'CREATE INDEX "face_check_gist" ON '
    || 'face_check USING gist (geom);';

  -- Build a btree index on id
  EXECUTE 'CREATE INDEX "face_check_bt" ON ' 
    || 'face_check (face_id);';

  -- Scan the table looking for NULL geometries
  FOR rec IN EXECUTE
    'SELECT f1.face_id FROM '
    || 'face_check f1 WHERE f1.geom IS NULL'
  LOOP
    -- Face missing !
    retrec.error := 'face has no rings';
    retrec.id1 := rec.face_id;
    retrec.id2 := NULL;
    RETURN NEXT retrec;
  END LOOP;


  -- Scan the table looking for overlap or containment
  -- TODO: also check for MBR consistency
  FOR rec IN EXECUTE
    'SELECT f1.geom, f1.face_id as id1, f2.face_id as id2, '
    || ' ST_Relate(f1.geom, f2.geom) as im'
    || ' FROM '
    || 'face_check f1, '
    || 'face_check f2 '
    || 'WHERE f1.face_id < f2.face_id'
    || ' AND f1.geom && f2.geom'
  LOOP

    -- Face overlap
    IF ST_RelateMatch(rec.im, 'T*T***T**') THEN
    retrec.error = 'face overlaps face';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
    END IF;

    -- Face 1 is within face 2 
    IF ST_RelateMatch(rec.im, 'T*F**F***') THEN
    retrec.error = 'face within face';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
    END IF;

    -- Face 1 contains face 2
    IF ST_RelateMatch(rec.im, 'T*****FF*') THEN
    retrec.error = 'face within face';
    retrec.id1 = rec.id2;
    retrec.id2 = rec.id1;
    RETURN NEXT retrec;
    END IF;

  END LOOP;


  DROP TABLE face_check;

  RETURN;
END
$$;


ALTER FUNCTION topology.validatetopology(toponame character varying) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- TOC entry 2306 (class 1255 OID 31279)
-- Name: quantile(double precision); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE quantile(double precision) (
    SFUNC = plr_array_accum,
    STYPE = double precision[],
    FINALFUNC = r_quantile
);


ALTER AGGREGATE public.quantile(double precision) OWNER TO postgres;

--
-- TOC entry 2291 (class 1255 OID 30170)
-- Name: st_3dextent(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_3dextent(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d
);


ALTER AGGREGATE public.st_3dextent(geometry) OWNER TO postgres;

--
-- TOC entry 2294 (class 1255 OID 30185)
-- Name: st_accum(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_accum(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_accum_finalfn
);


ALTER AGGREGATE public.st_accum(geometry) OWNER TO postgres;

--
-- TOC entry 2296 (class 1255 OID 30188)
-- Name: st_collect(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_collect(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_collect_finalfn
);


ALTER AGGREGATE public.st_collect(geometry) OWNER TO postgres;

--
-- TOC entry 2290 (class 1255 OID 30169)
-- Name: st_extent(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_extent(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d,
    FINALFUNC = public.box2d
);


ALTER AGGREGATE public.st_extent(geometry) OWNER TO postgres;

--
-- TOC entry 2298 (class 1255 OID 30190)
-- Name: st_makeline(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_makeline(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_makeline_finalfn
);


ALTER AGGREGATE public.st_makeline(geometry) OWNER TO postgres;

--
-- TOC entry 2292 (class 1255 OID 30172)
-- Name: st_memcollect(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_memcollect(geometry) (
    SFUNC = public.st_collect,
    STYPE = geometry
);


ALTER AGGREGATE public.st_memcollect(geometry) OWNER TO postgres;

--
-- TOC entry 2293 (class 1255 OID 30174)
-- Name: st_memunion(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_memunion(geometry) (
    SFUNC = public.st_union,
    STYPE = geometry
);


ALTER AGGREGATE public.st_memunion(geometry) OWNER TO postgres;

--
-- TOC entry 2297 (class 1255 OID 30189)
-- Name: st_polygonize(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_polygonize(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_polygonize_finalfn
);


ALTER AGGREGATE public.st_polygonize(geometry) OWNER TO postgres;

--
-- TOC entry 2299 (class 1255 OID 30926)
-- Name: st_samealignment(raster); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_samealignment(raster) (
    SFUNC = _st_samealignment_transfn,
    STYPE = agg_samealignment,
    FINALFUNC = _st_samealignment_finalfn
);


ALTER AGGREGATE public.st_samealignment(raster) OWNER TO postgres;

--
-- TOC entry 2295 (class 1255 OID 30187)
-- Name: st_union(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_union_finalfn
);


ALTER AGGREGATE public.st_union(geometry) OWNER TO postgres;

--
-- TOC entry 2303 (class 1255 OID 30988)
-- Name: st_union(raster); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(raster) (
    SFUNC = public._st_union_transfn,
    STYPE = internal,
    FINALFUNC = _st_union_finalfn
);


ALTER AGGREGATE public.st_union(raster) OWNER TO postgres;

--
-- TOC entry 2302 (class 1255 OID 30986)
-- Name: st_union(raster, integer); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(raster, integer) (
    SFUNC = public._st_union_transfn,
    STYPE = internal,
    FINALFUNC = _st_union_finalfn
);


ALTER AGGREGATE public.st_union(raster, integer) OWNER TO postgres;

--
-- TOC entry 2304 (class 1255 OID 30990)
-- Name: st_union(raster, text); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(raster, text) (
    SFUNC = public._st_union_transfn,
    STYPE = internal,
    FINALFUNC = _st_union_finalfn
);


ALTER AGGREGATE public.st_union(raster, text) OWNER TO postgres;

--
-- TOC entry 2300 (class 1255 OID 30982)
-- Name: st_union(raster, unionarg[]); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(raster, unionarg[]) (
    SFUNC = public._st_union_transfn,
    STYPE = internal,
    FINALFUNC = _st_union_finalfn
);


ALTER AGGREGATE public.st_union(raster, unionarg[]) OWNER TO postgres;

--
-- TOC entry 2301 (class 1255 OID 30984)
-- Name: st_union(raster, integer, text); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(raster, integer, text) (
    SFUNC = public._st_union_transfn,
    STYPE = internal,
    FINALFUNC = _st_union_finalfn
);


ALTER AGGREGATE public.st_union(raster, integer, text) OWNER TO postgres;

SET search_path = topology, pg_catalog;

--
-- TOC entry 2305 (class 1255 OID 31166)
-- Name: topoelementarray_agg(topoelement); Type: AGGREGATE; Schema: topology; Owner: postgres
--

CREATE AGGREGATE topoelementarray_agg(topoelement) (
    SFUNC = topoelementarray_append,
    STYPE = topoelementarray
);


ALTER AGGREGATE topology.topoelementarray_agg(topoelement) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- TOC entry 3046 (class 2617 OID 29869)
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = geometry_overlaps,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &&,
    RESTRICT = gserialized_gist_sel_2d,
    JOIN = gserialized_gist_joinsel_2d
);


ALTER OPERATOR public.&& (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3061 (class 2617 OID 30383)
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = geography_overlaps,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = &&,
    RESTRICT = gserialized_gist_sel_nd,
    JOIN = gserialized_gist_joinsel_nd
);


ALTER OPERATOR public.&& (geography, geography) OWNER TO postgres;

--
-- TOC entry 3075 (class 2617 OID 30909)
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = raster_overlap,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = &&,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.&& (raster, raster) OWNER TO postgres;

--
-- TOC entry 3085 (class 2617 OID 30916)
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = geometry_raster_overlap,
    LEFTARG = geometry,
    RIGHTARG = raster,
    COMMUTATOR = &&,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.&& (geometry, raster) OWNER TO postgres;

--
-- TOC entry 3084 (class 2617 OID 30917)
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = raster_geometry_overlap,
    LEFTARG = raster,
    RIGHTARG = geometry,
    COMMUTATOR = &&,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.&& (raster, geometry) OWNER TO postgres;

--
-- TOC entry 3060 (class 2617 OID 29928)
-- Name: &&&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &&& (
    PROCEDURE = geometry_overlaps_nd,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &&&,
    RESTRICT = gserialized_gist_sel_nd,
    JOIN = gserialized_gist_joinsel_nd
);


ALTER OPERATOR public.&&& (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3053 (class 2617 OID 29885)
-- Name: &<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &< (
    PROCEDURE = geometry_overleft,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&< (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3072 (class 2617 OID 30904)
-- Name: &<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &< (
    PROCEDURE = raster_overleft,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = &>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&< (raster, raster) OWNER TO postgres;

--
-- TOC entry 3055 (class 2617 OID 29891)
-- Name: &<|; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &<| (
    PROCEDURE = geometry_overbelow,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = |&>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&<| (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3074 (class 2617 OID 30908)
-- Name: &<|; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &<| (
    PROCEDURE = raster_overbelow,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = |&>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&<| (raster, raster) OWNER TO postgres;

--
-- TOC entry 3056 (class 2617 OID 29884)
-- Name: &>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &> (
    PROCEDURE = geometry_overright,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3076 (class 2617 OID 30903)
-- Name: &>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &> (
    PROCEDURE = raster_overright,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = &<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&> (raster, raster) OWNER TO postgres;

--
-- TOC entry 3041 (class 2617 OID 29842)
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = geometry_lt,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.< (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3062 (class 2617 OID 30402)
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = geography_lt,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.< (geography, geography) OWNER TO postgres;

--
-- TOC entry 3049 (class 2617 OID 29875)
-- Name: <#>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <#> (
    PROCEDURE = geometry_distance_box,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <#>
);


ALTER OPERATOR public.<#> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3048 (class 2617 OID 29874)
-- Name: <->; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <-> (
    PROCEDURE = geometry_distance_centroid,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <->
);


ALTER OPERATOR public.<-> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3052 (class 2617 OID 29882)
-- Name: <<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR << (
    PROCEDURE = geometry_left,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<< (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3071 (class 2617 OID 30902)
-- Name: <<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR << (
    PROCEDURE = raster_left,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = >>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<< (raster, raster) OWNER TO postgres;

--
-- TOC entry 3054 (class 2617 OID 29888)
-- Name: <<|; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <<| (
    PROCEDURE = geometry_below,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = |>>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<<| (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3073 (class 2617 OID 30906)
-- Name: <<|; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <<| (
    PROCEDURE = raster_below,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = |>>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<<| (raster, raster) OWNER TO postgres;

--
-- TOC entry 3042 (class 2617 OID 29843)
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = geometry_le,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3064 (class 2617 OID 30403)
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = geography_le,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<= (geography, geography) OWNER TO postgres;

--
-- TOC entry 3043 (class 2617 OID 29844)
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = geometry_eq,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = =,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3067 (class 2617 OID 30404)
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = geography_eq,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = =,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.= (geography, geography) OWNER TO postgres;

--
-- TOC entry 3070 (class 2617 OID 30878)
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = raster_eq,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = =,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (raster, raster) OWNER TO postgres;

--
-- TOC entry 3045 (class 2617 OID 29840)
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = geometry_gt,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3069 (class 2617 OID 30400)
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = geography_gt,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.> (geography, geography) OWNER TO postgres;

--
-- TOC entry 3044 (class 2617 OID 29841)
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = geometry_ge,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3068 (class 2617 OID 30401)
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = geography_ge,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>= (geography, geography) OWNER TO postgres;

--
-- TOC entry 3057 (class 2617 OID 29881)
-- Name: >>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >> (
    PROCEDURE = geometry_right,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.>> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3077 (class 2617 OID 30901)
-- Name: >>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >> (
    PROCEDURE = raster_right,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = <<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.>> (raster, raster) OWNER TO postgres;

--
-- TOC entry 3050 (class 2617 OID 29879)
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = geometry_within,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3081 (class 2617 OID 30912)
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = raster_contained,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (raster, raster) OWNER TO postgres;

--
-- TOC entry 3083 (class 2617 OID 30915)
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = raster_contained_by_geometry,
    LEFTARG = raster,
    RIGHTARG = geometry,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (raster, geometry) OWNER TO postgres;

--
-- TOC entry 3065 (class 2617 OID 30918)
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = geometry_contained_by_raster,
    LEFTARG = geometry,
    RIGHTARG = raster,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (geometry, raster) OWNER TO postgres;

--
-- TOC entry 3058 (class 2617 OID 29890)
-- Name: |&>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR |&> (
    PROCEDURE = geometry_overabove,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.|&> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3078 (class 2617 OID 30907)
-- Name: |&>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR |&> (
    PROCEDURE = raster_overabove,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = &<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.|&> (raster, raster) OWNER TO postgres;

--
-- TOC entry 3059 (class 2617 OID 29887)
-- Name: |>>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR |>> (
    PROCEDURE = geometry_above,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.|>> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3079 (class 2617 OID 30905)
-- Name: |>>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR |>> (
    PROCEDURE = raster_above,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = <<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.|>> (raster, raster) OWNER TO postgres;

--
-- TOC entry 3051 (class 2617 OID 29878)
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = geometry_contains,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3082 (class 2617 OID 30911)
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = raster_contain,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (raster, raster) OWNER TO postgres;

--
-- TOC entry 3066 (class 2617 OID 30913)
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = raster_geometry_contain,
    LEFTARG = raster,
    RIGHTARG = geometry,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (raster, geometry) OWNER TO postgres;

--
-- TOC entry 3063 (class 2617 OID 30914)
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = geometry_raster_contain,
    LEFTARG = geometry,
    RIGHTARG = raster,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (geometry, raster) OWNER TO postgres;

--
-- TOC entry 3047 (class 2617 OID 29871)
-- Name: ~=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~= (
    PROCEDURE = geometry_same,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3080 (class 2617 OID 30910)
-- Name: ~=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~= (
    PROCEDURE = raster_same,
    LEFTARG = raster,
    RIGHTARG = raster,
    COMMUTATOR = ~=,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.~= (raster, raster) OWNER TO postgres;

--
-- TOC entry 3210 (class 2616 OID 30406)
-- Name: btree_geography_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_geography_ops
    DEFAULT FOR TYPE geography USING btree AS
    OPERATOR 1 <(geography,geography) ,
    OPERATOR 2 <=(geography,geography) ,
    OPERATOR 3 =(geography,geography) ,
    OPERATOR 4 >=(geography,geography) ,
    OPERATOR 5 >(geography,geography) ,
    FUNCTION 1 (geography, geography) geography_cmp(geography,geography);


ALTER OPERATOR CLASS public.btree_geography_ops USING btree OWNER TO postgres;

--
-- TOC entry 3206 (class 2616 OID 29846)
-- Name: btree_geometry_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_geometry_ops
    DEFAULT FOR TYPE geometry USING btree AS
    OPERATOR 1 <(geometry,geometry) ,
    OPERATOR 2 <=(geometry,geometry) ,
    OPERATOR 3 =(geometry,geometry) ,
    OPERATOR 4 >=(geometry,geometry) ,
    OPERATOR 5 >(geometry,geometry) ,
    FUNCTION 1 (geometry, geometry) geometry_cmp(geometry,geometry);


ALTER OPERATOR CLASS public.btree_geometry_ops USING btree OWNER TO postgres;

--
-- TOC entry 3209 (class 2616 OID 30385)
-- Name: gist_geography_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_geography_ops
    DEFAULT FOR TYPE geography USING gist AS
    STORAGE gidx ,
    OPERATOR 3 &&(geography,geography) ,
    FUNCTION 1 (geography, geography) geography_gist_consistent(internal,geography,integer) ,
    FUNCTION 2 (geography, geography) geography_gist_union(bytea,internal) ,
    FUNCTION 3 (geography, geography) geography_gist_compress(internal) ,
    FUNCTION 4 (geography, geography) geography_gist_decompress(internal) ,
    FUNCTION 5 (geography, geography) geography_gist_penalty(internal,internal,internal) ,
    FUNCTION 6 (geography, geography) geography_gist_picksplit(internal,internal) ,
    FUNCTION 7 (geography, geography) geography_gist_same(box2d,box2d,internal);


ALTER OPERATOR CLASS public.gist_geography_ops USING gist OWNER TO postgres;

--
-- TOC entry 3207 (class 2616 OID 29897)
-- Name: gist_geometry_ops_2d; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_geometry_ops_2d
    DEFAULT FOR TYPE geometry USING gist AS
    STORAGE box2df ,
    OPERATOR 1 <<(geometry,geometry) ,
    OPERATOR 2 &<(geometry,geometry) ,
    OPERATOR 3 &&(geometry,geometry) ,
    OPERATOR 4 &>(geometry,geometry) ,
    OPERATOR 5 >>(geometry,geometry) ,
    OPERATOR 6 ~=(geometry,geometry) ,
    OPERATOR 7 ~(geometry,geometry) ,
    OPERATOR 8 @(geometry,geometry) ,
    OPERATOR 9 &<|(geometry,geometry) ,
    OPERATOR 10 <<|(geometry,geometry) ,
    OPERATOR 11 |>>(geometry,geometry) ,
    OPERATOR 12 |&>(geometry,geometry) ,
    OPERATOR 13 <->(geometry,geometry) FOR ORDER BY pg_catalog.float_ops ,
    OPERATOR 14 <#>(geometry,geometry) FOR ORDER BY pg_catalog.float_ops ,
    FUNCTION 1 (geometry, geometry) geometry_gist_consistent_2d(internal,geometry,integer) ,
    FUNCTION 2 (geometry, geometry) geometry_gist_union_2d(bytea,internal) ,
    FUNCTION 3 (geometry, geometry) geometry_gist_compress_2d(internal) ,
    FUNCTION 4 (geometry, geometry) geometry_gist_decompress_2d(internal) ,
    FUNCTION 5 (geometry, geometry) geometry_gist_penalty_2d(internal,internal,internal) ,
    FUNCTION 6 (geometry, geometry) geometry_gist_picksplit_2d(internal,internal) ,
    FUNCTION 7 (geometry, geometry) geometry_gist_same_2d(geometry,geometry,internal) ,
    FUNCTION 8 (geometry, geometry) geometry_gist_distance_2d(internal,geometry,integer);


ALTER OPERATOR CLASS public.gist_geometry_ops_2d USING gist OWNER TO postgres;

--
-- TOC entry 3208 (class 2616 OID 29930)
-- Name: gist_geometry_ops_nd; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_geometry_ops_nd
    FOR TYPE geometry USING gist AS
    STORAGE gidx ,
    OPERATOR 3 &&&(geometry,geometry) ,
    FUNCTION 1 (geometry, geometry) geometry_gist_consistent_nd(internal,geometry,integer) ,
    FUNCTION 2 (geometry, geometry) geometry_gist_union_nd(bytea,internal) ,
    FUNCTION 3 (geometry, geometry) geometry_gist_compress_nd(internal) ,
    FUNCTION 4 (geometry, geometry) geometry_gist_decompress_nd(internal) ,
    FUNCTION 5 (geometry, geometry) geometry_gist_penalty_nd(internal,internal,internal) ,
    FUNCTION 6 (geometry, geometry) geometry_gist_picksplit_nd(internal,internal) ,
    FUNCTION 7 (geometry, geometry) geometry_gist_same_nd(geometry,geometry,internal);


ALTER OPERATOR CLASS public.gist_geometry_ops_nd USING gist OWNER TO postgres;

--
-- TOC entry 3211 (class 2616 OID 30880)
-- Name: hash_raster_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS hash_raster_ops
    DEFAULT FOR TYPE raster USING hash AS
    OPERATOR 1 =(raster,raster) ,
    FUNCTION 1 (raster, raster) raster_hash(raster);


ALTER OPERATOR CLASS public.hash_raster_ops USING hash OWNER TO postgres;

SET search_path = pg_catalog;

--
-- TOC entry 4604 (class 2605 OID 30110)
-- Name: CAST (public.box2d AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box2d AS public.box3d) WITH FUNCTION public.box3d(public.box2d) AS IMPLICIT;


--
-- TOC entry 4603 (class 2605 OID 30111)
-- Name: CAST (public.box2d AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box2d AS public.geometry) WITH FUNCTION public.geometry(public.box2d) AS IMPLICIT;


--
-- TOC entry 4600 (class 2605 OID 30112)
-- Name: CAST (public.box3d AS box); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d AS box) WITH FUNCTION public.box(public.box3d) AS IMPLICIT;


--
-- TOC entry 4602 (class 2605 OID 30109)
-- Name: CAST (public.box3d AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d AS public.box2d) WITH FUNCTION public.box2d(public.box3d) AS IMPLICIT;


--
-- TOC entry 4601 (class 2605 OID 30113)
-- Name: CAST (public.box3d AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d AS public.geometry) WITH FUNCTION public.geometry(public.box3d) AS IMPLICIT;


--
-- TOC entry 4393 (class 2605 OID 30356)
-- Name: CAST (bytea AS public.geography); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (bytea AS public.geography) WITH FUNCTION public.geography(bytea) AS IMPLICIT;


--
-- TOC entry 4392 (class 2605 OID 30116)
-- Name: CAST (bytea AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (bytea AS public.geometry) WITH FUNCTION public.geometry(bytea) AS IMPLICIT;


--
-- TOC entry 4605 (class 2605 OID 30357)
-- Name: CAST (public.geography AS bytea); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geography AS bytea) WITH FUNCTION public.bytea(public.geography) AS IMPLICIT;


--
-- TOC entry 4607 (class 2605 OID 30353)
-- Name: CAST (public.geography AS public.geography); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geography AS public.geography) WITH FUNCTION public.geography(public.geography, integer, boolean) AS IMPLICIT;


--
-- TOC entry 4606 (class 2605 OID 30374)
-- Name: CAST (public.geography AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geography AS public.geometry) WITH FUNCTION public.geometry(public.geography);


--
-- TOC entry 4594 (class 2605 OID 30108)
-- Name: CAST (public.geometry AS box); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS box) WITH FUNCTION public.box(public.geometry) AS ASSIGNMENT;


--
-- TOC entry 4598 (class 2605 OID 30106)
-- Name: CAST (public.geometry AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.box2d) WITH FUNCTION public.box2d(public.geometry) AS IMPLICIT;


--
-- TOC entry 4597 (class 2605 OID 30107)
-- Name: CAST (public.geometry AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.box3d) WITH FUNCTION public.box3d(public.geometry) AS IMPLICIT;


--
-- TOC entry 4590 (class 2605 OID 30117)
-- Name: CAST (public.geometry AS bytea); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS bytea) WITH FUNCTION public.bytea(public.geometry) AS IMPLICIT;


--
-- TOC entry 4599 (class 2605 OID 30372)
-- Name: CAST (public.geometry AS public.geography); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.geography) WITH FUNCTION public.geography(public.geometry) AS IMPLICIT;


--
-- TOC entry 4596 (class 2605 OID 29801)
-- Name: CAST (public.geometry AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.geometry) WITH FUNCTION public.geometry(public.geometry, integer, boolean) AS IMPLICIT;


--
-- TOC entry 4593 (class 2605 OID 29810)
-- Name: CAST (public.geometry AS path); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS path) WITH FUNCTION public.path(public.geometry);


--
-- TOC entry 4592 (class 2605 OID 29808)
-- Name: CAST (public.geometry AS point); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS point) WITH FUNCTION public.point(public.geometry);


--
-- TOC entry 4595 (class 2605 OID 29812)
-- Name: CAST (public.geometry AS polygon); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS polygon) WITH FUNCTION public.polygon(public.geometry);


--
-- TOC entry 4591 (class 2605 OID 30115)
-- Name: CAST (public.geometry AS text); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS text) WITH FUNCTION public.text(public.geometry) AS IMPLICIT;


--
-- TOC entry 4480 (class 2605 OID 29811)
-- Name: CAST (path AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (path AS public.geometry) WITH FUNCTION public.geometry(path);


--
-- TOC entry 4476 (class 2605 OID 29809)
-- Name: CAST (point AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (point AS public.geometry) WITH FUNCTION public.geometry(point);


--
-- TOC entry 4489 (class 2605 OID 29813)
-- Name: CAST (polygon AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (polygon AS public.geometry) WITH FUNCTION public.geometry(polygon);


--
-- TOC entry 4610 (class 2605 OID 30873)
-- Name: CAST (public.raster AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.raster AS public.box3d) WITH FUNCTION public.box3d(public.raster) AS ASSIGNMENT;


--
-- TOC entry 4608 (class 2605 OID 30875)
-- Name: CAST (public.raster AS bytea); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.raster AS bytea) WITH FUNCTION public.bytea(public.raster) AS ASSIGNMENT;


--
-- TOC entry 4609 (class 2605 OID 30874)
-- Name: CAST (public.raster AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.raster AS public.geometry) WITH FUNCTION public.st_convexhull(public.raster) AS ASSIGNMENT;


--
-- TOC entry 4461 (class 2605 OID 30114)
-- Name: CAST (text AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS public.geometry) WITH FUNCTION public.geometry(text) AS IMPLICIT;


--
-- TOC entry 4611 (class 2605 OID 31135)
-- Name: CAST (topology.topogeometry AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (topology.topogeometry AS public.geometry) WITH FUNCTION topology.geometry(topology.topogeometry) AS IMPLICIT;


SET search_path = config, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- TOC entry 198 (class 1259 OID 31280)
-- Name: animazione_webgis; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE animazione_webgis (
    label character varying(64),
    nome_file character varying(125),
    tipo_dato character varying(32),
    formato_data character varying(64),
    campo_data character varying(64),
    gid integer NOT NULL,
    note character varying(255),
    delta_min integer,
    delta_max integer,
    delta_udm character varying(16),
    path character varying(200),
    data_index character(12),
    bounds3857 character varying(100),
    size character varying(64),
    delta_inizio integer,
    delta_passo integer,
    attivo smallint,
    webgis_idx character varying(12),
    webgis_idx_arr integer[],
    frame_offset smallint
);


ALTER TABLE animazione_webgis OWNER TO postgres;

--
-- TOC entry 5042 (class 0 OID 0)
-- Dependencies: 198
-- Name: TABLE animazione_webgis; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE animazione_webgis IS 'test per gestire le animazioni dei layers sul webgis';


--
-- TOC entry 5043 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.tipo_dato; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.tipo_dato IS 'indicare se il layer da animare e "vettore" o "img"';


--
-- TOC entry 5044 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.delta_min; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.delta_min IS 'passo minimo tra una animazione e la successiva, in delta_udm';


--
-- TOC entry 5045 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.delta_max; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.delta_max IS 'flashblack massimo concesso, in delta_udm';


--
-- TOC entry 5046 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.delta_udm; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.delta_udm IS 'unita di misura secondo lo standard postgres dei delta indicati';


--
-- TOC entry 5047 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.path; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.path IS 'percorso del file raster per l''animazione o nel caso di file vettoriali indicare DB.SCHEMA';


--
-- TOC entry 5048 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.data_index; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.data_index IS 'contando da zero indice iniziale incluso e indice finale escluso dell''informazione temporale separati da @@';


--
-- TOC entry 5049 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.bounds3857; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.bounds3857 IS '2 coppie di coordinate separate da @@ nel sistema epsg:3857, per i raster';


--
-- TOC entry 5050 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.size; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.size IS 'coppia delle dimensioni dell''immagine raster in pixel, separati da @@';


--
-- TOC entry 5051 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.delta_inizio; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.delta_inizio IS 'in delta_udm specificare il tempo di partenza del delta_min. normalmente è 00 ma potrebbe essere altro...';


--
-- TOC entry 5052 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.delta_passo; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.delta_passo IS 'passo in delta_udm per scaglionare gli intervalli temporali per il flashback, deve essere un sottomultiplo di delta_max. ad esempio se si vuol far selezionare di ora in ora, mettere 60 con delta_udm=MI';


--
-- TOC entry 5053 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.attivo; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.attivo IS '0-disattivato nell''elenco;1-attivato nell''elenco';


--
-- TOC entry 5054 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.webgis_idx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.webgis_idx IS 'webgis che contengono questi layer in animazione - VECCHIO campo elimina appena entra a regime quello con array';


--
-- TOC entry 5055 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.webgis_idx_arr; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.webgis_idx_arr IS 'webgis che contengono questi layer in animazione';


--
-- TOC entry 5056 (class 0 OID 0)
-- Dependencies: 198
-- Name: COLUMN animazione_webgis.frame_offset; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN animazione_webgis.frame_offset IS 'moltiplicatore del campo delta_min per non partire da frame al tempo attuale ma recuperarne X istanti indietro';


--
-- TOC entry 199 (class 1259 OID 31286)
-- Name: animazione_webgis_gid_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE animazione_webgis_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE animazione_webgis_gid_seq OWNER TO postgres;

--
-- TOC entry 5058 (class 0 OID 0)
-- Dependencies: 199
-- Name: animazione_webgis_gid_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE animazione_webgis_gid_seq OWNED BY animazione_webgis.gid;


--
-- TOC entry 308 (class 1259 OID 70654618)
-- Name: anomalie_severita; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE anomalie_severita (
    severita_idx integer NOT NULL,
    severita_descr character varying(12),
    impatto_operativo boolean,
    severita_colore character varying(24)
);


ALTER TABLE anomalie_severita OWNER TO postgres;

--
-- TOC entry 5059 (class 0 OID 0)
-- Dependencies: 308
-- Name: TABLE anomalie_severita; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE anomalie_severita IS 'severita delle anomalie, da riportare nella tabella realtime.anomalie';


--
-- TOC entry 200 (class 1259 OID 31288)
-- Name: anomalie_sistemi; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE anomalie_sistemi (
    id_sistema integer NOT NULL,
    descrizione character varying(250),
    data_agg timestamp without time zone DEFAULT now() NOT NULL,
    autore_agg character varying(50) NOT NULL
);


ALTER TABLE anomalie_sistemi OWNER TO postgres;

--
-- TOC entry 5061 (class 0 OID 0)
-- Dependencies: 200
-- Name: TABLE anomalie_sistemi; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE anomalie_sistemi IS 'Tabella dei sistemi RADAR per anomalie';


--
-- TOC entry 201 (class 1259 OID 31292)
-- Name: news_message; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE news_message (
    gid integer NOT NULL,
    messaggio character varying,
    icona_iniziale character varying,
    data_validita date DEFAULT now() NOT NULL,
    data_scadenza date,
    webgis_idx integer[]
);


ALTER TABLE news_message OWNER TO postgres;

--
-- TOC entry 5063 (class 0 OID 0)
-- Dependencies: 201
-- Name: TABLE news_message; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE news_message IS 'messaggi di ultime novita di sviluppo sul webgis da visualizzare sul browser basandosi sui cookies';


--
-- TOC entry 5064 (class 0 OID 0)
-- Dependencies: 201
-- Name: COLUMN news_message.webgis_idx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN news_message.webgis_idx IS 'indici dei webgis su cui deve comparire questa notizia o messaggio. Lasciarlo NULL se messaggio valido per tutti';


--
-- TOC entry 202 (class 1259 OID 31299)
-- Name: news_message_gid_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE news_message_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE news_message_gid_seq OWNER TO postgres;

--
-- TOC entry 5066 (class 0 OID 0)
-- Dependencies: 202
-- Name: news_message_gid_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE news_message_gid_seq OWNED BY news_message.gid;


--
-- TOC entry 203 (class 1259 OID 31301)
-- Name: webgis_groups; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_groups (
    legend_group_name character varying(32),
    pedice character varying(12) NOT NULL,
    group_father character varying(32),
    description character varying(120),
    group_idx integer NOT NULL,
    order_in_webgis integer,
    expanded boolean,
    is_father smallint,
    children_array character varying(32)[]
);


ALTER TABLE webgis_groups OWNER TO postgres;

--
-- TOC entry 5067 (class 0 OID 0)
-- Dependencies: 203
-- Name: TABLE webgis_groups; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_groups IS 'configurazione gruppi dei layers da DB';


--
-- TOC entry 5068 (class 0 OID 0)
-- Dependencies: 203
-- Name: COLUMN webgis_groups.pedice; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_groups.pedice IS 'pedice da usare nella forma ''<!--pedice-->''';


--
-- TOC entry 5069 (class 0 OID 0)
-- Dependencies: 203
-- Name: COLUMN webgis_groups.is_father; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_groups.is_father IS '0: gruppo normale; 1: gruppo padre; -1: sottogruppo';


--
-- TOC entry 5070 (class 0 OID 0)
-- Dependencies: 203
-- Name: COLUMN webgis_groups.children_array; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_groups.children_array IS 'pedici di eventuali sottogruppi figli del gruppo';


--
-- TOC entry 307 (class 1259 OID 70654218)
-- Name: webgis_indici_idx_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE webgis_indici_idx_seq
    START WITH 9
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE webgis_indici_idx_seq OWNER TO postgres;

--
-- TOC entry 204 (class 1259 OID 31307)
-- Name: webgis_indici; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_indici (
    webgis_name character varying(24) NOT NULL,
    webgis_description character varying(200),
    webgis_idx integer DEFAULT nextval('webgis_indici_idx_seq'::regclass) NOT NULL,
    default_raster integer,
    zoom_center integer DEFAULT 8 NOT NULL,
    lon_center double precision DEFAULT 8 NOT NULL,
    lat_center double precision DEFAULT 45 NOT NULL,
    query_map_idx smallint,
    baselayers integer[],
    collapsed_grid boolean DEFAULT true NOT NULL,
    defaultgrid_layeridx integer,
    attivo integer,
    local_path character varying(255) DEFAULT '/iris_base/'::character varying NOT NULL,
    themes_path character varying(255) DEFAULT '/common/tematismi'::character varying NOT NULL,
    scripts_path character varying(255) DEFAULT '/common/scripts'::character varying NOT NULL,
    nomelogo character varying(255) DEFAULT '/common/icons/logo_ArpaPiemonte_transp.png'::character varying NOT NULL,
    urllogo character varying(255) DEFAULT 'http://www.arpa.piemonte.gov.it/'::character varying NOT NULL,
    map_path character varying(255) DEFAULT '/var/www/html/common/mapfiles/'::character varying NOT NULL,
    url_tinyows character varying(255) DEFAULT '/cgi-bin/tinyows'::character varying NOT NULL,
    url_tinyows_sigeo character varying(255) DEFAULT '/cgi-bin/tinyows_sigeo'::character varying NOT NULL,
    titlelogo character varying(32) DEFAULT 'WebGis IRIS'::character varying NOT NULL,
    id_logo_div character varying(32) DEFAULT 'logo'::character varying NOT NULL,
    CONSTRAINT webgis_indici_attivo_check CHECK ((attivo = ANY (ARRAY[0, 1])))
);


ALTER TABLE webgis_indici OWNER TO postgres;

--
-- TOC entry 5072 (class 0 OID 0)
-- Dependencies: 204
-- Name: TABLE webgis_indici; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_indici IS 'indici univoci dei vari webgis attivi, per selezionare i layer da attivare per le animazioni.';


--
-- TOC entry 5073 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.webgis_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.webgis_name IS 'nome del webgis cosi come da TYPE nella url';


--
-- TOC entry 5074 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.webgis_idx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.webgis_idx IS 'indice numerico univoco da associare al webgis';


--
-- TOC entry 5075 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.default_raster; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.default_raster IS 'gid del raster visibile di default dalla tabella animazione_raster';


--
-- TOC entry 5076 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.query_map_idx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.query_map_idx IS 'idx delle azioni da abilitare al clic su mappa richiamando il codice python query_raster.py';


--
-- TOC entry 5077 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.baselayers; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.baselayers IS 'lista degli idx dei baselayers caricati sul servizio, in ordine. Il primo si accende di default';


--
-- TOC entry 5078 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.collapsed_grid; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.collapsed_grid IS 'la griglia attributi deve stare aperta - FALSE, o chiusa - TRUE';


--
-- TOC entry 5079 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.defaultgrid_layeridx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.defaultgrid_layeridx IS 'specificare quale layer mostrare nella griglia attributi. Lasciare NULL per niente. ATTENZIONE! il layer specificato DEVE ESSERE CARICATO sulla mappa altrimenti il servizio crasha';


--
-- TOC entry 5080 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.attivo; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.attivo IS 'Servizio attivo';


--
-- TOC entry 5081 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.local_path; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.local_path IS 'percorso con gli script specifici del servizio';


--
-- TOC entry 5082 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.themes_path; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.themes_path IS 'percorso con la definizione js dei tematismi';


--
-- TOC entry 5083 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.scripts_path; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.scripts_path IS 'percorso di altri script js';


--
-- TOC entry 5084 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.map_path; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.map_path IS 'percorso dei file .map di mapserver';


--
-- TOC entry 5085 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.url_tinyows; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.url_tinyows IS 'percorso eseguibile tinyows principale';


--
-- TOC entry 5086 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN webgis_indici.url_tinyows_sigeo; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_indici.url_tinyows_sigeo IS 'percorso eseguibile tinyows secondario per caricare eventuali altri dati da un altro DB';


--
-- TOC entry 205 (class 1259 OID 31318)
-- Name: webgis_layers; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_layers (
    webgis_idx integer NOT NULL,
    legend_name character varying(120) NOT NULL,
    legend_group_idx integer,
    select_highlight integer,
    visible integer,
    order_in_webgis integer NOT NULL,
    ol_layer_idx integer NOT NULL,
    CONSTRAINT webgis_layers_select_highlight_check CHECK ((select_highlight = ANY (ARRAY[0, 1, 2, 3]))),
    CONSTRAINT webgis_layers_visible_check CHECK ((visible = ANY (ARRAY[0, 1])))
);


ALTER TABLE webgis_layers OWNER TO postgres;

--
-- TOC entry 5088 (class 0 OID 0)
-- Dependencies: 205
-- Name: TABLE webgis_layers; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_layers IS 'configurazione layers da DB associati ai servizi webgis';


--
-- TOC entry 5089 (class 0 OID 0)
-- Dependencies: 205
-- Name: COLUMN webgis_layers.select_highlight; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_layers.select_highlight IS '0-niente;1-solo select;2-select e highlight';


--
-- TOC entry 5090 (class 0 OID 0)
-- Dependencies: 205
-- Name: COLUMN webgis_layers.visible; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_layers.visible IS 'visibile all''avvio del servizio. 0-no; 1-si';


--
-- TOC entry 5091 (class 0 OID 0)
-- Dependencies: 205
-- Name: COLUMN webgis_layers.ol_layer_idx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_layers.ol_layer_idx IS 'indice della variabile OL a cui far iferimento dalla tabella webgis_ol_layers';


--
-- TOC entry 206 (class 1259 OID 31323)
-- Name: webgis_ol_layers; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_ol_layers (
    layer_idx integer NOT NULL,
    openlayer_name character varying(120) NOT NULL,
    default_legend_variable character varying(32),
    db_table_view_name character varying(120) NOT NULL,
    service character varying(32),
    layer_description character varying(255) NOT NULL,
    theme_description character varying(255) NOT NULL,
    ol_cluster_enabled boolean DEFAULT false NOT NULL,
    store_definition character varying(32),
    column_definition character varying(32),
    filter_defined boolean NOT NULL,
    filter_description character varying(255),
    mobile_friendly boolean DEFAULT false NOT NULL,
    geom_type character varying(30),
    geom_srid integer,
    grid_title character varying(200)
);


ALTER TABLE webgis_ol_layers OWNER TO postgres;

--
-- TOC entry 5093 (class 0 OID 0)
-- Dependencies: 206
-- Name: TABLE webgis_ol_layers; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_ol_layers IS 'Layers definiti su OpenLayers. Elenco da tenere aggiornato manualmente in modo da poter aggiungere piu agevolmente i layer ai vari servizi WebGis';


--
-- TOC entry 5094 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.openlayer_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.openlayer_name IS 'nome della variabile data al layer su OL';


--
-- TOC entry 5095 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.default_legend_variable; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.default_legend_variable IS 'nome della variabile con il nome da riportare in legenda';


--
-- TOC entry 5096 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.db_table_view_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.db_table_view_name IS 'Campo NON descrittivo: puntare alla tabella o vista origine del dato!';


--
-- TOC entry 5097 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.service; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.service IS 'mapserver - tinyows - image';


--
-- TOC entry 5098 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.layer_description; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.layer_description IS 'descrizione sommaria di cosa rappresenta il layer';


--
-- TOC entry 5099 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.theme_description; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.theme_description IS 'descrizione di come viene tematizzato il layer con questa variabile';


--
-- TOC entry 5100 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.ol_cluster_enabled; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.ol_cluster_enabled IS 'e attiva la rappresentazione grafica per cluster di OL? 0-no, 1-si';


--
-- TOC entry 5101 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.store_definition; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.store_definition IS 'eventuale variabile che definisce lo store per questo layer';


--
-- TOC entry 5102 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.column_definition; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.column_definition IS 'eventuale variabile che definisce la column_store';


--
-- TOC entry 5103 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.filter_defined; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.filter_defined IS 'vi sono dei filtri definiti DA CODICE per estromettere alcuni dati? 0-no, 1-si';


--
-- TOC entry 5104 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.filter_description; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.filter_description IS 'se presente spiegare in cosa consiste il filtro';


--
-- TOC entry 5105 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.mobile_friendly; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.mobile_friendly IS 'la rappresentazione o il tematismo in se puo andar bene su un dispositivo mobile? 0-no, 1-si';


--
-- TOC entry 5106 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.geom_type; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.geom_type IS 'tipo di geometria - dalla vista geometry_columns';


--
-- TOC entry 5107 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.geom_srid; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.geom_srid IS 'srid del layer - da geometry_columns';


--
-- TOC entry 5108 (class 0 OID 0)
-- Dependencies: 206
-- Name: COLUMN webgis_ol_layers.grid_title; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_ol_layers.grid_title IS 'Titolo da dare alla griglia attributi. Nel caso dei dati RASTER e il riferimento all''immagine da usare come legenda';


--
-- TOC entry 207 (class 1259 OID 31331)
-- Name: v_webgis_custom_settings; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW v_webgis_custom_settings AS
 SELECT main_table.layer_idx,
    main_table.openlayer_name,
    main_table.db_table_view_name,
    main_table.default_legend_variable,
    main_table.service,
    main_table.theme_description,
    main_table.store_definition,
    main_table.column_definition,
    main_table.grid_title,
    main_table.layer_description,
    main_table.filter_defined,
    main_table.filter_description,
    main_table.mobile_friendly,
    main_table.geom_type,
    main_table.geom_srid,
    main_table.webgis_idx,
    main_table.webgis_name,
    main_table.webgis_description,
    main_table.legend_name,
    main_table.select_highlight,
    main_table.visible,
    main_table.order_in_webgis,
    main_table.legend_group_idx,
    main_table.legend_group_name,
    main_table.pedice,
    main_table.is_father,
    main_table.group_father,
    main_table.group_desc,
    main_table.group_order,
    main_table.expanded,
    d.group_idx AS father_group_idx,
    d.legend_group_name AS father_group_name,
    d.pedice AS father_pedice,
    COALESCE((d.is_father)::integer, 0) AS father_is_father,
    array_to_json(d.children_array) AS children_array,
    d.order_in_webgis AS father_group_order,
    (d.expanded)::text AS father_expanded
   FROM (( SELECT webgis_ol_layers.layer_idx,
            webgis_ol_layers.openlayer_name,
            webgis_ol_layers.db_table_view_name,
            webgis_ol_layers.default_legend_variable,
            webgis_ol_layers.service,
            webgis_ol_layers.theme_description,
            webgis_ol_layers.store_definition,
            webgis_ol_layers.column_definition,
            webgis_ol_layers.grid_title,
            webgis_ol_layers.layer_description,
            webgis_ol_layers.filter_defined,
            webgis_ol_layers.filter_description,
            webgis_ol_layers.mobile_friendly,
            webgis_ol_layers.geom_type,
            webgis_ol_layers.geom_srid,
            webgis_layers.webgis_idx,
            webgis_indici.webgis_name,
            webgis_indici.webgis_description,
            webgis_layers.legend_name,
            webgis_layers.select_highlight,
            webgis_layers.visible,
            webgis_layers.order_in_webgis,
            webgis_layers.legend_group_idx,
            webgis_groups.legend_group_name,
            webgis_groups.pedice,
            webgis_groups.is_father,
            webgis_groups.group_father,
            webgis_groups.description AS group_desc,
            webgis_groups.order_in_webgis AS group_order,
            (webgis_groups.expanded)::text AS expanded
           FROM webgis_ol_layers,
            webgis_layers,
            webgis_groups,
            webgis_indici
          WHERE (((webgis_ol_layers.layer_idx = webgis_layers.ol_layer_idx) AND (webgis_layers.webgis_idx = webgis_indici.webgis_idx)) AND (webgis_layers.legend_group_idx = webgis_groups.group_idx))) main_table
     LEFT JOIN webgis_groups d ON (((main_table.group_father)::text = (d.pedice)::text)));


ALTER TABLE v_webgis_custom_settings OWNER TO postgres;

--
-- TOC entry 5110 (class 0 OID 0)
-- Dependencies: 207
-- Name: VIEW v_webgis_custom_settings; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON VIEW v_webgis_custom_settings IS 'Configurazione layers da DB';


--
-- TOC entry 208 (class 1259 OID 31336)
-- Name: webgis_toolbar_tools; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_toolbar_tools (
    tool_idx integer NOT NULL,
    tool_name character varying(32),
    tool_description character varying(255),
    tool_icon character varying(250)
);


ALTER TABLE webgis_toolbar_tools OWNER TO postgres;

--
-- TOC entry 5112 (class 0 OID 0)
-- Dependencies: 208
-- Name: TABLE webgis_toolbar_tools; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_toolbar_tools IS 'strumenti aggiuntivi alla toolbar del webgis';


--
-- TOC entry 5113 (class 0 OID 0)
-- Dependencies: 208
-- Name: COLUMN webgis_toolbar_tools.tool_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_toolbar_tools.tool_name IS 'nome della variabile JS che rappresenta il tool';


--
-- TOC entry 209 (class 1259 OID 31342)
-- Name: webgis_tools; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_tools (
    webgis_idx integer NOT NULL,
    tools_idx integer NOT NULL
);


ALTER TABLE webgis_tools OWNER TO postgres;

--
-- TOC entry 5115 (class 0 OID 0)
-- Dependencies: 209
-- Name: TABLE webgis_tools; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_tools IS 'tools della toolbar attivi pe ciascun webgis. Tavola di appoggio';


--
-- TOC entry 210 (class 1259 OID 31345)
-- Name: v_webgis_general_config; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW v_webgis_general_config AS
 SELECT webgis_indici.webgis_name,
    webgis_indici.webgis_idx,
    webgis_indici.zoom_center,
    webgis_indici.lon_center,
    webgis_indici.lat_center,
    webgis_indici.query_map_idx,
    webgis_indici.baselayers,
    webgis_indici.collapsed_grid,
    webgis_indici.attivo,
    webgis_ol_layers.store_definition AS store_grid,
    webgis_ol_layers.column_definition AS columns_grid,
    webgis_ol_layers.grid_title AS title_grid,
    webgis_tools.tools_idx,
    webgis_toolbar_tools.tool_name,
    webgis_toolbar_tools.tool_icon,
    ((webgis_toolbar_tools.tool_name)::text || '_hidden'::text) AS tools_variable
   FROM (((webgis_indici
     LEFT JOIN webgis_tools ON ((webgis_indici.webgis_idx = webgis_tools.webgis_idx)))
     LEFT JOIN webgis_toolbar_tools ON ((webgis_tools.tools_idx = webgis_toolbar_tools.tool_idx)))
     LEFT JOIN webgis_ol_layers ON ((webgis_indici.defaultgrid_layeridx = webgis_ol_layers.layer_idx)));


ALTER TABLE v_webgis_general_config OWNER TO postgres;

--
-- TOC entry 5117 (class 0 OID 0)
-- Dependencies: 210
-- Name: VIEW v_webgis_general_config; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON VIEW v_webgis_general_config IS 'elenco dei tools da attivare in base al webgis';


--
-- TOC entry 211 (class 1259 OID 31350)
-- Name: v_webgis_ol_layers; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW v_webgis_ol_layers AS
 SELECT webgis_ol_layers.layer_idx,
        CASE
            WHEN (strpos((webgis_ol_layers.db_table_view_name)::text, '/'::text) > 0) THEN 'filesystem'::text
            WHEN (strpos((webgis_ol_layers.db_table_view_name)::text, '@@'::text) > 0) THEN 'wms'::text
            ELSE split_part((webgis_ol_layers.db_table_view_name)::text, '.'::text, 1)
        END AS db,
        CASE
            WHEN (strpos((webgis_ol_layers.db_table_view_name)::text, '/'::text) > 0) THEN 'image'::text
            WHEN (strpos((webgis_ol_layers.db_table_view_name)::text, '@@'::text) > 0) THEN split_part((webgis_ol_layers.db_table_view_name)::text, '@@'::text, 1)
            ELSE split_part((webgis_ol_layers.db_table_view_name)::text, '.'::text, 2)
        END AS schema,
        CASE
            WHEN (strpos((webgis_ol_layers.db_table_view_name)::text, '/'::text) > 0) THEN substr((webgis_ol_layers.db_table_view_name)::text, (length("substring"((webgis_ol_layers.db_table_view_name)::text, '^(.*/)'::text)) + 1))
            WHEN (strpos((webgis_ol_layers.db_table_view_name)::text, '@@'::text) > 0) THEN split_part((webgis_ol_layers.db_table_view_name)::text, '@@'::text, 2)
            ELSE split_part((webgis_ol_layers.db_table_view_name)::text, '.'::text, 3)
        END AS tablename,
    webgis_ol_layers.default_legend_variable,
    webgis_ol_layers.layer_description,
    webgis_ol_layers.theme_description,
    webgis_ol_layers.openlayer_name,
    webgis_ol_layers.service,
        CASE
            WHEN (webgis_ol_layers.store_definition IS NOT NULL) THEN true
            ELSE false
        END AS store,
    webgis_ol_layers.geom_type,
    webgis_ol_layers.mobile_friendly
   FROM webgis_ol_layers
  ORDER BY webgis_ol_layers.db_table_view_name;


ALTER TABLE v_webgis_ol_layers OWNER TO postgres;

--
-- TOC entry 5119 (class 0 OID 0)
-- Dependencies: 211
-- Name: VIEW v_webgis_ol_layers; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON VIEW v_webgis_ol_layers IS 'con alcuni ritocchi sui campi per costruire l''interfaccia web';


--
-- TOC entry 212 (class 1259 OID 31355)
-- Name: webgis_popups; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_popups (
    ol_layer_idx integer NOT NULL,
    webgis_idx integer NOT NULL,
    funzione_associata character varying(64),
    url_link character varying(250),
    url_name character varying(64),
    url_options character varying(250),
    grafici_stazione character varying(64),
    grafici_tab_attivo character varying(64),
    pop_html character varying(1250),
    pop_title character varying(125),
    grafici_valore character varying(64),
    grafici_codice character varying(64),
    grafici_progr character varying(64),
    grafici_tipostaz character varying(64),
    grafici_tiporete character varying(64),
    grafici_composito integer[]
);


ALTER TABLE webgis_popups OWNER TO postgres;

--
-- TOC entry 5121 (class 0 OID 0)
-- Dependencies: 212
-- Name: TABLE webgis_popups; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_popups IS 'eventuali funzioni da attivare al click su elemento di un layer';


--
-- TOC entry 5122 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.webgis_idx; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.webgis_idx IS 'id del webgis sul quale attivare questo tipo di popup per questo tipo di layer';


--
-- TOC entry 5123 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.funzione_associata; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.funzione_associata IS 'funzione da associare al click sul layer. Al momento sono createPopup, open_popup e grafici_rete';


--
-- TOC entry 5124 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.url_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.url_name IS 'nome della finestra popup da aprire';


--
-- TOC entry 5125 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.url_options; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.url_options IS 'opzioni della finestra popup da aprire, come posizione sul monitor e dimensioni';


--
-- TOC entry 5126 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_stazione; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_stazione IS 'per decidere a quale tipo di grafico puntare. I valori saranno vincolati dal codice. In particolare sono gli IF all''interno della funzione "grafici_rete", in js_functions.js. Questa variabile decide anche a quali script successivi puntare per popolare di contenuti la nuova finestra popup.';


--
-- TOC entry 5127 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_tab_attivo; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_tab_attivo IS 'tab da attivare all''apertura del grafico. In genere e'' il nome del parametro';


--
-- TOC entry 5128 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.pop_html; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.pop_html IS 'contenuto html del popup proprio del webgis';


--
-- TOC entry 5129 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.pop_title; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.pop_title IS 'titolo della popup propria del webgis';


--
-- TOC entry 5130 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_valore; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_valore IS 'campo dove si trovano i valori da ordinare per visualizzare il grafico su elementi clusterizzati';


--
-- TOC entry 5131 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_codice; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_codice IS 'campo dove si trova il codice istat per visualizzare il grafico su elementi clusterizzati. Alrimenti indicare l''id della stazione. Al momento il codice non e'' ottimale bisogna anche indicare il nome del nuovo campo nella funzione local_script_db.php e js_function.js. DA MIGLIORARE';


--
-- TOC entry 5132 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_progr; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_progr IS 'campo dove si trova il codice progressivo per visualizzare il grafico su elementi clusterizzati';


--
-- TOC entry 5133 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_tipostaz; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_tipostaz IS 'campo dove si trova il tipo_staz per visualizzare il grafico su elementi clusterizzati';


--
-- TOC entry 5134 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_tiporete; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_tiporete IS 'campo dove si trovano i valori per decidere quale tipo di grafico aprire, in sostanza ''meteoidro'' o ''estero''. Se i dati di origine provengono da una tabella e nond auna vista, per non stravolgere la struttura della tabella aggiungendo il campo "tipo_rete", scrivo qui "grafici_stazione", e nel campo "grafici_stazione" scrivo il tipo di grafico a cui questo popup deve rimandare. Una pezza insomma...';


--
-- TOC entry 5135 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN webgis_popups.grafici_composito; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_popups.grafici_composito IS '1-descrizione anagrafica fuori tab; 2-tab dei grafici; 3-meteogramma; 4-da sviluppare';


--
-- TOC entry 261 (class 1259 OID 23365562)
-- Name: v_webgis_popups; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW v_webgis_popups AS
 SELECT webgis_popups.ol_layer_idx,
    webgis_ol_layers.openlayer_name,
    webgis_ol_layers.default_legend_variable,
    webgis_popups.webgis_idx,
    webgis_popups.funzione_associata,
    webgis_popups.url_link,
    webgis_popups.url_name,
    webgis_popups.url_options,
    webgis_popups.grafici_stazione,
    webgis_popups.grafici_tab_attivo,
    webgis_popups.grafici_valore,
    webgis_popups.grafici_codice,
    webgis_popups.grafici_progr,
    webgis_popups.grafici_tipostaz,
    webgis_popups.grafici_tiporete,
    array_to_string(webgis_popups.grafici_composito, ','::text) AS grafici_composito,
    webgis_popups.pop_html,
    webgis_popups.pop_title
   FROM webgis_ol_layers,
    webgis_popups
  WHERE (webgis_popups.ol_layer_idx = webgis_ol_layers.layer_idx);


ALTER TABLE v_webgis_popups OWNER TO postgres;

--
-- TOC entry 5137 (class 0 OID 0)
-- Dependencies: 261
-- Name: VIEW v_webgis_popups; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON VIEW v_webgis_popups IS 'vista che raggruppa le azioni di clic su elementi dei layer per aprire eventuali popup, link esterni, etc';


--
-- TOC entry 213 (class 1259 OID 31365)
-- Name: webgis_base_layers; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_base_layers (
    baselayer_idx integer NOT NULL,
    openlayer_name character varying(120) NOT NULL,
    layer_legend_name character varying(32) NOT NULL,
    layer_description character varying(255) NOT NULL,
    geom_srid integer
);


ALTER TABLE webgis_base_layers OWNER TO postgres;

--
-- TOC entry 5139 (class 0 OID 0)
-- Dependencies: 213
-- Name: TABLE webgis_base_layers; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_base_layers IS 'Layers di base definiti su OpenLayers. Elenco da tenere aggiornato manualmente in modo da poter aggiungere piu agevolmente i layer ai vari servizi WebGis';


--
-- TOC entry 5140 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN webgis_base_layers.openlayer_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_base_layers.openlayer_name IS 'nome della variabile data al layer di base su OL';


--
-- TOC entry 5141 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN webgis_base_layers.layer_legend_name; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_base_layers.layer_legend_name IS 'nome del layer cosi come riportato in legenda';


--
-- TOC entry 5142 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN webgis_base_layers.layer_description; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_base_layers.layer_description IS 'descrizione sommaria di cosa rappresenta il layer';


--
-- TOC entry 5143 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN webgis_base_layers.geom_srid; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN webgis_base_layers.geom_srid IS 'srid del layer';


--
-- TOC entry 214 (class 1259 OID 31368)
-- Name: webgis_base_layers_baselayer_idx_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE webgis_base_layers_baselayer_idx_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE webgis_base_layers_baselayer_idx_seq OWNER TO postgres;

--
-- TOC entry 5145 (class 0 OID 0)
-- Dependencies: 214
-- Name: webgis_base_layers_baselayer_idx_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE webgis_base_layers_baselayer_idx_seq OWNED BY webgis_base_layers.baselayer_idx;


--
-- TOC entry 215 (class 1259 OID 31370)
-- Name: webgis_groups_group_idx_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE webgis_groups_group_idx_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE webgis_groups_group_idx_seq OWNER TO postgres;

--
-- TOC entry 5146 (class 0 OID 0)
-- Dependencies: 215
-- Name: webgis_groups_group_idx_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE webgis_groups_group_idx_seq OWNED BY webgis_groups.group_idx;


--
-- TOC entry 216 (class 1259 OID 31372)
-- Name: webgis_ol_layers_layer_idx_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE webgis_ol_layers_layer_idx_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE webgis_ol_layers_layer_idx_seq OWNER TO postgres;

--
-- TOC entry 5147 (class 0 OID 0)
-- Dependencies: 216
-- Name: webgis_ol_layers_layer_idx_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE webgis_ol_layers_layer_idx_seq OWNED BY webgis_ol_layers.layer_idx;


--
-- TOC entry 217 (class 1259 OID 31374)
-- Name: webgis_query_map; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_query_map (
    query_map_idx smallint NOT NULL,
    query_description character varying(120)
);


ALTER TABLE webgis_query_map OWNER TO postgres;

--
-- TOC entry 5148 (class 0 OID 0)
-- Dependencies: 217
-- Name: TABLE webgis_query_map; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_query_map IS 'funzioni da attivare al click su mappa - scenari di attivazione dello script query_raster.py';


--
-- TOC entry 218 (class 1259 OID 31377)
-- Name: webgis_target; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE webgis_target (
    webgis_idx integer NOT NULL,
    radius integer NOT NULL,
    udm text,
    the_geom public.geometry(LineString,32632)
);


ALTER TABLE webgis_target OWNER TO postgres;

--
-- TOC entry 5150 (class 0 OID 0)
-- Dependencies: 218
-- Name: TABLE webgis_target; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE webgis_target IS 'Linee concentriche da un bersaglio';


--
-- TOC entry 219 (class 1259 OID 31383)
-- Name: webgis_toolbar_tools_tool_idx_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE webgis_toolbar_tools_tool_idx_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE webgis_toolbar_tools_tool_idx_seq OWNER TO postgres;

--
-- TOC entry 5152 (class 0 OID 0)
-- Dependencies: 219
-- Name: webgis_toolbar_tools_tool_idx_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE webgis_toolbar_tools_tool_idx_seq OWNED BY webgis_toolbar_tools.tool_idx;


SET search_path = dati_di_base, pg_catalog;

--
-- TOC entry 244 (class 1259 OID 8661538)
-- Name: anagraficasensori; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE anagraficasensori (
    idstazione integer NOT NULL,
    idrete integer,
    proprieta character(25),
    provincia character(2),
    comune character varying(50),
    attributo character varying(50),
    utm_nord integer,
    utm_est integer,
    quota integer,
    idsensore integer NOT NULL,
    nometipologia character varying(5),
    altezza real,
    frequenza integer,
    fiume character varying(25),
    bacino character varying(50),
    the_geom public.geometry(Point,32632),
    datainizio date,
    datafine date,
    storico character varying(3),
    codice_im character varying(5),
    listanera character varying(1)
);


ALTER TABLE anagraficasensori OWNER TO postgres;

--
-- TOC entry 5153 (class 0 OID 0)
-- Dependencies: 244
-- Name: TABLE anagraficasensori; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE anagraficasensori IS 'Anagrafica sensori da DB METEO';


--
-- TOC entry 5154 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN anagraficasensori.codice_im; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON COLUMN anagraficasensori.codice_im IS 'codice area di allerta dove ricade il sensore';


--
-- TOC entry 252 (class 1259 OID 10118399)
-- Name: aree_allerta; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE aree_allerta (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,32632),
    objectid integer,
    fid_aree_i integer,
    cod_reg character varying(50),
    nome_reg character varying(40),
    shape_leng double precision,
    shape_area double precision,
    nome_im character varying(40),
    codice_im character varying(6)
);


ALTER TABLE aree_allerta OWNER TO postgres;

--
-- TOC entry 251 (class 1259 OID 10118397)
-- Name: aree_allerta_id_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE aree_allerta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aree_allerta_id_seq OWNER TO postgres;

--
-- TOC entry 5155 (class 0 OID 0)
-- Dependencies: 251
-- Name: aree_allerta_id_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE aree_allerta_id_seq OWNED BY aree_allerta.gid;


--
-- TOC entry 254 (class 1259 OID 10639969)
-- Name: bacini; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE bacini (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,3003),
    bacini_agg character varying(30),
    area integer
);


ALTER TABLE bacini OWNER TO postgres;

--
-- TOC entry 253 (class 1259 OID 10639967)
-- Name: bacini_id_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE bacini_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bacini_id_seq OWNER TO postgres;

--
-- TOC entry 5156 (class 0 OID 0)
-- Dependencies: 253
-- Name: bacini_id_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE bacini_id_seq OWNED BY bacini.gid;


--
-- TOC entry 303 (class 1259 OID 54816596)
-- Name: corpi_idrici_artif; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE corpi_idrici_artif (
    gid integer NOT NULL,
    the_geom public.geometry(MultiLineStringZ,32632),
    objectid integer,
    regione character varying(254),
    codice_ci_ character varying(254),
    nome_ci_pd character varying(254)
);


ALTER TABLE corpi_idrici_artif OWNER TO postgres;

--
-- TOC entry 302 (class 1259 OID 54816594)
-- Name: corpi_idri_artif_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE corpi_idri_artif_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE corpi_idri_artif_gid_seq OWNER TO postgres;

--
-- TOC entry 5157 (class 0 OID 0)
-- Dependencies: 302
-- Name: corpi_idri_artif_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE corpi_idri_artif_gid_seq OWNED BY corpi_idrici_artif.gid;


--
-- TOC entry 297 (class 1259 OID 54211014)
-- Name: corpi_idrici_nat; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE corpi_idrici_nat (
    gid integer NOT NULL,
    the_geom public.geometry(MultiLineStringZ,32632),
    objectid integer,
    regione character varying(254),
    codice_ci_ character varying(254),
    nome_ci_pd character varying(254)
);


ALTER TABLE corpi_idrici_nat OWNER TO postgres;

--
-- TOC entry 296 (class 1259 OID 54211012)
-- Name: corpi_idrici_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE corpi_idrici_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE corpi_idrici_gid_seq OWNER TO postgres;

--
-- TOC entry 5158 (class 0 OID 0)
-- Dependencies: 296
-- Name: corpi_idrici_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE corpi_idrici_gid_seq OWNED BY corpi_idrici_nat.gid;


--
-- TOC entry 273 (class 1259 OID 41373445)
-- Name: fiumi; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE fiumi (
    gid integer NOT NULL,
    the_geom public.geometry(MultiLineString,32632),
    des_topo character varying(254),
    cod_pro character varying(254),
    objectid character varying(254),
    idt character varying(254),
    nome_pro character varying(254),
    sig_pro character varying(254),
    foce character varying(254),
    idt_n character varying(254),
    topo_princ character varying(254),
    note character varying(254),
    tipo_topo character varying(254),
    des_princ character varying(254)
);


ALTER TABLE fiumi OWNER TO postgres;

--
-- TOC entry 272 (class 1259 OID 41373443)
-- Name: fiumi_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE fiumi_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fiumi_gid_seq OWNER TO postgres;

--
-- TOC entry 5159 (class 0 OID 0)
-- Dependencies: 272
-- Name: fiumi_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE fiumi_gid_seq OWNED BY fiumi.gid;


--
-- TOC entry 299 (class 1259 OID 54211417)
-- Name: laghi; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE laghi (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,32632),
    objectid integer,
    regione character varying(254),
    codice_ci_ character varying(254),
    nome_ci_pd character varying(254)
);


ALTER TABLE laghi OWNER TO postgres;

--
-- TOC entry 298 (class 1259 OID 54211415)
-- Name: laghi_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE laghi_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE laghi_gid_seq OWNER TO postgres;

--
-- TOC entry 5160 (class 0 OID 0)
-- Dependencies: 298
-- Name: laghi_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE laghi_gid_seq OWNED BY laghi.gid;


--
-- TOC entry 275 (class 1259 OID 41443262)
-- Name: limite_regionale; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE limite_regionale (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,3003)
);


ALTER TABLE limite_regionale OWNER TO postgres;

--
-- TOC entry 274 (class 1259 OID 41443260)
-- Name: limite_regionale_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE limite_regionale_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE limite_regionale_gid_seq OWNER TO postgres;

--
-- TOC entry 5161 (class 0 OID 0)
-- Dependencies: 274
-- Name: limite_regionale_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE limite_regionale_gid_seq OWNED BY limite_regionale.gid;


--
-- TOC entry 220 (class 1259 OID 31429)
-- Name: limiti_amministrativi; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE limiti_amministrativi (
    gid integer NOT NULL,
    localita character varying(254),
    comune character varying(254),
    regione character varying(50),
    provincia character varying(50),
    sigla_pro character varying(3),
    sigla_naz character varying(8),
    pop_2001 integer,
    warning_class smallint,
    the_geom public.geometry(MultiPolygon,32632),
    istat_2014 character varying(12),
    pop_2011 integer
);


ALTER TABLE limiti_amministrativi OWNER TO postgres;

--
-- TOC entry 5162 (class 0 OID 0)
-- Dependencies: 220
-- Name: TABLE limiti_amministrativi; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE limiti_amministrativi IS 'Limiti amministrativi Italia del nord e nazioni limitrofe, inclusi i mari. Da shapefiles ISTAT 2014 ed europei';


--
-- TOC entry 221 (class 1259 OID 31435)
-- Name: limiti_amministrativi_2014_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE limiti_amministrativi_2014_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE limiti_amministrativi_2014_gid_seq OWNER TO postgres;

--
-- TOC entry 5164 (class 0 OID 0)
-- Dependencies: 221
-- Name: limiti_amministrativi_2014_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE limiti_amministrativi_2014_gid_seq OWNED BY limiti_amministrativi.gid;


--
-- TOC entry 269 (class 1259 OID 28118666)
-- Name: limiti_comunali; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE limiti_comunali (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,3003),
    nome_com character varying(40)
);


ALTER TABLE limiti_comunali OWNER TO postgres;

--
-- TOC entry 268 (class 1259 OID 28118664)
-- Name: limiti_comunali_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE limiti_comunali_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE limiti_comunali_gid_seq OWNER TO postgres;

--
-- TOC entry 5165 (class 0 OID 0)
-- Dependencies: 268
-- Name: limiti_comunali_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE limiti_comunali_gid_seq OWNED BY limiti_comunali.gid;


--
-- TOC entry 271 (class 1259 OID 28170175)
-- Name: limiti_provinciali; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE limiti_provinciali (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,32632),
    nome character varying(40),
    sigla character varying(2)
);


ALTER TABLE limiti_provinciali OWNER TO postgres;

--
-- TOC entry 270 (class 1259 OID 28170173)
-- Name: limiti_provinciali_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE limiti_provinciali_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE limiti_provinciali_gid_seq OWNER TO postgres;

--
-- TOC entry 5166 (class 0 OID 0)
-- Dependencies: 270
-- Name: limiti_provinciali_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE limiti_provinciali_gid_seq OWNED BY limiti_provinciali.gid;


--
-- TOC entry 279 (class 1259 OID 41478799)
-- Name: lspp_d1; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE lspp_d1 (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,32632),
    cat character varying(254),
    "row" character varying(254),
    col character varying(254),
    "tr-200anni" character varying(254),
    "tr-100anni" character varying(254),
    "tr-50anni" character varying(254),
    "tr-20anni" character varying(254),
    "tr-10anni" character varying(254),
    "tr-5anni" character varying(254),
    "tr-2anni" character varying(254),
    durata character varying(254)
);


ALTER TABLE lspp_d1 OWNER TO postgres;

--
-- TOC entry 278 (class 1259 OID 41478797)
-- Name: lspp_d1_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE lspp_d1_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lspp_d1_gid_seq OWNER TO postgres;

--
-- TOC entry 5167 (class 0 OID 0)
-- Dependencies: 278
-- Name: lspp_d1_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE lspp_d1_gid_seq OWNED BY lspp_d1.gid;


--
-- TOC entry 281 (class 1259 OID 41478814)
-- Name: lspp_d2; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE lspp_d2 (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,32632),
    cat character varying(254),
    "row" character varying(254),
    col character varying(254),
    "tr-200anni" character varying(254),
    "tr-100anni" character varying(254),
    "tr-50anni" character varying(254),
    "tr-20anni" character varying(254),
    "tr-10anni" character varying(254),
    "tr-5anni" character varying(254),
    "tr-2anni" character varying(254),
    durata character varying(254)
);


ALTER TABLE lspp_d2 OWNER TO postgres;

--
-- TOC entry 280 (class 1259 OID 41478812)
-- Name: lspp_d2_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE lspp_d2_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lspp_d2_gid_seq OWNER TO postgres;

--
-- TOC entry 5168 (class 0 OID 0)
-- Dependencies: 280
-- Name: lspp_d2_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE lspp_d2_gid_seq OWNED BY lspp_d2.gid;


--
-- TOC entry 305 (class 1259 OID 54851233)
-- Name: portate_naturali; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE portate_naturali (
    gid integer NOT NULL,
    the_geom public.geometry(MultiPolygon,32632),
    ci_nome character varying(47),
    ci_codice character varying(21),
    area_kmq double precision,
    portata_annua numeric(6,2),
    portata_gen numeric(6,2),
    portata_feb numeric(6,2),
    portata_mar numeric(6,2),
    portata_apr numeric(6,2),
    portata_mag numeric(6,2),
    portata_giu numeric(6,2),
    portata_lug numeric(6,2),
    portata_ago numeric(6,2),
    portata_set numeric(6,2),
    portata_ott numeric(6,2),
    portata_nov numeric(6,2),
    portata_dic numeric(6,2),
    metodo character varying(254)
);


ALTER TABLE portate_naturali OWNER TO postgres;

--
-- TOC entry 304 (class 1259 OID 54851231)
-- Name: portate_naturali_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE portate_naturali_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE portate_naturali_gid_seq OWNER TO postgres;

--
-- TOC entry 5169 (class 0 OID 0)
-- Dependencies: 304
-- Name: portate_naturali_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE portate_naturali_gid_seq OWNED BY portate_naturali.gid;


--
-- TOC entry 222 (class 1259 OID 31437)
-- Name: province; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE province (
    province integer NOT NULL,
    the_geom public.geometry,
    area double precision,
    perimeter double precision,
    cod_reg integer,
    provname character varying(60),
    provabbr character varying(10),
    nation integer,
    cntryname character varying(60),
    cntryabbr character varying(10),
    CONSTRAINT enforce_dims_geom CHECK ((public.st_ndims(the_geom) = 2)),
    CONSTRAINT enforce_geotype_geom CHECK (((public.geometrytype(the_geom) = 'MULTIPOLYGON'::text) OR (the_geom IS NULL))),
    CONSTRAINT enforce_srid_geom CHECK ((public.st_srid(the_geom) = 32632))
);


ALTER TABLE province OWNER TO postgres;

--
-- TOC entry 5170 (class 0 OID 0)
-- Dependencies: 222
-- Name: TABLE province; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE province IS 'province italiane';


--
-- TOC entry 223 (class 1259 OID 31446)
-- Name: radar_visibility; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE radar_visibility (
    gid integer NOT NULL,
    id integer,
    aslm double precision,
    the_geom public.geometry,
    CONSTRAINT enforce_dims_the_geom CHECK ((public.st_ndims(the_geom) = 2)),
    CONSTRAINT enforce_geotype_the_geom CHECK (((public.geometrytype(the_geom) = 'MULTILINESTRING'::text) OR (the_geom IS NULL))),
    CONSTRAINT enforce_srid_the_geom CHECK ((public.st_srid(the_geom) = 23032))
);


ALTER TABLE radar_visibility OWNER TO postgres;

--
-- TOC entry 5172 (class 0 OID 0)
-- Dependencies: 223
-- Name: TABLE radar_visibility; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE radar_visibility IS 'Visibilita'' dei radar piemontesi - linee';


--
-- TOC entry 224 (class 1259 OID 31455)
-- Name: radar_visibility4000poly; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE radar_visibility4000poly (
    gid integer NOT NULL,
    id integer,
    aslm double precision,
    the_geom public.geometry,
    CONSTRAINT enforce_dims_the_geom CHECK ((public.st_ndims(the_geom) = 2)),
    CONSTRAINT enforce_geotype_the_geom CHECK (((public.geometrytype(the_geom) = 'POLYGON'::text) OR (the_geom IS NULL))),
    CONSTRAINT enforce_srid_the_geom CHECK ((public.st_srid(the_geom) = 23032))
);


ALTER TABLE radar_visibility4000poly OWNER TO postgres;

--
-- TOC entry 5174 (class 0 OID 0)
-- Dependencies: 224
-- Name: TABLE radar_visibility4000poly; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE radar_visibility4000poly IS 'Visibilita'' a 4000mt dei radar piemontesi - poligono';


--
-- TOC entry 225 (class 1259 OID 31464)
-- Name: radar_visibility4000poly_gid2_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE radar_visibility4000poly_gid2_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE radar_visibility4000poly_gid2_seq OWNER TO postgres;

--
-- TOC entry 5176 (class 0 OID 0)
-- Dependencies: 225
-- Name: radar_visibility4000poly_gid2_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE radar_visibility4000poly_gid2_seq OWNED BY radar_visibility4000poly.gid;


--
-- TOC entry 226 (class 1259 OID 31466)
-- Name: radar_visibility_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE radar_visibility_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE radar_visibility_gid_seq OWNER TO postgres;

--
-- TOC entry 5177 (class 0 OID 0)
-- Dependencies: 226
-- Name: radar_visibility_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE radar_visibility_gid_seq OWNED BY radar_visibility.gid;


--
-- TOC entry 227 (class 1259 OID 31468)
-- Name: regioni; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE regioni (
    id integer NOT NULL,
    the_geom public.geometry,
    area double precision,
    perimeter double precision,
    cod_reg integer,
    nome_reg character varying(35),
    CONSTRAINT enforce_dims_geom CHECK ((public.st_ndims(the_geom) = 2)),
    CONSTRAINT enforce_geotype_geom CHECK (((public.geometrytype(the_geom) = 'MULTIPOLYGON'::text) OR (the_geom IS NULL))),
    CONSTRAINT enforce_srid_geom CHECK ((public.st_srid(the_geom) = 32632))
);


ALTER TABLE regioni OWNER TO postgres;

--
-- TOC entry 5178 (class 0 OID 0)
-- Dependencies: 227
-- Name: TABLE regioni; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE regioni IS 'regioni italiane';


--
-- TOC entry 228 (class 1259 OID 31477)
-- Name: regioni_id_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE regioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE regioni_id_seq OWNER TO postgres;

--
-- TOC entry 5179 (class 0 OID 0)
-- Dependencies: 228
-- Name: regioni_id_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE regioni_id_seq OWNED BY regioni.id;


--
-- TOC entry 229 (class 1259 OID 31503)
-- Name: reticolo_idro_nw; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE reticolo_idro_nw (
    gid integer NOT NULL,
    id_fiume integer,
    id_tratta integer,
    tipo character varying(16),
    nome character varying(35),
    foglio_igm character varying(25),
    sottotipo integer,
    ordine integer,
    bacino_pri character varying(35),
    bacino character varying(35),
    da character varying(35),
    tipo_da integer,
    a character varying(35),
    tipo_a integer,
    the_geom public.geometry,
    publish smallint,
    CONSTRAINT enforce_dims_the_geom CHECK ((public.st_ndims(the_geom) = 2)),
    CONSTRAINT enforce_geotype_the_geom CHECK (((public.geometrytype(the_geom) = 'LINESTRING'::text) OR (the_geom IS NULL))),
    CONSTRAINT enforce_srid_the_geom CHECK ((public.st_srid(the_geom) = 32632))
);


ALTER TABLE reticolo_idro_nw OWNER TO postgres;

--
-- TOC entry 5180 (class 0 OID 0)
-- Dependencies: 229
-- Name: TABLE reticolo_idro_nw; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON TABLE reticolo_idro_nw IS 'Da shpfile reticolo_idrografico nazionale,tagliato sulle regioni del NW';


--
-- TOC entry 230 (class 1259 OID 31512)
-- Name: reticolo_idro_nw_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE reticolo_idro_nw_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reticolo_idro_nw_gid_seq OWNER TO postgres;

--
-- TOC entry 5182 (class 0 OID 0)
-- Dependencies: 230
-- Name: reticolo_idro_nw_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE reticolo_idro_nw_gid_seq OWNED BY reticolo_idro_nw.gid;


--
-- TOC entry 259 (class 1259 OID 12638256)
-- Name: soglie_idrometriche; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE soglie_idrometriche (
    idsensore integer NOT NULL,
    ordinaria double precision,
    moderata double precision,
    elevata double precision
);


ALTER TABLE soglie_idrometriche OWNER TO postgres;

--
-- TOC entry 277 (class 1259 OID 41478675)
-- Name: torrenti; Type: TABLE; Schema: dati_di_base; Owner: postgres
--

CREATE TABLE torrenti (
    gid integer NOT NULL,
    the_geom public.geometry(MultiLineString,32632),
    nome_rs character varying(254),
    sum_length character varying(254)
);


ALTER TABLE torrenti OWNER TO postgres;

--
-- TOC entry 276 (class 1259 OID 41478673)
-- Name: torrenti_gid_seq; Type: SEQUENCE; Schema: dati_di_base; Owner: postgres
--

CREATE SEQUENCE torrenti_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE torrenti_gid_seq OWNER TO postgres;

--
-- TOC entry 5183 (class 0 OID 0)
-- Dependencies: 276
-- Name: torrenti_gid_seq; Type: SEQUENCE OWNED BY; Schema: dati_di_base; Owner: postgres
--

ALTER SEQUENCE torrenti_gid_seq OWNED BY torrenti.gid;


--
-- TOC entry 250 (class 1259 OID 9201007)
-- Name: v_anagraficasensorialtri; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagraficasensorialtri AS
 SELECT a.idrete AS rete,
    a.denominazione,
    a.idstazione,
    a.quota,
    a.provincia,
    a.altezza,
    a.frequenza,
    (a.the_geom)::public.geometry(Point,32632) AS the_geom,
    a.idstazione AS gid,
    a.nometipologia_dst AS tipo_staz,
        CASE
            WHEN (a.nometipologia_dst ~~ '%I%'::text) THEN 'Idrometrica'::text
            WHEN (a.nometipologia_dst = 'P'::text) THEN 'Pluviometrica'::text
            ELSE 'Meteorologica'::text
        END AS meteo_tab,
    a.nometipologia AS nometipologie,
    a.idsensore AS idsensori,
    a.utm_nord,
    a.utm_est,
    a.proprieta
   FROM ( SELECT anagraficasensori.idstazione,
            max(anagraficasensori.idrete) AS idrete,
            (max((anagraficasensori.proprieta)::text) || ' '::text) AS proprieta,
            max(anagraficasensori.provincia) AS provincia,
            max(anagraficasensori.frequenza) AS frequenza,
            max(anagraficasensori.altezza) AS altezza,
            array_to_string(array_agg(DISTINCT
                CASE
                    WHEN ((anagraficasensori.nometipologia)::text = 'VV'::text) THEN 'V'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'PP'::text) THEN 'P'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'DV'::text) THEN ''::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'UR'::text) THEN 'H'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'DVS'::text) THEN ''::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'VVS'::text) THEN 'V'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'PA'::text) THEN 'B'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'RG'::text) THEN 'R'::character varying
                    ELSE anagraficasensori.nometipologia
                END), ''::text) AS nometipologia_dst,
            array_agg(anagraficasensori.nometipologia) AS nometipologia,
            array_agg(anagraficasensori.idsensore) AS idsensore,
            max((anagraficasensori.the_geom)::text) AS the_geom,
            ((max((anagraficasensori.comune)::text) || ' '::text) || COALESCE(max((anagraficasensori.attributo)::text), ''::text)) AS denominazione,
            max(anagraficasensori.quota) AS quota,
            max(anagraficasensori.utm_nord) AS utm_nord,
            max(anagraficasensori.utm_est) AS utm_est
           FROM anagraficasensori
          WHERE ((anagraficasensori.idrete = ANY (ARRAY[5, 6])) AND ((anagraficasensori.storico)::text = 'No'::text))
          GROUP BY anagraficasensori.idstazione) a;


ALTER TABLE v_anagraficasensorialtri OWNER TO postgres;

--
-- TOC entry 5184 (class 0 OID 0)
-- Dependencies: 250
-- Name: VIEW v_anagraficasensorialtri; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagraficasensorialtri IS 'vista per anagrafica stazioni NON ARPA in tempo reale';


--
-- TOC entry 293 (class 1259 OID 53840025)
-- Name: v_anagrafica_altri_idro; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_altri_idro AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    NULL::text AS codice_im,
    c.ordinaria AS soglia_idro_ordinaria,
    c.moderata AS soglia_idro_moderata,
    c.elevata AS soglia_idro_elevata,
    b.proprieta
   FROM (v_anagraficasensorialtri b
     LEFT JOIN soglie_idrometriche c ON (((c.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(I|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_altri_idro OWNER TO postgres;

--
-- TOC entry 5185 (class 0 OID 0)
-- Dependencies: 293
-- Name: VIEW v_anagrafica_altri_idro; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_altri_idro IS 'Vista anagrafica altri enti su idrometri e relative soglie (se sono state definite)';


--
-- TOC entry 245 (class 1259 OID 8661626)
-- Name: v_anagraficasensori; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagraficasensori AS
 SELECT a.idrete AS rete,
    a.denominazione,
    a.idstazione,
    a.quota,
    a.provincia,
    a.altezza,
    a.frequenza,
    (a.the_geom)::public.geometry(Point,32632) AS the_geom,
    a.idstazione AS gid,
    a.nometipologia_dst AS tipo_staz,
        CASE
            WHEN (a.nometipologia_dst ~~ '%I%'::text) THEN 'Idrometrica'::text
            WHEN (a.nometipologia_dst ~~ '%N%'::text) THEN 'Nivometrica'::text
            WHEN (a.nometipologia_dst = 'P'::text) THEN 'Pluviometrica'::text
            WHEN (a.nometipologia_dst = 'V'::text) THEN 'Anemometrica'::text
            ELSE 'Meteorologica'::text
        END AS meteo_tab,
    a.nometipologia AS nometipologie,
    a.idsensore AS idsensori,
    a.utm_nord,
    a.utm_est,
    a.codice_im,
    a.proprieta
   FROM ( SELECT anagraficasensori.idstazione,
            max((anagraficasensori.codice_im)::text) AS codice_im,
            max(anagraficasensori.idrete) AS idrete,
            (max((anagraficasensori.proprieta)::text) || ' '::text) AS proprieta,
            max(anagraficasensori.provincia) AS provincia,
            max(anagraficasensori.frequenza) AS frequenza,
            max(anagraficasensori.altezza) AS altezza,
            array_to_string(array_agg(DISTINCT
                CASE
                    WHEN ((anagraficasensori.nometipologia)::text = 'VV'::text) THEN 'V'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'PP'::text) THEN 'P'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'DV'::text) THEN ''::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'UR'::text) THEN 'H'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'DVS'::text) THEN ''::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'VVS'::text) THEN 'V'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'PA'::text) THEN 'B'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'RG'::text) THEN 'R'::character varying
                    ELSE anagraficasensori.nometipologia
                END), ''::text) AS nometipologia_dst,
            array_agg(anagraficasensori.nometipologia) AS nometipologia,
            array_agg(anagraficasensori.idsensore) AS idsensore,
            max((anagraficasensori.the_geom)::text) AS the_geom,
            ((max((anagraficasensori.comune)::text) || ' '::text) || COALESCE(max((anagraficasensori.attributo)::text), ''::text)) AS denominazione,
            max(anagraficasensori.quota) AS quota,
            max(anagraficasensori.utm_nord) AS utm_nord,
            max(anagraficasensori.utm_est) AS utm_est
           FROM anagraficasensori
          WHERE ((anagraficasensori.idrete = ANY (ARRAY[1, 2, 4])) AND ((anagraficasensori.storico)::text = 'No'::text))
          GROUP BY anagraficasensori.idstazione) a;


ALTER TABLE v_anagraficasensori OWNER TO postgres;

--
-- TOC entry 5187 (class 0 OID 0)
-- Dependencies: 245
-- Name: VIEW v_anagraficasensori; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagraficasensori IS 'Vista per anagrafica stazioni in tempo reale';


--
-- TOC entry 289 (class 1259 OID 53656302)
-- Name: v_anagrafica_anemo; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_anemo AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    b.proprieta
   FROM v_anagraficasensori b
  WHERE ((b.tipo_staz ~ similar_escape('%(V)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_anemo OWNER TO postgres;

--
-- TOC entry 5189 (class 0 OID 0)
-- Dependencies: 289
-- Name: VIEW v_anagrafica_anemo; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_anemo IS 'Vista anagrafica sugli anemometri Arpa';


--
-- TOC entry 291 (class 1259 OID 53656310)
-- Name: v_anagrafica_baro; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_baro AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    b.proprieta
   FROM v_anagraficasensori b
  WHERE ((b.tipo_staz ~ similar_escape('%(B)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_baro OWNER TO postgres;

--
-- TOC entry 5191 (class 0 OID 0)
-- Dependencies: 291
-- Name: VIEW v_anagrafica_baro; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_baro IS 'Vista anagrafica sui barometri Arpa';


--
-- TOC entry 282 (class 1259 OID 50041886)
-- Name: v_anagrafica_idro; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_idro AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    c.ordinaria AS soglia_idro_ordinaria,
    c.moderata AS soglia_idro_moderata,
    c.elevata AS soglia_idro_elevata,
    b.proprieta
   FROM (v_anagraficasensori b
     LEFT JOIN soglie_idrometriche c ON (((c.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(I|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_idro OWNER TO postgres;

--
-- TOC entry 5193 (class 0 OID 0)
-- Dependencies: 282
-- Name: VIEW v_anagrafica_idro; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_idro IS 'Vista anagrafica su idrometri e relative soglie';


--
-- TOC entry 290 (class 1259 OID 53656306)
-- Name: v_anagrafica_igro; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_igro AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    b.proprieta
   FROM v_anagraficasensori b
  WHERE ((b.tipo_staz ~ similar_escape('%(H|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_igro OWNER TO postgres;

--
-- TOC entry 5195 (class 0 OID 0)
-- Dependencies: 290
-- Name: VIEW v_anagrafica_igro; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_igro IS 'Vista anagrafica sugli igrometri Arpa';


--
-- TOC entry 287 (class 1259 OID 53655111)
-- Name: v_anagrafica_nivo; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_nivo AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    b.proprieta
   FROM v_anagraficasensori b
  WHERE ((b.tipo_staz ~ similar_escape('%(N)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_nivo OWNER TO postgres;

--
-- TOC entry 5197 (class 0 OID 0)
-- Dependencies: 287
-- Name: VIEW v_anagrafica_nivo; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_nivo IS 'Vista anagrafica sui nivometri Arpa';


--
-- TOC entry 284 (class 1259 OID 51197632)
-- Name: v_anagrafica_pluvio; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_pluvio AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    b.proprieta
   FROM v_anagraficasensori b
  WHERE ((b.tipo_staz ~ similar_escape('%(P)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_pluvio OWNER TO postgres;

--
-- TOC entry 5199 (class 0 OID 0)
-- Dependencies: 284
-- Name: VIEW v_anagrafica_pluvio; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_pluvio IS 'Vista anagrafica sui pluviometri Arpa';


--
-- TOC entry 283 (class 1259 OID 50071840)
-- Name: v_anagrafica_soglie_idro; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_soglie_idro AS
 SELECT a.idrete AS rete,
    a.denominazione,
    a.idstazione,
    a.quota,
    a.provincia,
    a.altezza,
    a.frequenza,
    (a.the_geom)::public.geometry(Point,32632) AS the_geom,
    a.idstazione AS gid,
    a.nometipologia_dst AS tipo_staz,
        CASE
            WHEN (a.nometipologia_dst ~~ '%I%'::text) THEN 'Idrometrica'::text
            WHEN (a.nometipologia_dst ~~ '%N%'::text) THEN 'Nivometrica'::text
            WHEN (a.nometipologia_dst = 'P'::text) THEN 'Pluviometrica'::text
            WHEN (a.nometipologia_dst = 'V'::text) THEN 'Anemometrica'::text
            ELSE 'Meteorologica'::text
        END AS meteo_tab,
    a.nometipologia AS nometipologie,
    a.idsensore AS idsensori,
    a.utm_nord,
    a.utm_est,
    a.codice_im,
    c.ordinaria AS soglia_idro_ordinaria,
    c.moderata AS soglia_idro_moderata,
    c.elevata AS soglia_idro_elevata
   FROM (( SELECT anagraficasensori.idstazione,
            max((anagraficasensori.codice_im)::text) AS codice_im,
            max(anagraficasensori.idrete) AS idrete,
            max(anagraficasensori.provincia) AS provincia,
            max(anagraficasensori.frequenza) AS frequenza,
            max(anagraficasensori.altezza) AS altezza,
            array_to_string(array_agg(DISTINCT
                CASE
                    WHEN ((anagraficasensori.nometipologia)::text = 'VV'::text) THEN 'V'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'PP'::text) THEN 'P'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'DV'::text) THEN ''::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'UR'::text) THEN 'H'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'DVS'::text) THEN ''::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'VVS'::text) THEN 'V'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'PA'::text) THEN 'B'::character varying
                    WHEN ((anagraficasensori.nometipologia)::text = 'RG'::text) THEN 'R'::character varying
                    ELSE anagraficasensori.nometipologia
                END), ''::text) AS nometipologia_dst,
            array_agg(anagraficasensori.nometipologia) AS nometipologia,
            array_agg(anagraficasensori.idsensore) AS idsensore,
            max((anagraficasensori.the_geom)::text) AS the_geom,
            ((max((anagraficasensori.comune)::text) || ' '::text) || COALESCE(max((anagraficasensori.attributo)::text), ''::text)) AS denominazione,
            max(anagraficasensori.quota) AS quota,
            max(anagraficasensori.utm_nord) AS utm_nord,
            max(anagraficasensori.utm_est) AS utm_est
           FROM anagraficasensori
          WHERE ((anagraficasensori.storico)::text = 'No'::text)
          GROUP BY anagraficasensori.idstazione) a
     LEFT JOIN soglie_idrometriche c ON (((c.idsensore)::numeric = ANY ((a.idsensore)::numeric[]))));


ALTER TABLE v_anagrafica_soglie_idro OWNER TO postgres;

--
-- TOC entry 5201 (class 0 OID 0)
-- Dependencies: 283
-- Name: VIEW v_anagrafica_soglie_idro; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_soglie_idro IS 'Vista per anagrafica stazioni in tempo reale con relative soglie idro';


--
-- TOC entry 288 (class 1259 OID 53655115)
-- Name: v_anagrafica_termo; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_anagrafica_termo AS
 SELECT b.rete,
    b.denominazione,
    b.idstazione,
    b.quota,
    b.provincia,
    b.altezza,
    b.frequenza,
    b.the_geom,
    b.gid,
    b.tipo_staz,
    b.meteo_tab,
    b.nometipologie,
    b.idsensori,
    b.utm_nord,
    b.utm_est,
    b.codice_im,
    b.proprieta
   FROM v_anagraficasensori b
  WHERE ((b.tipo_staz ~ similar_escape('%(T)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_anagrafica_termo OWNER TO postgres;

--
-- TOC entry 5203 (class 0 OID 0)
-- Dependencies: 288
-- Name: VIEW v_anagrafica_termo; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_anagrafica_termo IS 'Vista anagrafica sui termometri Arpa';


--
-- TOC entry 306 (class 1259 OID 54863848)
-- Name: v_portate_naturali_annuali; Type: VIEW; Schema: dati_di_base; Owner: postgres
--

CREATE VIEW v_portate_naturali_annuali AS
 SELECT portate_naturali.gid,
    portate_naturali.the_geom,
    portate_naturali.ci_nome,
    portate_naturali.ci_codice,
    portate_naturali.area_kmq,
        CASE
            WHEN ((portate_naturali.portata_annua IS NULL) OR (portate_naturali.portata_annua < (0)::numeric)) THEN ((-999))::numeric(6,2)
            ELSE portate_naturali.portata_annua
        END AS portata_annua,
    portate_naturali.metodo,
        CASE
            WHEN ((portate_naturali.metodo)::text = '0'::text) THEN 'RIBASIM'::text
            ELSE 'Regionalizzazione'::text
        END AS bilancio_idrologico
   FROM portate_naturali;


ALTER TABLE v_portate_naturali_annuali OWNER TO postgres;

--
-- TOC entry 5205 (class 0 OID 0)
-- Dependencies: 306
-- Name: VIEW v_portate_naturali_annuali; Type: COMMENT; Schema: dati_di_base; Owner: postgres
--

COMMENT ON VIEW v_portate_naturali_annuali IS 'TEST IRIS Lombardia modellizzazione portate naturali annuali';


SET search_path = public, pg_catalog;

--
-- TOC entry 312 (class 1259 OID 70658581)
-- Name: 'realtime''.'errori_sensori'; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE "'realtime''.'errori_sensori'" (
    index bigint,
    idstazione bigint,
    idsensore bigint,
    codice bigint,
    descrizione text
);


ALTER TABLE "'realtime''.'errori_sensori'" OWNER TO postgres;

--
-- TOC entry 311 (class 1259 OID 70658567)
-- Name: errori_sensori; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE errori_sensori (
    index bigint,
    idstazione bigint,
    idsensore bigint,
    codice bigint,
    descrizione text
);


ALTER TABLE errori_sensori OWNER TO postgres;

--
-- TOC entry 182 (class 1259 OID 30366)
-- Name: geography_columns; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW geography_columns AS
 SELECT current_database() AS f_table_catalog,
    n.nspname AS f_table_schema,
    c.relname AS f_table_name,
    a.attname AS f_geography_column,
    postgis_typmod_dims(a.atttypmod) AS coord_dimension,
    postgis_typmod_srid(a.atttypmod) AS srid,
    postgis_typmod_type(a.atttypmod) AS type
   FROM pg_class c,
    pg_attribute a,
    pg_type t,
    pg_namespace n
  WHERE (((((((t.typname = 'geography'::name) AND (a.attisdropped = false)) AND (a.atttypid = t.oid)) AND (a.attrelid = c.oid)) AND (c.relnamespace = n.oid)) AND (NOT pg_is_other_temp_schema(c.relnamespace))) AND has_table_privilege(c.oid, 'SELECT'::text));


ALTER TABLE geography_columns OWNER TO postgres;

--
-- TOC entry 183 (class 1259 OID 30477)
-- Name: geometry_columns; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW geometry_columns AS
 SELECT (current_database())::character varying(256) AS f_table_catalog,
    (n.nspname)::character varying(256) AS f_table_schema,
    (c.relname)::character varying(256) AS f_table_name,
    (a.attname)::character varying(256) AS f_geometry_column,
    COALESCE(postgis_typmod_dims(a.atttypmod), sn.ndims, 2) AS coord_dimension,
    COALESCE(NULLIF(postgis_typmod_srid(a.atttypmod), 0), sr.srid, 0) AS srid,
    (replace(replace(COALESCE(NULLIF(upper(postgis_typmod_type(a.atttypmod)), 'GEOMETRY'::text), st.type, 'GEOMETRY'::text), 'ZM'::text, ''::text), 'Z'::text, ''::text))::character varying(30) AS type
   FROM ((((((pg_class c
     JOIN pg_attribute a ON (((a.attrelid = c.oid) AND (NOT a.attisdropped))))
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN ( SELECT s.connamespace,
            s.conrelid,
            s.conkey,
            replace(split_part(s.consrc, ''''::text, 2), ')'::text, ''::text) AS type
           FROM pg_constraint s
          WHERE (s.consrc ~~* '%geometrytype(% = %'::text)) st ON ((((st.connamespace = n.oid) AND (st.conrelid = c.oid)) AND (a.attnum = ANY (st.conkey)))))
     LEFT JOIN ( SELECT s.connamespace,
            s.conrelid,
            s.conkey,
            (replace(split_part(s.consrc, ' = '::text, 2), ')'::text, ''::text))::integer AS ndims
           FROM pg_constraint s
          WHERE (s.consrc ~~* '%ndims(% = %'::text)) sn ON ((((sn.connamespace = n.oid) AND (sn.conrelid = c.oid)) AND (a.attnum = ANY (sn.conkey)))))
     LEFT JOIN ( SELECT s.connamespace,
            s.conrelid,
            s.conkey,
            (replace(replace(split_part(s.consrc, ' = '::text, 2), ')'::text, ''::text), '('::text, ''::text))::integer AS srid
           FROM pg_constraint s
          WHERE (s.consrc ~~* '%srid(% = %'::text)) sr ON ((((sr.connamespace = n.oid) AND (sr.conrelid = c.oid)) AND (a.attnum = ANY (sr.conkey)))))
  WHERE (((((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char"])) AND (NOT (c.relname = 'raster_columns'::name))) AND (t.typname = 'geometry'::name)) AND (NOT pg_is_other_temp_schema(c.relnamespace))) AND has_table_privilege(c.oid, 'SELECT'::text));


ALTER TABLE geometry_columns OWNER TO postgres;

--
-- TOC entry 301 (class 1259 OID 54811638)
-- Name: layer_styles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE layer_styles (
    id integer NOT NULL,
    f_table_catalog character varying,
    f_table_schema character varying,
    f_table_name character varying,
    f_geometry_column character varying,
    stylename character varying(30),
    styleqml xml,
    stylesld xml,
    useasdefault boolean,
    description text,
    owner character varying(30),
    ui xml,
    update_time timestamp without time zone DEFAULT now()
);


ALTER TABLE layer_styles OWNER TO postgres;

--
-- TOC entry 300 (class 1259 OID 54811636)
-- Name: layer_styles_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE layer_styles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE layer_styles_id_seq OWNER TO postgres;

--
-- TOC entry 5209 (class 0 OID 0)
-- Dependencies: 300
-- Name: layer_styles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE layer_styles_id_seq OWNED BY layer_styles.id;


--
-- TOC entry 190 (class 1259 OID 31055)
-- Name: raster_columns; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW raster_columns AS
 SELECT current_database() AS r_table_catalog,
    n.nspname AS r_table_schema,
    c.relname AS r_table_name,
    a.attname AS r_raster_column,
    COALESCE(_raster_constraint_info_srid(n.nspname, c.relname, a.attname), ( SELECT st_srid('010100000000000000000000000000000000000000'::geometry) AS st_srid)) AS srid,
    _raster_constraint_info_scale(n.nspname, c.relname, a.attname, 'x'::bpchar) AS scale_x,
    _raster_constraint_info_scale(n.nspname, c.relname, a.attname, 'y'::bpchar) AS scale_y,
    _raster_constraint_info_blocksize(n.nspname, c.relname, a.attname, 'width'::text) AS blocksize_x,
    _raster_constraint_info_blocksize(n.nspname, c.relname, a.attname, 'height'::text) AS blocksize_y,
    COALESCE(_raster_constraint_info_alignment(n.nspname, c.relname, a.attname), false) AS same_alignment,
    COALESCE(_raster_constraint_info_regular_blocking(n.nspname, c.relname, a.attname), false) AS regular_blocking,
    _raster_constraint_info_num_bands(n.nspname, c.relname, a.attname) AS num_bands,
    _raster_constraint_info_pixel_types(n.nspname, c.relname, a.attname) AS pixel_types,
    _raster_constraint_info_nodata_values(n.nspname, c.relname, a.attname) AS nodata_values,
    _raster_constraint_info_out_db(n.nspname, c.relname, a.attname) AS out_db,
    _raster_constraint_info_extent(n.nspname, c.relname, a.attname) AS extent
   FROM pg_class c,
    pg_attribute a,
    pg_type t,
    pg_namespace n
  WHERE (((((((t.typname = 'raster'::name) AND (a.attisdropped = false)) AND (a.atttypid = t.oid)) AND (a.attrelid = c.oid)) AND (c.relnamespace = n.oid)) AND ((c.relkind)::text = ANY ((ARRAY['r'::character(1), 'v'::character(1), 'm'::character(1), 'f'::character(1)])::text[]))) AND (NOT pg_is_other_temp_schema(c.relnamespace)));


ALTER TABLE raster_columns OWNER TO postgres;

--
-- TOC entry 191 (class 1259 OID 31064)
-- Name: raster_overviews; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW raster_overviews AS
 SELECT current_database() AS o_table_catalog,
    n.nspname AS o_table_schema,
    c.relname AS o_table_name,
    a.attname AS o_raster_column,
    current_database() AS r_table_catalog,
    (split_part(split_part(s.consrc, '''::name'::text, 1), ''''::text, 2))::name AS r_table_schema,
    (split_part(split_part(s.consrc, '''::name'::text, 2), ''''::text, 2))::name AS r_table_name,
    (split_part(split_part(s.consrc, '''::name'::text, 3), ''''::text, 2))::name AS r_raster_column,
    (btrim(split_part(s.consrc, ','::text, 2)))::integer AS overview_factor
   FROM pg_class c,
    pg_attribute a,
    pg_type t,
    pg_namespace n,
    pg_constraint s
  WHERE ((((((((((t.typname = 'raster'::name) AND (a.attisdropped = false)) AND (a.atttypid = t.oid)) AND (a.attrelid = c.oid)) AND (c.relnamespace = n.oid)) AND ((c.relkind)::text = ANY ((ARRAY['r'::character(1), 'v'::character(1), 'm'::character(1), 'f'::character(1)])::text[]))) AND (s.connamespace = n.oid)) AND (s.conrelid = c.oid)) AND (s.consrc ~~ '%_overview_constraint(%'::text)) AND (NOT pg_is_other_temp_schema(c.relnamespace)));


ALTER TABLE raster_overviews OWNER TO postgres;

--
-- TOC entry 180 (class 1259 OID 30053)
-- Name: spatial_ref_sys; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE spatial_ref_sys (
    srid integer NOT NULL,
    auth_name character varying(256),
    auth_srid integer,
    srtext character varying(2048),
    proj4text character varying(2048),
    CONSTRAINT spatial_ref_sys_srid_check CHECK (((srid > 0) AND (srid <= 998999)))
);


ALTER TABLE spatial_ref_sys OWNER TO postgres;

SET search_path = realtime, pg_catalog;

--
-- TOC entry 309 (class 1259 OID 70654623)
-- Name: anomalie; Type: TABLE; Schema: realtime; Owner: postgres
--

CREATE TABLE anomalie (
    data_inizio timestamp without time zone NOT NULL,
    data_fine timestamp without time zone,
    id_sistema integer NOT NULL,
    autore character varying(50) NOT NULL,
    data_agg timestamp without time zone DEFAULT now() NOT NULL,
    descrizione character varying(250) NOT NULL,
    severita smallint DEFAULT 1 NOT NULL
);


ALTER TABLE anomalie OWNER TO postgres;

--
-- TOC entry 5213 (class 0 OID 0)
-- Dependencies: 309
-- Name: TABLE anomalie; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON TABLE anomalie IS 'Tabella con le anomalie ai sitemi';


--
-- TOC entry 5214 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN anomalie.autore; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON COLUMN anomalie.autore IS 'Autore che ha inserito l''anomalia';


--
-- TOC entry 5215 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN anomalie.severita; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON COLUMN anomalie.severita IS 'grado di severita dell''anomalia: 1-lieve; 2-moderata; 3-grave anomalia.
Aggiungere ''1'' davanti per eventi senza impatti operativi';


--
-- TOC entry 313 (class 1259 OID 70675235)
-- Name: errori_sensori; Type: TABLE; Schema: realtime; Owner: postgres
--

CREATE TABLE errori_sensori (
    idstazione bigint,
    idsensore bigint,
    codice bigint,
    descrizione text,
    data_e_ora text
);


ALTER TABLE errori_sensori OWNER TO postgres;

--
-- TOC entry 315 (class 1259 OID 71325163)
-- Name: errori_sensori_attuali; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW errori_sensori_attuali AS
 SELECT anagraficasensori.idstazione,
    anagraficasensori.nometipologia,
    anagraficasensori.comune,
    anagraficasensori.idrete,
    anagraficasensori.the_geom,
    anagraficasensori.attributo,
    anagraficasensori.frequenza,
    anagraficasensori.idsensore,
    errori_sensori.data_e_ora,
    errori_sensori.descrizione,
    errori_sensori.codice
   FROM (dati_di_base.anagraficasensori
     JOIN errori_sensori ON ((anagraficasensori.idsensore = errori_sensori.idsensore)));


ALTER TABLE errori_sensori_attuali OWNER TO postgres;

--
-- TOC entry 5217 (class 0 OID 0)
-- Dependencies: 315
-- Name: VIEW errori_sensori_attuali; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW errori_sensori_attuali IS 'vista per riproduzione su GIS';


--
-- TOC entry 231 (class 1259 OID 31590)
-- Name: g_dbstorm_seq; Type: SEQUENCE; Schema: realtime; Owner: postgres
--

CREATE SEQUENCE g_dbstorm_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE g_dbstorm_seq OWNER TO postgres;

SET default_with_oids = true;

--
-- TOC entry 243 (class 1259 OID 35544)
-- Name: m_osservazioni_tr; Type: TABLE; Schema: realtime; Owner: webgis_r
--

CREATE TABLE m_osservazioni_tr (
    idsensore integer NOT NULL,
    nometipologia character(3),
    idoperatore integer NOT NULL,
    data_e_ora timestamp(6) without time zone NOT NULL,
    misura real,
    flag_manuale_dbunico character varying(1),
    flag_manuale character varying(1),
    flag_automatica character varying(1),
    autore character varying(15),
    data timestamp(6) without time zone,
    idutente integer
);


ALTER TABLE m_osservazioni_tr OWNER TO webgis_r;

--
-- TOC entry 314 (class 1259 OID 70675349)
-- Name: mia_prova; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW mia_prova AS
 SELECT anagraficasensori.idstazione,
    anagraficasensori.comune,
    anagraficasensori.idrete,
    anagraficasensori.the_geom,
    anagraficasensori.attributo,
    anagraficasensori.idsensore,
    anagraficasensori.listanera,
    errori_sensori.data_e_ora,
    errori_sensori.descrizione,
    errori_sensori.codice
   FROM (dati_di_base.anagraficasensori
     JOIN errori_sensori ON ((anagraficasensori.idsensore = errori_sensori.idsensore)));


ALTER TABLE mia_prova OWNER TO postgres;

--
-- TOC entry 5219 (class 0 OID 0)
-- Dependencies: 314
-- Name: VIEW mia_prova; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW mia_prova IS 'vista per costruzione tabella con stazioni e sensori che hanno errori di trasmissione';


SET default_with_oids = false;

--
-- TOC entry 255 (class 1259 OID 11422758)
-- Name: soglie_pioggia_12ore; Type: TABLE; Schema: realtime; Owner: postgres
--

CREATE TABLE soglie_pioggia_12ore (
    area character(5) NOT NULL,
    a integer NOT NULL,
    b integer NOT NULL,
    c integer NOT NULL
);


ALTER TABLE soglie_pioggia_12ore OWNER TO postgres;

--
-- TOC entry 5220 (class 0 OID 0)
-- Dependencies: 255
-- Name: TABLE soglie_pioggia_12ore; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON TABLE soglie_pioggia_12ore IS 'soglie pioggia su 12 ore da dgr4599 2015';


--
-- TOC entry 256 (class 1259 OID 11433052)
-- Name: soglie_pioggia_24ore; Type: TABLE; Schema: realtime; Owner: postgres
--

CREATE TABLE soglie_pioggia_24ore (
    area character(5) NOT NULL,
    a integer NOT NULL,
    b integer NOT NULL,
    c integer NOT NULL
);


ALTER TABLE soglie_pioggia_24ore OWNER TO postgres;

--
-- TOC entry 5221 (class 0 OID 0)
-- Dependencies: 256
-- Name: TABLE soglie_pioggia_24ore; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON TABLE soglie_pioggia_24ore IS 'soglie pioggia su 24 ore da dgr4599 2015';


--
-- TOC entry 310 (class 1259 OID 70654640)
-- Name: v_anomalie; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_anomalie AS
 SELECT anomalie_sistemi.id_sistema,
    anomalie_sistemi.descrizione AS sistema,
    anomalie.data_inizio,
    anomalie.data_fine,
    anomalie.descrizione,
    anomalie.autore,
    anomalie.data_agg,
    anomalie.severita,
    anomalie_severita.severita_descr,
    anomalie_severita.impatto_operativo,
    anomalie_severita.severita_colore
   FROM config.anomalie_sistemi,
    anomalie,
    config.anomalie_severita
  WHERE ((anomalie.id_sistema = anomalie_sistemi.id_sistema) AND (anomalie_severita.severita_idx = anomalie.severita))
  ORDER BY anomalie.data_inizio DESC;


ALTER TABLE v_anomalie OWNER TO postgres;

--
-- TOC entry 5222 (class 0 OID 0)
-- Dependencies: 310
-- Name: VIEW v_anomalie; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_anomalie IS 'Anomalie riscontrate nelle apparecchiature radar - per WebGIS';


--
-- TOC entry 294 (class 1259 OID 54069484)
-- Name: v_last_altri_idro; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_altri_idro AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    COALESCE(((foo.ultimovalore)::integer)::text, '-'::text) AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.elevata IS NULL) AND (c.moderata IS NULL)) AND (c.ordinaria IS NULL)) THEN (-1)
            WHEN (foo.ultimovalore >= c.elevata) THEN 3
            WHEN (foo.ultimovalore >= c.moderata) THEN 2
            WHEN (foo.ultimovalore >= c.ordinaria) THEN 1
            ELSE 0
        END AS stato_idro
   FROM ((dati_di_base.v_anagraficasensorialtri b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((meteo_real_time.nometipologia)::text = 'I'::text)
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
     LEFT JOIN dati_di_base.soglie_idrometriche c ON (((c.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(I|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_altri_idro OWNER TO postgres;

--
-- TOC entry 5224 (class 0 OID 0)
-- Dependencies: 294
-- Name: VIEW v_last_altri_idro; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_altri_idro IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di LIVELLO per le stazioni (altri enti) di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS;';


--
-- TOC entry 260 (class 1259 OID 12660980)
-- Name: v_last_idro; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_idro AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    COALESCE(((foo.ultimovalore)::integer)::text, '-'::text) AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.elevata IS NULL) AND (c.moderata IS NULL)) AND (c.ordinaria IS NULL)) THEN (-1)
            WHEN (foo.ultimovalore >= c.elevata) THEN 3
            WHEN (foo.ultimovalore >= c.moderata) THEN 2
            WHEN (foo.ultimovalore >= c.ordinaria) THEN 1
            ELSE 0
        END AS stato_idro
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((meteo_real_time.nometipologia)::text = 'I'::text)
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
     LEFT JOIN dati_di_base.soglie_idrometriche c ON (((c.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(I|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_idro OWNER TO postgres;

--
-- TOC entry 5226 (class 0 OID 0)
-- Dependencies: 260
-- Name: VIEW v_last_idro; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_idro IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di LIVELLO per le stazioni di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS';


--
-- TOC entry 292 (class 1259 OID 53656325)
-- Name: v_last_igro; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_igro AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    foo.ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori
   FROM (dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((((meteo_real_time.nometipologia)::text = 'UR'::text) AND (meteo_real_time.idoperatore = 1)) AND (meteo_real_time.data_e_ora > (timezone('cet'::text, now()) - '02:00:00'::interval)))
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(H)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_igro OWNER TO postgres;

--
-- TOC entry 5228 (class 0 OID 0)
-- Dependencies: 292
-- Name: VIEW v_last_igro; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_igro IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di umidità - etichettatura per WebGIS';


--
-- TOC entry 257 (class 1259 OID 11438158)
-- Name: v_last_nivo; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_nivo AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    foo.ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori
   FROM (dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((meteo_real_time.nometipologia)::text = 'N'::text)
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(N|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_nivo OWNER TO postgres;

--
-- TOC entry 5230 (class 0 OID 0)
-- Dependencies: 257
-- Name: VIEW v_last_nivo; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_nivo IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di LIVELLO NIVOMETRICO per le stazioni di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS';


--
-- TOC entry 249 (class 1259 OID 9200997)
-- Name: v_last_pluvio; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    foo.ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori
   FROM (dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE (((meteo_real_time.nometipologia)::text = 'PP'::text) AND (meteo_real_time.data_e_ora > (timezone('cet'::text, now()) - '02:00:00'::interval)))
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio OWNER TO postgres;

--
-- TOC entry 5232 (class 0 OID 0)
-- Dependencies: 249
-- Name: VIEW v_last_pluvio; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS';


--
-- TOC entry 266 (class 1259 OID 26938591)
-- Name: v_last_pluvio12h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio12h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (c.c)::double precision) THEN 3
            WHEN (foo.cumulata >= (c.b)::double precision) THEN 2
            WHEN (foo.cumulata >= (c.a)::double precision) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_12ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '12:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio12h OWNER TO postgres;

--
-- TOC entry 5234 (class 0 OID 0)
-- Dependencies: 266
-- Name: VIEW v_last_pluvio12h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio12h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 12 ore - etichettatura per WebGIS';


--
-- TOC entry 265 (class 1259 OID 26935987)
-- Name: v_last_pluvio1h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio1h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (c.c)::double precision) THEN 3
            WHEN (foo.cumulata >= (c.b)::double precision) THEN 2
            WHEN (foo.cumulata >= (c.a)::double precision) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_12ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '01:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio1h OWNER TO postgres;

--
-- TOC entry 5236 (class 0 OID 0)
-- Dependencies: 265
-- Name: VIEW v_last_pluvio1h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio1h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time ultima ora - etichettatura per WebGIS';


--
-- TOC entry 267 (class 1259 OID 26939906)
-- Name: v_last_pluvio24h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio24h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (c.c)::double precision) THEN 3
            WHEN (foo.cumulata >= (c.b)::double precision) THEN 2
            WHEN (foo.cumulata >= (c.a)::double precision) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_24ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '24:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio24h OWNER TO postgres;

--
-- TOC entry 5238 (class 0 OID 0)
-- Dependencies: 267
-- Name: VIEW v_last_pluvio24h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio24h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 24 ore - etichettatura per WebGIS';


--
-- TOC entry 262 (class 1259 OID 23781630)
-- Name: v_last_pluvio3h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio3h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (((c.c)::numeric / (12)::numeric))::double precision) THEN 3
            WHEN (foo.cumulata >= (((c.b)::numeric / (12)::numeric))::double precision) THEN 2
            WHEN (foo.cumulata >= (((c.a)::numeric / (12)::numeric))::double precision) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_12ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '03:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio3h OWNER TO postgres;

--
-- TOC entry 5240 (class 0 OID 0)
-- Dependencies: 262
-- Name: VIEW v_last_pluvio3h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio3h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 3 ore - etichettatura per WebGIS';


--
-- TOC entry 285 (class 1259 OID 53397406)
-- Name: v_last_pluvio48h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio48h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (((2)::numeric)::double precision * (c.c)::double precision)) THEN 3
            WHEN (foo.cumulata >= (((2)::numeric)::double precision * (c.b)::double precision)) THEN 2
            WHEN (foo.cumulata >= (((2)::numeric)::double precision * (c.a)::double precision)) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_24ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '48:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio48h OWNER TO postgres;

--
-- TOC entry 5242 (class 0 OID 0)
-- Dependencies: 285
-- Name: VIEW v_last_pluvio48h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio48h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 48 ore - etichettatura per WebGIS';


--
-- TOC entry 263 (class 1259 OID 26895226)
-- Name: v_last_pluvio6h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio6h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (((c.c)::numeric / (2)::numeric))::double precision) THEN 3
            WHEN (foo.cumulata >= (((c.b)::numeric / (2)::numeric))::double precision) THEN 2
            WHEN (foo.cumulata >= (((c.a)::numeric / (2)::numeric))::double precision) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_12ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '06:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio6h OWNER TO postgres;

--
-- TOC entry 5244 (class 0 OID 0)
-- Dependencies: 263
-- Name: VIEW v_last_pluvio6h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio6h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 6 ore - etichettatura per WebGIS';


--
-- TOC entry 286 (class 1259 OID 53630231)
-- Name: v_last_pluvio72h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio72h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= (((2)::numeric)::double precision * (c.c)::double precision)) THEN 3
            WHEN (foo.cumulata >= (((2)::numeric)::double precision * (c.b)::double precision)) THEN 2
            WHEN (foo.cumulata >= (((2)::numeric)::double precision * (c.a)::double precision)) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_24ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '72:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio72h OWNER TO postgres;

--
-- TOC entry 5246 (class 0 OID 0)
-- Dependencies: 286
-- Name: VIEW v_last_pluvio72h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio72h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 72 ore - etichettatura per WebGIS';


--
-- TOC entry 264 (class 1259 OID 26895231)
-- Name: v_last_pluvio9h; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_pluvio9h AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
        CASE
            WHEN (((foo.cumulata)::numeric IS NULL) OR (foo.cumulata < ((0)::numeric)::double precision)) THEN ((-999))::numeric(4,0)
            WHEN ((foo.cumulata)::numeric >= (1)::numeric) THEN (foo.cumulata)::numeric(4,0)
            ELSE (foo.cumulata)::numeric(4,1)
        END AS ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori,
        CASE
            WHEN (((c.c IS NULL) AND (c.b IS NULL)) AND (c.a IS NULL)) THEN (-1)
            WHEN (foo.cumulata >= ((((c.c)::numeric * (4)::numeric) / (3)::numeric))::double precision) THEN 3
            WHEN (foo.cumulata >= ((((c.b)::numeric * (4)::numeric) / (3)::numeric))::double precision) THEN 2
            WHEN (foo.cumulata >= ((((c.a)::numeric * (4)::numeric) / (3)::numeric))::double precision) THEN 1
            WHEN (foo.cumulata >= ((0)::numeric)::double precision) THEN 0
            ELSE (-1)
        END AS stato_meteo
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN soglie_pioggia_12ore c ON ((b.codice_im ~~ (c.area)::text)))
     LEFT JOIN ( SELECT a.idsensore,
            max(a.nometipologia) AS nometipologia,
            max(a.data_e_ora) AS timeultimovalore,
            sum(a.misura) AS cumulata,
            count(a.misura) AS conteggio
           FROM m_osservazioni_tr a
          WHERE (((a.nometipologia = 'PP'::bpchar) AND (a.data_e_ora >= (timezone('cet'::text, now()) - '09:30:00'::interval))) AND (a.data_e_ora <= (timezone('cet'::text, now()) - '00:30:00'::interval)))
          GROUP BY a.idsensore) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(P|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_pluvio9h OWNER TO postgres;

--
-- TOC entry 5248 (class 0 OID 0)
-- Dependencies: 264
-- Name: VIEW v_last_pluvio9h; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_pluvio9h IS 'TEST IRIS LOMBARDIA - cumulata di PRECIPITAZIONE per le stazioni di meteo_real_time nelle ultime 9 ore - etichettatura per WebGIS';


--
-- TOC entry 248 (class 1259 OID 9200991)
-- Name: v_last_raffica; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_raffica AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    foo.ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori
   FROM (dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE (((meteo_real_time.nometipologia)::text = 'VV'::text) AND (meteo_real_time.idoperatore = 3))
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(V|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_raffica OWNER TO postgres;

--
-- TOC entry 5250 (class 0 OID 0)
-- Dependencies: 248
-- Name: VIEW v_last_raffica; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_raffica IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di max di velocità del vento per le stazioni di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS';


--
-- TOC entry 247 (class 1259 OID 8661636)
-- Name: v_last_terma; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_terma AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    foo.ultimovalore,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori
   FROM (dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((((meteo_real_time.nometipologia)::text = 'T'::text) AND (meteo_real_time.idoperatore = 1)) AND (meteo_real_time.data_e_ora > (timezone('cet'::text, now()) - '02:00:00'::interval)))
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(T|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_terma OWNER TO postgres;

--
-- TOC entry 5251 (class 0 OID 0)
-- Dependencies: 247
-- Name: VIEW v_last_terma; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_terma IS 'TEST IRIS LOMBARDIA - ultimo dato registrato di temperatura MEDIA per le stazioni di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS';


--
-- TOC entry 258 (class 1259 OID 12553522)
-- Name: v_last_vento; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_last_vento AS
 SELECT b.idstazione,
    b.denominazione,
    b.tipo_staz,
    b.gid,
    b.the_geom,
    COALESCE(foo2.ultimovalore, (0)::real) AS dirultimo,
    COALESCE(foo.ultimovalore, (((-9999))::numeric)::real) AS ventoultimo,
    foo.timeultimovalore,
    foo.idsensore,
    b.utm_nord,
    b.utm_est,
    b.nometipologie,
    b.idsensori
   FROM ((dati_di_base.v_anagraficasensori b
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((((meteo_real_time.nometipologia)::text = 'VV'::text) AND (meteo_real_time.idoperatore = 1)) AND (meteo_real_time.data_e_ora > (now() - '02:00:00'::interval)))
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo ON (((foo.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
     LEFT JOIN ( SELECT DISTINCT ON (meteo_real_time.idsensore) meteo_real_time.idsensore,
            meteo_real_time.nometipologia,
            meteo_real_time.data_e_ora AS timeultimovalore,
            meteo_real_time.misura AS ultimovalore
           FROM m_osservazioni_tr meteo_real_time
          WHERE ((((meteo_real_time.nometipologia)::text = 'DV'::text) AND (meteo_real_time.idoperatore = 1)) AND (meteo_real_time.data_e_ora > (now() - '02:00:00'::interval)))
          ORDER BY meteo_real_time.idsensore, meteo_real_time.data_e_ora DESC) foo2 ON (((foo2.idsensore)::numeric = ANY ((b.idsensori)::numeric[]))))
  WHERE ((b.tipo_staz ~ similar_escape('%(V|Y)%'::text, NULL::text)) AND (b.meteo_tab !~~ '%Z'::text));


ALTER TABLE v_last_vento OWNER TO postgres;

--
-- TOC entry 5253 (class 0 OID 0)
-- Dependencies: 258
-- Name: VIEW v_last_vento; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_last_vento IS ' TEST IRIS LOMBARDIA - ultimo dato registrato di VENTO per le stazioni di meteo_real_time nelle ultime 2 ore - etichettatura per WebGIS';


--
-- TOC entry 246 (class 1259 OID 8661631)
-- Name: v_meteo_real_time; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_meteo_real_time AS
 SELECT b.idstazione AS id_stazione,
    a.data_e_ora,
    a.idsensore AS id_sensore,
    a.nometipologia AS id_parametro,
    a.misura AS valore_originale,
    a.flag_manuale_dbunico AS tipologia_validaz,
    '??'::text AS flag_validaz_autom,
    '??'::text AS flag_gestore_sistema,
    a.data AS data_agg,
    a.idoperatore,
    b.frequenza,
    b.altezza
   FROM (m_osservazioni_tr a
     LEFT JOIN dati_di_base.v_anagraficasensori b ON ((a.idsensore = ANY (b.idsensori))));


ALTER TABLE v_meteo_real_time OWNER TO postgres;

--
-- TOC entry 5255 (class 0 OID 0)
-- Dependencies: 246
-- Name: VIEW v_meteo_real_time; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_meteo_real_time IS 'TEST IRIS Lombardia per costruzione grafici';


--
-- TOC entry 295 (class 1259 OID 54204931)
-- Name: v_meteo_tot_real_time; Type: VIEW; Schema: realtime; Owner: postgres
--

CREATE VIEW v_meteo_tot_real_time AS
 SELECT b.idstazione AS id_stazione,
    a.data_e_ora,
    a.idsensore AS id_sensore,
    a.nometipologia AS id_parametro,
    a.misura AS valore_originale,
    a.flag_manuale_dbunico AS tipologia_validaz,
    '??'::text AS flag_validaz_autom,
    '??'::text AS flag_gestore_sistema,
    a.data AS data_agg,
    a.idoperatore,
    b.frequenza,
    b.altezza
   FROM (m_osservazioni_tr a
     LEFT JOIN dati_di_base.v_anagrafica_soglie_idro b ON ((a.idsensore = ANY (b.idsensori))));


ALTER TABLE v_meteo_tot_real_time OWNER TO postgres;

--
-- TOC entry 5257 (class 0 OID 0)
-- Dependencies: 295
-- Name: VIEW v_meteo_tot_real_time; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON VIEW v_meteo_tot_real_time IS 'TEST IRIS Lombardia per costruzione grafici';


--
-- TOC entry 232 (class 1259 OID 31835)
-- Name: webgis_tickets; Type: TABLE; Schema: realtime; Owner: postgres
--

CREATE TABLE webgis_tickets (
    gid integer NOT NULL,
    data_apertura timestamp without time zone DEFAULT now() NOT NULL,
    autore character(8) NOT NULL,
    richiesta character varying(250) NOT NULL,
    tipo character varying(24) NOT NULL,
    browser_client character varying(32),
    so_client character varying(32),
    data_chiusura timestamp without time zone,
    webgis character varying(32) DEFAULT 'generico'::character varying,
    autore_chiusura character varying(12),
    note_chiusura character varying(250)
);


ALTER TABLE webgis_tickets OWNER TO postgres;

--
-- TOC entry 5259 (class 0 OID 0)
-- Dependencies: 232
-- Name: TABLE webgis_tickets; Type: COMMENT; Schema: realtime; Owner: postgres
--

COMMENT ON TABLE webgis_tickets IS 'Raccolta delle richieste dei fruitori del servizio webgis IRIS';


--
-- TOC entry 233 (class 1259 OID 31843)
-- Name: webgis_tickets_gid_seq; Type: SEQUENCE; Schema: realtime; Owner: postgres
--

CREATE SEQUENCE webgis_tickets_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE webgis_tickets_gid_seq OWNER TO postgres;

--
-- TOC entry 5261 (class 0 OID 0)
-- Dependencies: 233
-- Name: webgis_tickets_gid_seq; Type: SEQUENCE OWNED BY; Schema: realtime; Owner: postgres
--

ALTER SEQUENCE webgis_tickets_gid_seq OWNED BY webgis_tickets.gid;


SET search_path = topology, pg_catalog;

--
-- TOC entry 194 (class 1259 OID 31092)
-- Name: layer; Type: TABLE; Schema: topology; Owner: postgres
--

CREATE TABLE layer (
    topology_id integer NOT NULL,
    layer_id integer NOT NULL,
    schema_name character varying NOT NULL,
    table_name character varying NOT NULL,
    feature_column character varying NOT NULL,
    feature_type integer NOT NULL,
    level integer DEFAULT 0 NOT NULL,
    child_id integer
);


ALTER TABLE layer OWNER TO postgres;

--
-- TOC entry 193 (class 1259 OID 31079)
-- Name: topology; Type: TABLE; Schema: topology; Owner: postgres
--

CREATE TABLE topology (
    id integer NOT NULL,
    name character varying NOT NULL,
    srid integer NOT NULL,
    "precision" double precision NOT NULL,
    hasz boolean DEFAULT false NOT NULL
);


ALTER TABLE topology OWNER TO postgres;

--
-- TOC entry 192 (class 1259 OID 31077)
-- Name: topology_id_seq; Type: SEQUENCE; Schema: topology; Owner: postgres
--

CREATE SEQUENCE topology_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE topology_id_seq OWNER TO postgres;

--
-- TOC entry 5263 (class 0 OID 0)
-- Dependencies: 192
-- Name: topology_id_seq; Type: SEQUENCE OWNED BY; Schema: topology; Owner: postgres
--

ALTER SEQUENCE topology_id_seq OWNED BY topology.id;


SET search_path = warning, pg_catalog;

--
-- TOC entry 234 (class 1259 OID 31845)
-- Name: warning_area; Type: TABLE; Schema: warning; Owner: postgres
--

CREATE TABLE warning_area (
    id_area integer NOT NULL,
    descrizione character varying(80) NOT NULL,
    the_geom public.geometry NOT NULL,
    lat numeric(7,4),
    lon numeric(7,4),
    utm_x integer,
    utm_y integer,
    CONSTRAINT enforce_dims_the_geom CHECK ((public.st_ndims(the_geom) = 2)),
    CONSTRAINT enforce_geotype_the_geom CHECK (((public.geometrytype(the_geom) = 'POINT'::text) OR (the_geom IS NULL))),
    CONSTRAINT enforce_srid_the_geom CHECK ((public.st_srid(the_geom) = 4326))
);


ALTER TABLE warning_area OWNER TO postgres;

--
-- TOC entry 5264 (class 0 OID 0)
-- Dependencies: 234
-- Name: TABLE warning_area; Type: COMMENT; Schema: warning; Owner: postgres
--

COMMENT ON TABLE warning_area IS 'Tabella per la gestione delle aree di warning per utente';


--
-- TOC entry 5265 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN warning_area.the_geom; Type: COMMENT; Schema: warning; Owner: postgres
--

COMMENT ON COLUMN warning_area.the_geom IS 'Punto in coordinate lat/lon del centro';


--
-- TOC entry 235 (class 1259 OID 31854)
-- Name: warning_levels; Type: TABLE; Schema: warning; Owner: postgres
--

CREATE TABLE warning_levels (
    id_utente integer NOT NULL,
    id_area integer NOT NULL,
    buffer double precision NOT NULL,
    ssi integer NOT NULL,
    poh integer NOT NULL,
    warning_interval integer NOT NULL,
    inizio_validita date DEFAULT now(),
    fine_validita date,
    id_level integer NOT NULL
);


ALTER TABLE warning_levels OWNER TO postgres;

--
-- TOC entry 5267 (class 0 OID 0)
-- Dependencies: 235
-- Name: TABLE warning_levels; Type: COMMENT; Schema: warning; Owner: postgres
--

COMMENT ON TABLE warning_levels IS 'Specifiche delle allerte da inviare agli utenti';


--
-- TOC entry 236 (class 1259 OID 31858)
-- Name: warning_users; Type: TABLE; Schema: warning; Owner: postgres
--

CREATE TABLE warning_users (
    id_utente integer NOT NULL,
    nome character varying(100),
    email character varying(500),
    sms bigint,
    autore character varying(100),
    data_agg date DEFAULT now()
);


ALTER TABLE warning_users OWNER TO postgres;

--
-- TOC entry 5269 (class 0 OID 0)
-- Dependencies: 236
-- Name: TABLE warning_users; Type: COMMENT; Schema: warning; Owner: postgres
--

COMMENT ON TABLE warning_users IS 'Tabella anagrafica utenti da avvisare con email';


--
-- TOC entry 237 (class 1259 OID 31865)
-- Name: v_active_warnings; Type: VIEW; Schema: warning; Owner: postgres
--

CREATE VIEW v_active_warnings AS
 SELECT warning_users.id_utente,
    warning_users.nome,
    warning_users.email,
    warning_users.sms,
    warning_area.id_area,
    warning_area.descrizione,
    warning_area.lat,
    warning_area.lon,
    (warning_area.the_geom)::public.geometry(Point,4326) AS the_geom,
    warning_levels.buffer,
    warning_levels.ssi,
    warning_levels.poh,
    warning_levels.warning_interval,
    warning_levels.inizio_validita,
    warning_levels.fine_validita,
    warning_levels.id_level
   FROM warning_area,
    warning_levels,
    warning_users
  WHERE (((warning_area.id_area = warning_levels.id_area) AND (warning_users.id_utente = warning_levels.id_utente)) AND (warning_levels.fine_validita IS NULL))
  ORDER BY warning_users.id_utente;


ALTER TABLE v_active_warnings OWNER TO postgres;

--
-- TOC entry 238 (class 1259 OID 31870)
-- Name: warning_issued; Type: TABLE; Schema: warning; Owner: postgres
--

CREATE TABLE warning_issued (
    id_utente integer NOT NULL,
    id_area integer NOT NULL,
    id_level integer NOT NULL,
    dataora_issuing timestamp without time zone NOT NULL
);


ALTER TABLE warning_issued OWNER TO postgres;

--
-- TOC entry 5272 (class 0 OID 0)
-- Dependencies: 238
-- Name: TABLE warning_issued; Type: COMMENT; Schema: warning; Owner: postgres
--

COMMENT ON TABLE warning_issued IS 'Allerte inviate agli utenti';


--
-- TOC entry 239 (class 1259 OID 31873)
-- Name: v_warning_issued; Type: VIEW; Schema: warning; Owner: postgres
--

CREATE VIEW v_warning_issued AS
 SELECT warning_users.id_utente,
    warning_users.nome,
    warning_users.email,
    warning_area.id_area,
    warning_area.descrizione,
    warning_levels.buffer,
    warning_levels.ssi,
    warning_levels.poh,
    warning_levels.warning_interval,
    warning_levels.id_level,
    warning_issued.dataora_issuing
   FROM warning_issued,
    warning_users,
    warning_levels,
    warning_area
  WHERE (((warning_users.id_utente = warning_levels.id_utente) AND (warning_levels.id_level = warning_issued.id_level)) AND (warning_area.id_area = warning_levels.id_area));


ALTER TABLE v_warning_issued OWNER TO postgres;

--
-- TOC entry 240 (class 1259 OID 31877)
-- Name: warning_area_id_area_seq; Type: SEQUENCE; Schema: warning; Owner: postgres
--

CREATE SEQUENCE warning_area_id_area_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE warning_area_id_area_seq OWNER TO postgres;

--
-- TOC entry 5274 (class 0 OID 0)
-- Dependencies: 240
-- Name: warning_area_id_area_seq; Type: SEQUENCE OWNED BY; Schema: warning; Owner: postgres
--

ALTER SEQUENCE warning_area_id_area_seq OWNED BY warning_area.id_area;


--
-- TOC entry 241 (class 1259 OID 31879)
-- Name: warning_levels_id_level_seq; Type: SEQUENCE; Schema: warning; Owner: postgres
--

CREATE SEQUENCE warning_levels_id_level_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE warning_levels_id_level_seq OWNER TO postgres;

--
-- TOC entry 5275 (class 0 OID 0)
-- Dependencies: 241
-- Name: warning_levels_id_level_seq; Type: SEQUENCE OWNED BY; Schema: warning; Owner: postgres
--

ALTER SEQUENCE warning_levels_id_level_seq OWNED BY warning_levels.id_level;


--
-- TOC entry 242 (class 1259 OID 31881)
-- Name: warning_users_id_utente_seq; Type: SEQUENCE; Schema: warning; Owner: postgres
--

CREATE SEQUENCE warning_users_id_utente_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE warning_users_id_utente_seq OWNER TO postgres;

--
-- TOC entry 5276 (class 0 OID 0)
-- Dependencies: 242
-- Name: warning_users_id_utente_seq; Type: SEQUENCE OWNED BY; Schema: warning; Owner: postgres
--

ALTER SEQUENCE warning_users_id_utente_seq OWNED BY warning_users.id_utente;


SET search_path = config, pg_catalog;

--
-- TOC entry 4616 (class 2604 OID 31883)
-- Name: gid; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY animazione_webgis ALTER COLUMN gid SET DEFAULT nextval('animazione_webgis_gid_seq'::regclass);


--
-- TOC entry 4619 (class 2604 OID 31884)
-- Name: gid; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY news_message ALTER COLUMN gid SET DEFAULT nextval('news_message_gid_seq'::regclass);


--
-- TOC entry 4643 (class 2604 OID 31885)
-- Name: baselayer_idx; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_base_layers ALTER COLUMN baselayer_idx SET DEFAULT nextval('webgis_base_layers_baselayer_idx_seq'::regclass);


--
-- TOC entry 4620 (class 2604 OID 31886)
-- Name: group_idx; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_groups ALTER COLUMN group_idx SET DEFAULT nextval('webgis_groups_group_idx_seq'::regclass);


--
-- TOC entry 4641 (class 2604 OID 31887)
-- Name: layer_idx; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_ol_layers ALTER COLUMN layer_idx SET DEFAULT nextval('webgis_ol_layers_layer_idx_seq'::regclass);


--
-- TOC entry 4642 (class 2604 OID 31888)
-- Name: tool_idx; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_toolbar_tools ALTER COLUMN tool_idx SET DEFAULT nextval('webgis_toolbar_tools_tool_idx_seq'::regclass);


SET search_path = dati_di_base, pg_catalog;

--
-- TOC entry 4675 (class 2604 OID 10118402)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY aree_allerta ALTER COLUMN gid SET DEFAULT nextval('aree_allerta_id_seq'::regclass);


--
-- TOC entry 4676 (class 2604 OID 10639972)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY bacini ALTER COLUMN gid SET DEFAULT nextval('bacini_id_seq'::regclass);


--
-- TOC entry 4688 (class 2604 OID 54816599)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY corpi_idrici_artif ALTER COLUMN gid SET DEFAULT nextval('corpi_idri_artif_gid_seq'::regclass);


--
-- TOC entry 4684 (class 2604 OID 54211017)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY corpi_idrici_nat ALTER COLUMN gid SET DEFAULT nextval('corpi_idrici_gid_seq'::regclass);


--
-- TOC entry 4679 (class 2604 OID 41373448)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY fiumi ALTER COLUMN gid SET DEFAULT nextval('fiumi_gid_seq'::regclass);


--
-- TOC entry 4685 (class 2604 OID 54211420)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY laghi ALTER COLUMN gid SET DEFAULT nextval('laghi_gid_seq'::regclass);


--
-- TOC entry 4680 (class 2604 OID 41443265)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limite_regionale ALTER COLUMN gid SET DEFAULT nextval('limite_regionale_gid_seq'::regclass);


--
-- TOC entry 4644 (class 2604 OID 31893)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limiti_amministrativi ALTER COLUMN gid SET DEFAULT nextval('limiti_amministrativi_2014_gid_seq'::regclass);


--
-- TOC entry 4677 (class 2604 OID 28118669)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limiti_comunali ALTER COLUMN gid SET DEFAULT nextval('limiti_comunali_gid_seq'::regclass);


--
-- TOC entry 4678 (class 2604 OID 28170178)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limiti_provinciali ALTER COLUMN gid SET DEFAULT nextval('limiti_provinciali_gid_seq'::regclass);


--
-- TOC entry 4682 (class 2604 OID 41478802)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY lspp_d1 ALTER COLUMN gid SET DEFAULT nextval('lspp_d1_gid_seq'::regclass);


--
-- TOC entry 4683 (class 2604 OID 41478817)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY lspp_d2 ALTER COLUMN gid SET DEFAULT nextval('lspp_d2_gid_seq'::regclass);


--
-- TOC entry 4689 (class 2604 OID 54851236)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY portate_naturali ALTER COLUMN gid SET DEFAULT nextval('portate_naturali_gid_seq'::regclass);


--
-- TOC entry 4648 (class 2604 OID 31894)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY radar_visibility ALTER COLUMN gid SET DEFAULT nextval('radar_visibility_gid_seq'::regclass);


--
-- TOC entry 4652 (class 2604 OID 31895)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY radar_visibility4000poly ALTER COLUMN gid SET DEFAULT nextval('radar_visibility4000poly_gid2_seq'::regclass);


--
-- TOC entry 4656 (class 2604 OID 31896)
-- Name: id; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY regioni ALTER COLUMN id SET DEFAULT nextval('regioni_id_seq'::regclass);


--
-- TOC entry 4660 (class 2604 OID 31899)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY reticolo_idro_nw ALTER COLUMN gid SET DEFAULT nextval('reticolo_idro_nw_gid_seq'::regclass);


--
-- TOC entry 4681 (class 2604 OID 41478678)
-- Name: gid; Type: DEFAULT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY torrenti ALTER COLUMN gid SET DEFAULT nextval('torrenti_gid_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- TOC entry 4686 (class 2604 OID 54811641)
-- Name: id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY layer_styles ALTER COLUMN id SET DEFAULT nextval('layer_styles_id_seq'::regclass);


SET search_path = realtime, pg_catalog;

--
-- TOC entry 4666 (class 2604 OID 31905)
-- Name: gid; Type: DEFAULT; Schema: realtime; Owner: postgres
--

ALTER TABLE ONLY webgis_tickets ALTER COLUMN gid SET DEFAULT nextval('webgis_tickets_gid_seq'::regclass);


SET search_path = topology, pg_catalog;

--
-- TOC entry 4613 (class 2604 OID 31082)
-- Name: id; Type: DEFAULT; Schema: topology; Owner: postgres
--

ALTER TABLE ONLY topology ALTER COLUMN id SET DEFAULT nextval('topology_id_seq'::regclass);


SET search_path = warning, pg_catalog;

--
-- TOC entry 4667 (class 2604 OID 31906)
-- Name: id_area; Type: DEFAULT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_area ALTER COLUMN id_area SET DEFAULT nextval('warning_area_id_area_seq'::regclass);


--
-- TOC entry 4672 (class 2604 OID 31907)
-- Name: id_level; Type: DEFAULT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_levels ALTER COLUMN id_level SET DEFAULT nextval('warning_levels_id_level_seq'::regclass);


--
-- TOC entry 4674 (class 2604 OID 31908)
-- Name: id_utente; Type: DEFAULT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_users ALTER COLUMN id_utente SET DEFAULT nextval('warning_users_id_utente_seq'::regclass);


SET search_path = config, pg_catalog;

--
-- TOC entry 4703 (class 2606 OID 35251)
-- Name: animazione_webgis_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY animazione_webgis
    ADD CONSTRAINT animazione_webgis_pkey PRIMARY KEY (gid);


--
-- TOC entry 4814 (class 2606 OID 70654622)
-- Name: anomalie_severita_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY anomalie_severita
    ADD CONSTRAINT anomalie_severita_pkey PRIMARY KEY (severita_idx);


--
-- TOC entry 4707 (class 2606 OID 35253)
-- Name: news_message_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY news_message
    ADD CONSTRAINT news_message_pkey PRIMARY KEY (gid);


--
-- TOC entry 4705 (class 2606 OID 35255)
-- Name: pk_sistema; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY anomalie_sistemi
    ADD CONSTRAINT pk_sistema PRIMARY KEY (id_sistema);


--
-- TOC entry 4733 (class 2606 OID 35257)
-- Name: webgis_base_layers_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_base_layers
    ADD CONSTRAINT webgis_base_layers_pkey PRIMARY KEY (baselayer_idx);


--
-- TOC entry 4709 (class 2606 OID 35259)
-- Name: webgis_groups_group_idx_key; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_groups
    ADD CONSTRAINT webgis_groups_group_idx_key UNIQUE (group_idx);


--
-- TOC entry 4711 (class 2606 OID 35261)
-- Name: webgis_groups_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_groups
    ADD CONSTRAINT webgis_groups_pkey PRIMARY KEY (pedice);


--
-- TOC entry 4713 (class 2606 OID 35263)
-- Name: webgis_indici_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_indici
    ADD CONSTRAINT webgis_indici_pkey PRIMARY KEY (webgis_name);


--
-- TOC entry 4715 (class 2606 OID 35265)
-- Name: webgis_indici_webgis_idx_key; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_indici
    ADD CONSTRAINT webgis_indici_webgis_idx_key UNIQUE (webgis_idx);


--
-- TOC entry 4717 (class 2606 OID 35269)
-- Name: webgis_layers_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_layers
    ADD CONSTRAINT webgis_layers_pkey PRIMARY KEY (ol_layer_idx, webgis_idx);


--
-- TOC entry 4719 (class 2606 OID 35271)
-- Name: webgis_layers_webgis_idx_legend_name_legend_group_idx_key; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_layers
    ADD CONSTRAINT webgis_layers_webgis_idx_legend_name_legend_group_idx_key UNIQUE (webgis_idx, legend_name, legend_group_idx);


--
-- TOC entry 4721 (class 2606 OID 35273)
-- Name: webgis_ol_layers_default_legend_variable_key; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_ol_layers
    ADD CONSTRAINT webgis_ol_layers_default_legend_variable_key UNIQUE (default_legend_variable);


--
-- TOC entry 4723 (class 2606 OID 35275)
-- Name: webgis_ol_layers_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_ol_layers
    ADD CONSTRAINT webgis_ol_layers_pkey PRIMARY KEY (layer_idx);


--
-- TOC entry 4731 (class 2606 OID 35277)
-- Name: webgis_popups_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_popups
    ADD CONSTRAINT webgis_popups_pkey PRIMARY KEY (ol_layer_idx, webgis_idx);


--
-- TOC entry 4735 (class 2606 OID 35279)
-- Name: webgis_query_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_query_map
    ADD CONSTRAINT webgis_query_map_pkey PRIMARY KEY (query_map_idx);


--
-- TOC entry 4737 (class 2606 OID 35281)
-- Name: webgis_target_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_target
    ADD CONSTRAINT webgis_target_pkey PRIMARY KEY (webgis_idx, radius);


--
-- TOC entry 4725 (class 2606 OID 35283)
-- Name: webgis_toolbar_tools_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_toolbar_tools
    ADD CONSTRAINT webgis_toolbar_tools_pkey PRIMARY KEY (tool_idx);


--
-- TOC entry 4727 (class 2606 OID 35285)
-- Name: webgis_toolbar_tools_tool_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_toolbar_tools
    ADD CONSTRAINT webgis_toolbar_tools_tool_name_key UNIQUE (tool_name);


--
-- TOC entry 4729 (class 2606 OID 35287)
-- Name: webgis_tools_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_tools
    ADD CONSTRAINT webgis_tools_pkey PRIMARY KEY (webgis_idx, tools_idx);


SET search_path = dati_di_base, pg_catalog;

--
-- TOC entry 4777 (class 2606 OID 8661542)
-- Name: anagraficasensori_pkey1; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY anagraficasensori
    ADD CONSTRAINT anagraficasensori_pkey1 PRIMARY KEY (idsensore);


--
-- TOC entry 4779 (class 2606 OID 12547689)
-- Name: aree_allerta_codice_im_key; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY aree_allerta
    ADD CONSTRAINT aree_allerta_codice_im_key UNIQUE (codice_im);


--
-- TOC entry 4781 (class 2606 OID 10118404)
-- Name: aree_allerta_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY aree_allerta
    ADD CONSTRAINT aree_allerta_pkey PRIMARY KEY (gid);


--
-- TOC entry 4783 (class 2606 OID 10639974)
-- Name: bacini_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY bacini
    ADD CONSTRAINT bacini_pkey PRIMARY KEY (gid);


--
-- TOC entry 4810 (class 2606 OID 54816601)
-- Name: corpi_idri_artif_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY corpi_idrici_artif
    ADD CONSTRAINT corpi_idri_artif_pkey PRIMARY KEY (gid);


--
-- TOC entry 4804 (class 2606 OID 54211019)
-- Name: corpi_idrici_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY corpi_idrici_nat
    ADD CONSTRAINT corpi_idrici_pkey PRIMARY KEY (gid);


--
-- TOC entry 4794 (class 2606 OID 41373450)
-- Name: fiumi_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY fiumi
    ADD CONSTRAINT fiumi_pkey PRIMARY KEY (gid);


--
-- TOC entry 4806 (class 2606 OID 54211422)
-- Name: laghi_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY laghi
    ADD CONSTRAINT laghi_pkey PRIMARY KEY (gid);


--
-- TOC entry 4796 (class 2606 OID 41443267)
-- Name: limite_regionale_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limite_regionale
    ADD CONSTRAINT limite_regionale_pkey PRIMARY KEY (gid);


--
-- TOC entry 4741 (class 2606 OID 35299)
-- Name: limiti_amministrativi_2014_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limiti_amministrativi
    ADD CONSTRAINT limiti_amministrativi_2014_pkey PRIMARY KEY (gid);


--
-- TOC entry 4790 (class 2606 OID 28118671)
-- Name: limiti_comunali_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limiti_comunali
    ADD CONSTRAINT limiti_comunali_pkey PRIMARY KEY (gid);


--
-- TOC entry 4792 (class 2606 OID 28170180)
-- Name: limiti_provinciali_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY limiti_provinciali
    ADD CONSTRAINT limiti_provinciali_pkey PRIMARY KEY (gid);


--
-- TOC entry 4800 (class 2606 OID 41478804)
-- Name: lspp_d1_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY lspp_d1
    ADD CONSTRAINT lspp_d1_pkey PRIMARY KEY (gid);


--
-- TOC entry 4802 (class 2606 OID 41478819)
-- Name: lspp_d2_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY lspp_d2
    ADD CONSTRAINT lspp_d2_pkey PRIMARY KEY (gid);


--
-- TOC entry 4812 (class 2606 OID 54851238)
-- Name: portate_naturali_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY portate_naturali
    ADD CONSTRAINT portate_naturali_pkey PRIMARY KEY (gid);


--
-- TOC entry 4743 (class 2606 OID 35303)
-- Name: province_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY province
    ADD CONSTRAINT province_pkey PRIMARY KEY (province);


--
-- TOC entry 4749 (class 2606 OID 35305)
-- Name: radar_visibility4000poly_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY radar_visibility4000poly
    ADD CONSTRAINT radar_visibility4000poly_pkey PRIMARY KEY (gid);


--
-- TOC entry 4746 (class 2606 OID 35307)
-- Name: radar_visibility_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY radar_visibility
    ADD CONSTRAINT radar_visibility_pkey PRIMARY KEY (gid);


--
-- TOC entry 4751 (class 2606 OID 35309)
-- Name: regioni_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY regioni
    ADD CONSTRAINT regioni_pkey PRIMARY KEY (id);


--
-- TOC entry 4755 (class 2606 OID 35315)
-- Name: reticolo_idro_nw_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY reticolo_idro_nw
    ADD CONSTRAINT reticolo_idro_nw_pkey PRIMARY KEY (gid);


--
-- TOC entry 4788 (class 2606 OID 12653315)
-- Name: soglie_idrometriche_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY soglie_idrometriche
    ADD CONSTRAINT soglie_idrometriche_pkey PRIMARY KEY (idsensore);


--
-- TOC entry 4798 (class 2606 OID 41478680)
-- Name: torrenti_pkey; Type: CONSTRAINT; Schema: dati_di_base; Owner: postgres
--

ALTER TABLE ONLY torrenti
    ADD CONSTRAINT torrenti_pkey PRIMARY KEY (gid);


SET search_path = public, pg_catalog;

--
-- TOC entry 4808 (class 2606 OID 54811647)
-- Name: layer_styles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY layer_styles
    ADD CONSTRAINT layer_styles_pkey PRIMARY KEY (id);


--
-- TOC entry 4693 (class 2606 OID 30061)
-- Name: spatial_ref_sys_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY spatial_ref_sys
    ADD CONSTRAINT spatial_ref_sys_pkey PRIMARY KEY (srid);


SET search_path = realtime, pg_catalog;

--
-- TOC entry 4773 (class 2606 OID 35548)
-- Name: Identita_dati; Type: CONSTRAINT; Schema: realtime; Owner: webgis_r
--

ALTER TABLE ONLY m_osservazioni_tr
    ADD CONSTRAINT "Identita_dati" PRIMARY KEY (idsensore, idoperatore, data_e_ora);


--
-- TOC entry 4816 (class 2606 OID 70654629)
-- Name: pk_anomalia; Type: CONSTRAINT; Schema: realtime; Owner: postgres
--

ALTER TABLE ONLY anomalie
    ADD CONSTRAINT pk_anomalia PRIMARY KEY (data_inizio, id_sistema);


--
-- TOC entry 4786 (class 2606 OID 11430531)
-- Name: soglie_pioggia_12ore_area_key; Type: CONSTRAINT; Schema: realtime; Owner: postgres
--

ALTER TABLE ONLY soglie_pioggia_12ore
    ADD CONSTRAINT soglie_pioggia_12ore_area_key UNIQUE (area);


--
-- TOC entry 4757 (class 2606 OID 35383)
-- Name: webgis_tickets_pkey; Type: CONSTRAINT; Schema: realtime; Owner: postgres
--

ALTER TABLE ONLY webgis_tickets
    ADD CONSTRAINT webgis_tickets_pkey PRIMARY KEY (gid);


SET search_path = topology, pg_catalog;

--
-- TOC entry 4699 (class 2606 OID 31100)
-- Name: layer_pkey; Type: CONSTRAINT; Schema: topology; Owner: postgres
--

ALTER TABLE ONLY layer
    ADD CONSTRAINT layer_pkey PRIMARY KEY (topology_id, layer_id);


--
-- TOC entry 4701 (class 2606 OID 31102)
-- Name: layer_schema_name_table_name_feature_column_key; Type: CONSTRAINT; Schema: topology; Owner: postgres
--

ALTER TABLE ONLY layer
    ADD CONSTRAINT layer_schema_name_table_name_feature_column_key UNIQUE (schema_name, table_name, feature_column);


--
-- TOC entry 4695 (class 2606 OID 31090)
-- Name: topology_name_key; Type: CONSTRAINT; Schema: topology; Owner: postgres
--

ALTER TABLE ONLY topology
    ADD CONSTRAINT topology_name_key UNIQUE (name);


--
-- TOC entry 4697 (class 2606 OID 31088)
-- Name: topology_pkey; Type: CONSTRAINT; Schema: topology; Owner: postgres
--

ALTER TABLE ONLY topology
    ADD CONSTRAINT topology_pkey PRIMARY KEY (id);


SET search_path = warning, pg_catalog;

--
-- TOC entry 4769 (class 2606 OID 35385)
-- Name: key_id; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_users
    ADD CONSTRAINT key_id PRIMARY KEY (id_utente);


--
-- TOC entry 4759 (class 2606 OID 35387)
-- Name: warning_area_the_geom_key; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_area
    ADD CONSTRAINT warning_area_the_geom_key UNIQUE (the_geom);


--
-- TOC entry 4771 (class 2606 OID 35389)
-- Name: warning_issued_pkey; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_issued
    ADD CONSTRAINT warning_issued_pkey PRIMARY KEY (id_utente, id_area, id_level, dataora_issuing);


--
-- TOC entry 4763 (class 2606 OID 35391)
-- Name: warning_levels_id_utente_id_area_key; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_levels
    ADD CONSTRAINT warning_levels_id_utente_id_area_key UNIQUE (id_utente, id_area);


--
-- TOC entry 4765 (class 2606 OID 35393)
-- Name: warning_levels_id_utente_id_area_key1; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_levels
    ADD CONSTRAINT warning_levels_id_utente_id_area_key1 UNIQUE (id_utente, id_area);


--
-- TOC entry 4767 (class 2606 OID 35395)
-- Name: warning_levels_pkey; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_levels
    ADD CONSTRAINT warning_levels_pkey PRIMARY KEY (id_level);


--
-- TOC entry 4761 (class 2606 OID 35397)
-- Name: warninng_area_pkey; Type: CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_area
    ADD CONSTRAINT warninng_area_pkey PRIMARY KEY (id_area);


SET search_path = dati_di_base, pg_catalog;

--
-- TOC entry 4738 (class 1259 OID 35401)
-- Name: limamn_2014_idx; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX limamn_2014_idx ON limiti_amministrativi USING gist (the_geom);


--
-- TOC entry 4739 (class 1259 OID 35402)
-- Name: limamn_2014_idx2; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX limamn_2014_idx2 ON limiti_amministrativi USING btree (gid);


--
-- TOC entry 4747 (class 1259 OID 35404)
-- Name: radar_visibility_the_geom_gist; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX radar_visibility_the_geom_gist ON radar_visibility USING gist (the_geom);


--
-- TOC entry 4753 (class 1259 OID 35408)
-- Name: reticolo_idro_nw_idx; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX reticolo_idro_nw_idx ON reticolo_idro_nw USING gist (the_geom);


--
-- TOC entry 4784 (class 1259 OID 10639992)
-- Name: sidx_bacini_the_geom; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX sidx_bacini_the_geom ON bacini USING gist (the_geom);


--
-- TOC entry 4744 (class 1259 OID 35410)
-- Name: sidx_province_geom; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX sidx_province_geom ON province USING gist (the_geom);


--
-- TOC entry 4752 (class 1259 OID 35411)
-- Name: sidx_regioni_geom; Type: INDEX; Schema: dati_di_base; Owner: postgres
--

CREATE INDEX sidx_regioni_geom ON regioni USING gist (the_geom);


SET search_path = public, pg_catalog;

--
-- TOC entry 4818 (class 1259 OID 70658587)
-- Name: ix_'realtime''.'errori_sensori'_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX "ix_'realtime''.'errori_sensori'_index" ON "'realtime''.'errori_sensori'" USING btree (index);


--
-- TOC entry 4817 (class 1259 OID 70658573)
-- Name: ix_errori_sensori_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX ix_errori_sensori_index ON errori_sensori USING btree (index);


SET search_path = realtime, pg_catalog;

--
-- TOC entry 4774 (class 1259 OID 8661545)
-- Name: idsensore; Type: INDEX; Schema: realtime; Owner: webgis_r
--

CREATE INDEX idsensore ON m_osservazioni_tr USING btree (idsensore);


--
-- TOC entry 4775 (class 1259 OID 9370467)
-- Name: indice_data_e_ora; Type: INDEX; Schema: realtime; Owner: webgis_r
--

CREATE INDEX indice_data_e_ora ON m_osservazioni_tr USING btree (data_e_ora DESC);


SET search_path = public, pg_catalog;

--
-- TOC entry 4950 (class 2618 OID 30484)
-- Name: geometry_columns_delete; Type: RULE; Schema: public; Owner: postgres
--

CREATE RULE geometry_columns_delete AS
    ON DELETE TO geometry_columns DO INSTEAD NOTHING;


--
-- TOC entry 4948 (class 2618 OID 30482)
-- Name: geometry_columns_insert; Type: RULE; Schema: public; Owner: postgres
--

CREATE RULE geometry_columns_insert AS
    ON INSERT TO geometry_columns DO INSTEAD NOTHING;


--
-- TOC entry 4949 (class 2618 OID 30483)
-- Name: geometry_columns_update; Type: RULE; Schema: public; Owner: postgres
--

CREATE RULE geometry_columns_update AS
    ON UPDATE TO geometry_columns DO INSTEAD NOTHING;


SET search_path = config, pg_catalog;

--
-- TOC entry 4838 (class 2620 OID 35438)
-- Name: trigger_update_legend_variable; Type: TRIGGER; Schema: config; Owner: postgres
--

CREATE TRIGGER trigger_update_legend_variable AFTER INSERT ON webgis_ol_layers FOR EACH ROW EXECUTE PROCEDURE update_legend_variable();


SET search_path = topology, pg_catalog;

--
-- TOC entry 4837 (class 2620 OID 31108)
-- Name: layer_integrity_checks; Type: TRIGGER; Schema: topology; Owner: postgres
--

CREATE TRIGGER layer_integrity_checks BEFORE DELETE OR UPDATE ON layer FOR EACH ROW EXECUTE PROCEDURE layertrigger();


SET search_path = config, pg_catalog;

--
-- TOC entry 4820 (class 2606 OID 35442)
-- Name: webgis_groups_group_father_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_groups
    ADD CONSTRAINT webgis_groups_group_father_fkey FOREIGN KEY (group_father) REFERENCES webgis_groups(pedice) ON UPDATE CASCADE;


--
-- TOC entry 4821 (class 2606 OID 35447)
-- Name: webgis_indici_default_raster_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_indici
    ADD CONSTRAINT webgis_indici_default_raster_fkey FOREIGN KEY (default_raster) REFERENCES animazione_webgis(gid);


--
-- TOC entry 4822 (class 2606 OID 35452)
-- Name: webgis_indici_defaultgrid_layeridx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_indici
    ADD CONSTRAINT webgis_indici_defaultgrid_layeridx_fkey FOREIGN KEY (defaultgrid_layeridx) REFERENCES webgis_ol_layers(layer_idx) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 4823 (class 2606 OID 35457)
-- Name: webgis_indici_query_map_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_indici
    ADD CONSTRAINT webgis_indici_query_map_idx_fkey FOREIGN KEY (query_map_idx) REFERENCES webgis_query_map(query_map_idx);


--
-- TOC entry 4824 (class 2606 OID 35462)
-- Name: webgis_layers_legend_group_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_layers
    ADD CONSTRAINT webgis_layers_legend_group_idx_fkey FOREIGN KEY (legend_group_idx) REFERENCES webgis_groups(group_idx);


--
-- TOC entry 4825 (class 2606 OID 35467)
-- Name: webgis_layers_ol_layer_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_layers
    ADD CONSTRAINT webgis_layers_ol_layer_idx_fkey FOREIGN KEY (ol_layer_idx) REFERENCES webgis_ol_layers(layer_idx);


--
-- TOC entry 4826 (class 2606 OID 35472)
-- Name: webgis_layers_webgis_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_layers
    ADD CONSTRAINT webgis_layers_webgis_idx_fkey FOREIGN KEY (webgis_idx) REFERENCES webgis_indici(webgis_idx) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4829 (class 2606 OID 35477)
-- Name: webgis_popups_webgis_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_popups
    ADD CONSTRAINT webgis_popups_webgis_idx_fkey FOREIGN KEY (webgis_idx, ol_layer_idx) REFERENCES webgis_layers(webgis_idx, ol_layer_idx) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4827 (class 2606 OID 35482)
-- Name: webgis_tools_tools_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_tools
    ADD CONSTRAINT webgis_tools_tools_idx_fkey FOREIGN KEY (tools_idx) REFERENCES webgis_toolbar_tools(tool_idx);


--
-- TOC entry 4828 (class 2606 OID 35487)
-- Name: webgis_tools_webgis_idx_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY webgis_tools
    ADD CONSTRAINT webgis_tools_webgis_idx_fkey FOREIGN KEY (webgis_idx) REFERENCES webgis_indici(webgis_idx);


SET search_path = realtime, pg_catalog;

--
-- TOC entry 4836 (class 2606 OID 70654630)
-- Name: anomalie_id_sistema_fkey; Type: FK CONSTRAINT; Schema: realtime; Owner: postgres
--

ALTER TABLE ONLY anomalie
    ADD CONSTRAINT anomalie_id_sistema_fkey FOREIGN KEY (id_sistema) REFERENCES config.anomalie_sistemi(id_sistema) MATCH FULL;


--
-- TOC entry 4835 (class 2606 OID 70654635)
-- Name: anomalie_severita_fkey; Type: FK CONSTRAINT; Schema: realtime; Owner: postgres
--

ALTER TABLE ONLY anomalie
    ADD CONSTRAINT anomalie_severita_fkey FOREIGN KEY (severita) REFERENCES config.anomalie_severita(severita_idx);


SET search_path = topology, pg_catalog;

--
-- TOC entry 4819 (class 2606 OID 31103)
-- Name: layer_topology_id_fkey; Type: FK CONSTRAINT; Schema: topology; Owner: postgres
--

ALTER TABLE ONLY layer
    ADD CONSTRAINT layer_topology_id_fkey FOREIGN KEY (topology_id) REFERENCES topology(id);


SET search_path = warning, pg_catalog;

--
-- TOC entry 4832 (class 2606 OID 35502)
-- Name: warning_issued_id_area_fkey; Type: FK CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_issued
    ADD CONSTRAINT warning_issued_id_area_fkey FOREIGN KEY (id_area) REFERENCES warning_area(id_area) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4833 (class 2606 OID 35507)
-- Name: warning_issued_id_level_fkey; Type: FK CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_issued
    ADD CONSTRAINT warning_issued_id_level_fkey FOREIGN KEY (id_level) REFERENCES warning_levels(id_level) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4834 (class 2606 OID 35512)
-- Name: warning_issued_id_utente_fkey; Type: FK CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_issued
    ADD CONSTRAINT warning_issued_id_utente_fkey FOREIGN KEY (id_utente) REFERENCES warning_users(id_utente) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4830 (class 2606 OID 35517)
-- Name: warning_levels_id_area_fkey; Type: FK CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_levels
    ADD CONSTRAINT warning_levels_id_area_fkey FOREIGN KEY (id_area) REFERENCES warning_area(id_area) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4831 (class 2606 OID 35522)
-- Name: warning_levels_id_utente_fkey; Type: FK CONSTRAINT; Schema: warning; Owner: postgres
--

ALTER TABLE ONLY warning_levels
    ADD CONSTRAINT warning_levels_id_utente_fkey FOREIGN KEY (id_utente) REFERENCES warning_users(id_utente) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 4999 (class 0 OID 0)
-- Dependencies: 8
-- Name: config; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA config FROM PUBLIC;
REVOKE ALL ON SCHEMA config FROM postgres;
GRANT ALL ON SCHEMA config TO postgres;
GRANT USAGE ON SCHEMA config TO PUBLIC;
GRANT USAGE ON SCHEMA config TO webgis_r;
GRANT ALL ON SCHEMA config TO radar_rw;


--
-- TOC entry 5001 (class 0 OID 0)
-- Dependencies: 9
-- Name: dati_di_base; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA dati_di_base FROM PUBLIC;
REVOKE ALL ON SCHEMA dati_di_base FROM postgres;
GRANT ALL ON SCHEMA dati_di_base TO postgres;
GRANT USAGE ON SCHEMA dati_di_base TO PUBLIC;
GRANT USAGE ON SCHEMA dati_di_base TO webgis_r;
GRANT ALL ON SCHEMA dati_di_base TO radar_rw;


--
-- TOC entry 5003 (class 0 OID 0)
-- Dependencies: 10
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO PUBLIC;
GRANT USAGE ON SCHEMA public TO webgis_r;
GRANT ALL ON SCHEMA public TO radar_rw;


--
-- TOC entry 5005 (class 0 OID 0)
-- Dependencies: 11
-- Name: realtime; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA realtime FROM PUBLIC;
REVOKE ALL ON SCHEMA realtime FROM postgres;
GRANT ALL ON SCHEMA realtime TO postgres;
GRANT ALL ON SCHEMA realtime TO PUBLIC;
GRANT USAGE ON SCHEMA realtime TO webgis_r;
GRANT ALL ON SCHEMA realtime TO radar_rw;


--
-- TOC entry 5007 (class 0 OID 0)
-- Dependencies: 12
-- Name: warning; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA warning FROM PUBLIC;
REVOKE ALL ON SCHEMA warning FROM postgres;
GRANT ALL ON SCHEMA warning TO postgres;
GRANT USAGE ON SCHEMA warning TO PUBLIC;
GRANT USAGE ON SCHEMA warning TO webgis_r;
GRANT ALL ON SCHEMA warning TO radar_rw;


SET search_path = public, pg_catalog;

--
-- TOC entry 5010 (class 0 OID 0)
-- Dependencies: 1485
-- Name: cristal_forecast(integer, real, real); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION cristal_forecast(integer, real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION cristal_forecast(integer, real, real) FROM postgres;
GRANT ALL ON FUNCTION cristal_forecast(integer, real, real) TO postgres;
GRANT ALL ON FUNCTION cristal_forecast(integer, real, real) TO PUBLIC;


--
-- TOC entry 5011 (class 0 OID 0)
-- Dependencies: 1486
-- Name: ellipse(double precision, double precision, double precision, double precision, double precision, integer); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION ellipse(double precision, double precision, double precision, double precision, double precision, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION ellipse(double precision, double precision, double precision, double precision, double precision, integer) FROM postgres;
GRANT ALL ON FUNCTION ellipse(double precision, double precision, double precision, double precision, double precision, integer) TO postgres;
GRANT ALL ON FUNCTION ellipse(double precision, double precision, double precision, double precision, double precision, integer) TO PUBLIC;


--
-- TOC entry 5012 (class 0 OID 0)
-- Dependencies: 331
-- Name: install_rcmd(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION install_rcmd(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION install_rcmd(text) FROM postgres;
GRANT ALL ON FUNCTION install_rcmd(text) TO postgres;


--
-- TOC entry 5013 (class 0 OID 0)
-- Dependencies: 335
-- Name: plr_environ(); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plr_environ() FROM PUBLIC;
REVOKE ALL ON FUNCTION plr_environ() FROM postgres;
GRANT ALL ON FUNCTION plr_environ() TO postgres;


--
-- TOC entry 5014 (class 0 OID 0)
-- Dependencies: 341
-- Name: plr_set_display(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plr_set_display(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plr_set_display(text) FROM postgres;
GRANT ALL ON FUNCTION plr_set_display(text) TO postgres;


--
-- TOC entry 5015 (class 0 OID 0)
-- Dependencies: 339
-- Name: plr_set_rhome(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plr_set_rhome(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION plr_set_rhome(text) FROM postgres;
GRANT ALL ON FUNCTION plr_set_rhome(text) TO postgres;


--
-- TOC entry 5016 (class 0 OID 0)
-- Dependencies: 340
-- Name: plr_unset_rhome(); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION plr_unset_rhome() FROM PUBLIC;
REVOKE ALL ON FUNCTION plr_unset_rhome() FROM postgres;
GRANT ALL ON FUNCTION plr_unset_rhome() TO postgres;


--
-- TOC entry 5017 (class 0 OID 0)
-- Dependencies: 1487
-- Name: r_plotpie_stab(); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION r_plotpie_stab() FROM PUBLIC;
REVOKE ALL ON FUNCTION r_plotpie_stab() FROM postgres;
GRANT ALL ON FUNCTION r_plotpie_stab() TO postgres;
GRANT ALL ON FUNCTION r_plotpie_stab() TO PUBLIC;


--
-- TOC entry 5019 (class 0 OID 0)
-- Dependencies: 1515
-- Name: zradar_at(real, real, real); Type: ACL; Schema: public; Owner: radar
--

REVOKE ALL ON FUNCTION zradar_at(real, real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_at(real, real, real) FROM radar;
GRANT ALL ON FUNCTION zradar_at(real, real, real) TO radar;
GRANT ALL ON FUNCTION zradar_at(real, real, real) TO PUBLIC;
GRANT ALL ON FUNCTION zradar_at(real, real, real) TO postgres;


--
-- TOC entry 5021 (class 0 OID 0)
-- Dependencies: 1516
-- Name: zradar_forecast(integer, real, real); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION zradar_forecast(integer, real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_forecast(integer, real, real) FROM postgres;
GRANT ALL ON FUNCTION zradar_forecast(integer, real, real) TO postgres;
GRANT ALL ON FUNCTION zradar_forecast(integer, real, real) TO PUBLIC;


--
-- TOC entry 5023 (class 0 OID 0)
-- Dependencies: 1490
-- Name: zradar_forecast_app(integer, real, real); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION zradar_forecast_app(integer, real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_forecast_app(integer, real, real) FROM postgres;
GRANT ALL ON FUNCTION zradar_forecast_app(integer, real, real) TO postgres;
GRANT ALL ON FUNCTION zradar_forecast_app(integer, real, real) TO PUBLIC;


--
-- TOC entry 5025 (class 0 OID 0)
-- Dependencies: 1517
-- Name: zradar_forecast_averagespeed(integer, real, real, integer); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION zradar_forecast_averagespeed(integer, real, real, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_forecast_averagespeed(integer, real, real, integer) FROM postgres;
GRANT ALL ON FUNCTION zradar_forecast_averagespeed(integer, real, real, integer) TO postgres;
GRANT ALL ON FUNCTION zradar_forecast_averagespeed(integer, real, real, integer) TO PUBLIC;


--
-- TOC entry 5027 (class 0 OID 0)
-- Dependencies: 1492
-- Name: zradar_humidex(real, real); Type: ACL; Schema: public; Owner: radar
--

REVOKE ALL ON FUNCTION zradar_humidex(real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_humidex(real, real) FROM radar;
GRANT ALL ON FUNCTION zradar_humidex(real, real) TO radar;
GRANT ALL ON FUNCTION zradar_humidex(real, real) TO PUBLIC;
GRANT ALL ON FUNCTION zradar_humidex(real, real) TO postgres;


--
-- TOC entry 5029 (class 0 OID 0)
-- Dependencies: 1489
-- Name: zradar_mslp(real, real, real, real); Type: ACL; Schema: public; Owner: radar
--

REVOKE ALL ON FUNCTION zradar_mslp(real, real, real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_mslp(real, real, real, real) FROM radar;
GRANT ALL ON FUNCTION zradar_mslp(real, real, real, real) TO radar;
GRANT ALL ON FUNCTION zradar_mslp(real, real, real, real) TO PUBLIC;
GRANT ALL ON FUNCTION zradar_mslp(real, real, real, real) TO postgres;


--
-- TOC entry 5031 (class 0 OID 0)
-- Dependencies: 1491
-- Name: zradar_new_severity_index(real, real, real, real, double precision); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION zradar_new_severity_index(real, real, real, real, double precision) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_new_severity_index(real, real, real, real, double precision) FROM postgres;
GRANT ALL ON FUNCTION zradar_new_severity_index(real, real, real, real, double precision) TO postgres;
GRANT ALL ON FUNCTION zradar_new_severity_index(real, real, real, real, double precision) TO PUBLIC;


--
-- TOC entry 5033 (class 0 OID 0)
-- Dependencies: 1518
-- Name: zradar_severity_index(real, real, real); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION zradar_severity_index(real, real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_severity_index(real, real, real) FROM postgres;
GRANT ALL ON FUNCTION zradar_severity_index(real, real, real) TO postgres;
GRANT ALL ON FUNCTION zradar_severity_index(real, real, real) TO PUBLIC;


--
-- TOC entry 5035 (class 0 OID 0)
-- Dependencies: 1499
-- Name: zradar_td(real, real); Type: ACL; Schema: public; Owner: radar
--

REVOKE ALL ON FUNCTION zradar_td(real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_td(real, real) FROM radar;
GRANT ALL ON FUNCTION zradar_td(real, real) TO radar;
GRANT ALL ON FUNCTION zradar_td(real, real) TO PUBLIC;
GRANT ALL ON FUNCTION zradar_td(real, real) TO postgres;


--
-- TOC entry 5037 (class 0 OID 0)
-- Dependencies: 1493
-- Name: zradar_windchill(real, real); Type: ACL; Schema: public; Owner: radar
--

REVOKE ALL ON FUNCTION zradar_windchill(real, real) FROM PUBLIC;
REVOKE ALL ON FUNCTION zradar_windchill(real, real) FROM radar;
GRANT ALL ON FUNCTION zradar_windchill(real, real) TO radar;
GRANT ALL ON FUNCTION zradar_windchill(real, real) TO PUBLIC;
GRANT ALL ON FUNCTION zradar_windchill(real, real) TO postgres;


SET search_path = config, pg_catalog;

--
-- TOC entry 5057 (class 0 OID 0)
-- Dependencies: 198
-- Name: animazione_webgis; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE animazione_webgis FROM PUBLIC;
REVOKE ALL ON TABLE animazione_webgis FROM postgres;
GRANT ALL ON TABLE animazione_webgis TO postgres;
GRANT SELECT ON TABLE animazione_webgis TO webgis_r;


--
-- TOC entry 5060 (class 0 OID 0)
-- Dependencies: 308
-- Name: anomalie_severita; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE anomalie_severita FROM PUBLIC;
REVOKE ALL ON TABLE anomalie_severita FROM postgres;
GRANT ALL ON TABLE anomalie_severita TO postgres;
GRANT SELECT ON TABLE anomalie_severita TO webgis_r;
GRANT ALL ON TABLE anomalie_severita TO radar_rw;


--
-- TOC entry 5062 (class 0 OID 0)
-- Dependencies: 200
-- Name: anomalie_sistemi; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE anomalie_sistemi FROM PUBLIC;
REVOKE ALL ON TABLE anomalie_sistemi FROM postgres;
GRANT ALL ON TABLE anomalie_sistemi TO postgres;
GRANT SELECT ON TABLE anomalie_sistemi TO webgis_r;
GRANT ALL ON TABLE anomalie_sistemi TO radar_rw;


--
-- TOC entry 5065 (class 0 OID 0)
-- Dependencies: 201
-- Name: news_message; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE news_message FROM PUBLIC;
REVOKE ALL ON TABLE news_message FROM postgres;
GRANT ALL ON TABLE news_message TO postgres;
GRANT SELECT ON TABLE news_message TO webgis_r;
GRANT ALL ON TABLE news_message TO radar_rw;


--
-- TOC entry 5071 (class 0 OID 0)
-- Dependencies: 203
-- Name: webgis_groups; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_groups FROM PUBLIC;
REVOKE ALL ON TABLE webgis_groups FROM postgres;
GRANT ALL ON TABLE webgis_groups TO postgres;
GRANT SELECT ON TABLE webgis_groups TO webgis_r;
GRANT ALL ON TABLE webgis_groups TO radar_rw;


--
-- TOC entry 5087 (class 0 OID 0)
-- Dependencies: 204
-- Name: webgis_indici; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_indici FROM PUBLIC;
REVOKE ALL ON TABLE webgis_indici FROM postgres;
GRANT ALL ON TABLE webgis_indici TO postgres;
GRANT SELECT ON TABLE webgis_indici TO webgis_r;


--
-- TOC entry 5092 (class 0 OID 0)
-- Dependencies: 205
-- Name: webgis_layers; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_layers FROM PUBLIC;
REVOKE ALL ON TABLE webgis_layers FROM postgres;
GRANT ALL ON TABLE webgis_layers TO postgres;
GRANT SELECT ON TABLE webgis_layers TO webgis_r;
GRANT ALL ON TABLE webgis_layers TO radar_rw;


--
-- TOC entry 5109 (class 0 OID 0)
-- Dependencies: 206
-- Name: webgis_ol_layers; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_ol_layers FROM PUBLIC;
REVOKE ALL ON TABLE webgis_ol_layers FROM postgres;
GRANT ALL ON TABLE webgis_ol_layers TO postgres;
GRANT SELECT ON TABLE webgis_ol_layers TO webgis_r;


--
-- TOC entry 5111 (class 0 OID 0)
-- Dependencies: 207
-- Name: v_webgis_custom_settings; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE v_webgis_custom_settings FROM PUBLIC;
REVOKE ALL ON TABLE v_webgis_custom_settings FROM postgres;
GRANT ALL ON TABLE v_webgis_custom_settings TO postgres;
GRANT SELECT ON TABLE v_webgis_custom_settings TO webgis_r;


--
-- TOC entry 5114 (class 0 OID 0)
-- Dependencies: 208
-- Name: webgis_toolbar_tools; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_toolbar_tools FROM PUBLIC;
REVOKE ALL ON TABLE webgis_toolbar_tools FROM postgres;
GRANT ALL ON TABLE webgis_toolbar_tools TO postgres;
GRANT SELECT ON TABLE webgis_toolbar_tools TO webgis_r;


--
-- TOC entry 5116 (class 0 OID 0)
-- Dependencies: 209
-- Name: webgis_tools; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_tools FROM PUBLIC;
REVOKE ALL ON TABLE webgis_tools FROM postgres;
GRANT ALL ON TABLE webgis_tools TO postgres;
GRANT SELECT ON TABLE webgis_tools TO webgis_r;


--
-- TOC entry 5118 (class 0 OID 0)
-- Dependencies: 210
-- Name: v_webgis_general_config; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE v_webgis_general_config FROM PUBLIC;
REVOKE ALL ON TABLE v_webgis_general_config FROM postgres;
GRANT ALL ON TABLE v_webgis_general_config TO postgres;
GRANT SELECT ON TABLE v_webgis_general_config TO webgis_r;


--
-- TOC entry 5120 (class 0 OID 0)
-- Dependencies: 211
-- Name: v_webgis_ol_layers; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE v_webgis_ol_layers FROM PUBLIC;
REVOKE ALL ON TABLE v_webgis_ol_layers FROM postgres;
GRANT ALL ON TABLE v_webgis_ol_layers TO postgres;
GRANT ALL ON TABLE v_webgis_ol_layers TO radar_rw;
GRANT SELECT ON TABLE v_webgis_ol_layers TO webgis_r;


--
-- TOC entry 5136 (class 0 OID 0)
-- Dependencies: 212
-- Name: webgis_popups; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_popups FROM PUBLIC;
REVOKE ALL ON TABLE webgis_popups FROM postgres;
GRANT ALL ON TABLE webgis_popups TO postgres;
GRANT SELECT ON TABLE webgis_popups TO webgis_r;


--
-- TOC entry 5138 (class 0 OID 0)
-- Dependencies: 261
-- Name: v_webgis_popups; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE v_webgis_popups FROM PUBLIC;
REVOKE ALL ON TABLE v_webgis_popups FROM postgres;
GRANT ALL ON TABLE v_webgis_popups TO postgres;
GRANT SELECT ON TABLE v_webgis_popups TO webgis_r;


--
-- TOC entry 5144 (class 0 OID 0)
-- Dependencies: 213
-- Name: webgis_base_layers; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_base_layers FROM PUBLIC;
REVOKE ALL ON TABLE webgis_base_layers FROM postgres;
GRANT ALL ON TABLE webgis_base_layers TO postgres;
GRANT SELECT ON TABLE webgis_base_layers TO webgis_r;


--
-- TOC entry 5149 (class 0 OID 0)
-- Dependencies: 217
-- Name: webgis_query_map; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_query_map FROM PUBLIC;
REVOKE ALL ON TABLE webgis_query_map FROM postgres;
GRANT ALL ON TABLE webgis_query_map TO postgres;
GRANT SELECT ON TABLE webgis_query_map TO webgis_r;


--
-- TOC entry 5151 (class 0 OID 0)
-- Dependencies: 218
-- Name: webgis_target; Type: ACL; Schema: config; Owner: postgres
--

REVOKE ALL ON TABLE webgis_target FROM PUBLIC;
REVOKE ALL ON TABLE webgis_target FROM postgres;
GRANT ALL ON TABLE webgis_target TO postgres;
GRANT SELECT ON TABLE webgis_target TO webgis_r;
GRANT ALL ON TABLE webgis_target TO radar_rw;


SET search_path = dati_di_base, pg_catalog;

--
-- TOC entry 5163 (class 0 OID 0)
-- Dependencies: 220
-- Name: limiti_amministrativi; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE limiti_amministrativi FROM PUBLIC;
REVOKE ALL ON TABLE limiti_amministrativi FROM postgres;
GRANT ALL ON TABLE limiti_amministrativi TO postgres;
GRANT SELECT ON TABLE limiti_amministrativi TO webgis_r;
GRANT ALL ON TABLE limiti_amministrativi TO radar_rw;


--
-- TOC entry 5171 (class 0 OID 0)
-- Dependencies: 222
-- Name: province; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE province FROM PUBLIC;
REVOKE ALL ON TABLE province FROM postgres;
GRANT ALL ON TABLE province TO postgres;
GRANT SELECT ON TABLE province TO webgis_r;
GRANT ALL ON TABLE province TO radar_rw;


--
-- TOC entry 5173 (class 0 OID 0)
-- Dependencies: 223
-- Name: radar_visibility; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE radar_visibility FROM PUBLIC;
REVOKE ALL ON TABLE radar_visibility FROM postgres;
GRANT ALL ON TABLE radar_visibility TO postgres;
GRANT SELECT ON TABLE radar_visibility TO webgis_r;
GRANT ALL ON TABLE radar_visibility TO radar_rw;


--
-- TOC entry 5175 (class 0 OID 0)
-- Dependencies: 224
-- Name: radar_visibility4000poly; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE radar_visibility4000poly FROM PUBLIC;
REVOKE ALL ON TABLE radar_visibility4000poly FROM postgres;
GRANT ALL ON TABLE radar_visibility4000poly TO postgres;
GRANT SELECT ON TABLE radar_visibility4000poly TO webgis_r;
GRANT ALL ON TABLE radar_visibility4000poly TO radar_rw;


--
-- TOC entry 5181 (class 0 OID 0)
-- Dependencies: 229
-- Name: reticolo_idro_nw; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE reticolo_idro_nw FROM PUBLIC;
REVOKE ALL ON TABLE reticolo_idro_nw FROM postgres;
GRANT ALL ON TABLE reticolo_idro_nw TO postgres;
GRANT SELECT ON TABLE reticolo_idro_nw TO webgis_r;
GRANT ALL ON TABLE reticolo_idro_nw TO radar_rw;


--
-- TOC entry 5186 (class 0 OID 0)
-- Dependencies: 293
-- Name: v_anagrafica_altri_idro; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_altri_idro FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_altri_idro FROM postgres;
GRANT ALL ON TABLE v_anagrafica_altri_idro TO postgres;
GRANT SELECT ON TABLE v_anagrafica_altri_idro TO webgis_r;


--
-- TOC entry 5188 (class 0 OID 0)
-- Dependencies: 245
-- Name: v_anagraficasensori; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagraficasensori FROM PUBLIC;
REVOKE ALL ON TABLE v_anagraficasensori FROM postgres;
GRANT ALL ON TABLE v_anagraficasensori TO postgres;
GRANT SELECT ON TABLE v_anagraficasensori TO webgis_r;


--
-- TOC entry 5190 (class 0 OID 0)
-- Dependencies: 289
-- Name: v_anagrafica_anemo; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_anemo FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_anemo FROM postgres;
GRANT ALL ON TABLE v_anagrafica_anemo TO postgres;
GRANT SELECT ON TABLE v_anagrafica_anemo TO webgis_r;


--
-- TOC entry 5192 (class 0 OID 0)
-- Dependencies: 291
-- Name: v_anagrafica_baro; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_baro FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_baro FROM postgres;
GRANT ALL ON TABLE v_anagrafica_baro TO postgres;
GRANT SELECT ON TABLE v_anagrafica_baro TO webgis_r;


--
-- TOC entry 5194 (class 0 OID 0)
-- Dependencies: 282
-- Name: v_anagrafica_idro; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_idro FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_idro FROM postgres;
GRANT ALL ON TABLE v_anagrafica_idro TO postgres;
GRANT SELECT ON TABLE v_anagrafica_idro TO webgis_r;


--
-- TOC entry 5196 (class 0 OID 0)
-- Dependencies: 290
-- Name: v_anagrafica_igro; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_igro FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_igro FROM postgres;
GRANT ALL ON TABLE v_anagrafica_igro TO postgres;
GRANT SELECT ON TABLE v_anagrafica_igro TO webgis_r;


--
-- TOC entry 5198 (class 0 OID 0)
-- Dependencies: 287
-- Name: v_anagrafica_nivo; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_nivo FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_nivo FROM postgres;
GRANT ALL ON TABLE v_anagrafica_nivo TO postgres;
GRANT SELECT ON TABLE v_anagrafica_nivo TO webgis_r;


--
-- TOC entry 5200 (class 0 OID 0)
-- Dependencies: 284
-- Name: v_anagrafica_pluvio; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_pluvio FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_pluvio FROM postgres;
GRANT ALL ON TABLE v_anagrafica_pluvio TO postgres;
GRANT SELECT ON TABLE v_anagrafica_pluvio TO webgis_r;


--
-- TOC entry 5202 (class 0 OID 0)
-- Dependencies: 283
-- Name: v_anagrafica_soglie_idro; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_soglie_idro FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_soglie_idro FROM postgres;
GRANT ALL ON TABLE v_anagrafica_soglie_idro TO postgres;
GRANT SELECT ON TABLE v_anagrafica_soglie_idro TO webgis_r;


--
-- TOC entry 5204 (class 0 OID 0)
-- Dependencies: 288
-- Name: v_anagrafica_termo; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_anagrafica_termo FROM PUBLIC;
REVOKE ALL ON TABLE v_anagrafica_termo FROM postgres;
GRANT ALL ON TABLE v_anagrafica_termo TO postgres;
GRANT SELECT ON TABLE v_anagrafica_termo TO webgis_r;


--
-- TOC entry 5206 (class 0 OID 0)
-- Dependencies: 306
-- Name: v_portate_naturali_annuali; Type: ACL; Schema: dati_di_base; Owner: postgres
--

REVOKE ALL ON TABLE v_portate_naturali_annuali FROM PUBLIC;
REVOKE ALL ON TABLE v_portate_naturali_annuali FROM postgres;
GRANT ALL ON TABLE v_portate_naturali_annuali TO postgres;
GRANT SELECT ON TABLE v_portate_naturali_annuali TO webgis_r;


SET search_path = public, pg_catalog;

--
-- TOC entry 5207 (class 0 OID 0)
-- Dependencies: 182
-- Name: geography_columns; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE geography_columns FROM PUBLIC;
REVOKE ALL ON TABLE geography_columns FROM postgres;
GRANT ALL ON TABLE geography_columns TO postgres;
GRANT SELECT ON TABLE geography_columns TO PUBLIC;


--
-- TOC entry 5208 (class 0 OID 0)
-- Dependencies: 183
-- Name: geometry_columns; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE geometry_columns FROM PUBLIC;
REVOKE ALL ON TABLE geometry_columns FROM postgres;
GRANT ALL ON TABLE geometry_columns TO postgres;
GRANT SELECT ON TABLE geometry_columns TO PUBLIC;


--
-- TOC entry 5210 (class 0 OID 0)
-- Dependencies: 190
-- Name: raster_columns; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE raster_columns FROM PUBLIC;
REVOKE ALL ON TABLE raster_columns FROM postgres;
GRANT ALL ON TABLE raster_columns TO postgres;
GRANT SELECT ON TABLE raster_columns TO PUBLIC;


--
-- TOC entry 5211 (class 0 OID 0)
-- Dependencies: 191
-- Name: raster_overviews; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE raster_overviews FROM PUBLIC;
REVOKE ALL ON TABLE raster_overviews FROM postgres;
GRANT ALL ON TABLE raster_overviews TO postgres;
GRANT SELECT ON TABLE raster_overviews TO PUBLIC;


--
-- TOC entry 5212 (class 0 OID 0)
-- Dependencies: 180
-- Name: spatial_ref_sys; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE spatial_ref_sys FROM PUBLIC;
REVOKE ALL ON TABLE spatial_ref_sys FROM postgres;
GRANT ALL ON TABLE spatial_ref_sys TO postgres;
GRANT SELECT ON TABLE spatial_ref_sys TO PUBLIC;


SET search_path = realtime, pg_catalog;

--
-- TOC entry 5216 (class 0 OID 0)
-- Dependencies: 309
-- Name: anomalie; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE anomalie FROM PUBLIC;
REVOKE ALL ON TABLE anomalie FROM postgres;
GRANT ALL ON TABLE anomalie TO postgres;
GRANT SELECT ON TABLE anomalie TO webgis_r;
GRANT ALL ON TABLE anomalie TO radar_rw;


--
-- TOC entry 5218 (class 0 OID 0)
-- Dependencies: 231
-- Name: g_dbstorm_seq; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON SEQUENCE g_dbstorm_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE g_dbstorm_seq FROM postgres;
GRANT ALL ON SEQUENCE g_dbstorm_seq TO postgres;
GRANT SELECT ON SEQUENCE g_dbstorm_seq TO webgis_r;
GRANT ALL ON SEQUENCE g_dbstorm_seq TO radar_rw;


--
-- TOC entry 5223 (class 0 OID 0)
-- Dependencies: 310
-- Name: v_anomalie; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_anomalie FROM PUBLIC;
REVOKE ALL ON TABLE v_anomalie FROM postgres;
GRANT ALL ON TABLE v_anomalie TO postgres;
GRANT SELECT ON TABLE v_anomalie TO webgis_r;
GRANT ALL ON TABLE v_anomalie TO radar_rw;


--
-- TOC entry 5225 (class 0 OID 0)
-- Dependencies: 294
-- Name: v_last_altri_idro; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_altri_idro FROM PUBLIC;
REVOKE ALL ON TABLE v_last_altri_idro FROM postgres;
GRANT ALL ON TABLE v_last_altri_idro TO postgres;
GRANT SELECT ON TABLE v_last_altri_idro TO webgis_r;


--
-- TOC entry 5227 (class 0 OID 0)
-- Dependencies: 260
-- Name: v_last_idro; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_idro FROM PUBLIC;
REVOKE ALL ON TABLE v_last_idro FROM postgres;
GRANT ALL ON TABLE v_last_idro TO postgres;
GRANT SELECT ON TABLE v_last_idro TO webgis_r;


--
-- TOC entry 5229 (class 0 OID 0)
-- Dependencies: 292
-- Name: v_last_igro; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_igro FROM PUBLIC;
REVOKE ALL ON TABLE v_last_igro FROM postgres;
GRANT ALL ON TABLE v_last_igro TO postgres;
GRANT SELECT ON TABLE v_last_igro TO webgis_r;


--
-- TOC entry 5231 (class 0 OID 0)
-- Dependencies: 257
-- Name: v_last_nivo; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_nivo FROM PUBLIC;
REVOKE ALL ON TABLE v_last_nivo FROM postgres;
GRANT ALL ON TABLE v_last_nivo TO postgres;
GRANT SELECT ON TABLE v_last_nivo TO webgis_r;


--
-- TOC entry 5233 (class 0 OID 0)
-- Dependencies: 249
-- Name: v_last_pluvio; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio FROM postgres;
GRANT ALL ON TABLE v_last_pluvio TO postgres;
GRANT SELECT ON TABLE v_last_pluvio TO webgis_r;


--
-- TOC entry 5235 (class 0 OID 0)
-- Dependencies: 266
-- Name: v_last_pluvio12h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio12h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio12h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio12h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio12h TO webgis_r;


--
-- TOC entry 5237 (class 0 OID 0)
-- Dependencies: 265
-- Name: v_last_pluvio1h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio1h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio1h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio1h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio1h TO webgis_r;


--
-- TOC entry 5239 (class 0 OID 0)
-- Dependencies: 267
-- Name: v_last_pluvio24h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio24h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio24h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio24h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio24h TO webgis_r;


--
-- TOC entry 5241 (class 0 OID 0)
-- Dependencies: 262
-- Name: v_last_pluvio3h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio3h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio3h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio3h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio3h TO webgis_r;


--
-- TOC entry 5243 (class 0 OID 0)
-- Dependencies: 285
-- Name: v_last_pluvio48h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio48h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio48h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio48h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio48h TO webgis_r;


--
-- TOC entry 5245 (class 0 OID 0)
-- Dependencies: 263
-- Name: v_last_pluvio6h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio6h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio6h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio6h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio6h TO webgis_r;


--
-- TOC entry 5247 (class 0 OID 0)
-- Dependencies: 286
-- Name: v_last_pluvio72h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio72h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio72h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio72h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio72h TO webgis_r;


--
-- TOC entry 5249 (class 0 OID 0)
-- Dependencies: 264
-- Name: v_last_pluvio9h; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_pluvio9h FROM PUBLIC;
REVOKE ALL ON TABLE v_last_pluvio9h FROM postgres;
GRANT ALL ON TABLE v_last_pluvio9h TO postgres;
GRANT SELECT ON TABLE v_last_pluvio9h TO webgis_r;


--
-- TOC entry 5252 (class 0 OID 0)
-- Dependencies: 247
-- Name: v_last_terma; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_terma FROM PUBLIC;
REVOKE ALL ON TABLE v_last_terma FROM postgres;
GRANT ALL ON TABLE v_last_terma TO postgres;
GRANT SELECT ON TABLE v_last_terma TO webgis_r;


--
-- TOC entry 5254 (class 0 OID 0)
-- Dependencies: 258
-- Name: v_last_vento; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_last_vento FROM PUBLIC;
REVOKE ALL ON TABLE v_last_vento FROM postgres;
GRANT ALL ON TABLE v_last_vento TO postgres;
GRANT SELECT ON TABLE v_last_vento TO webgis_r;


--
-- TOC entry 5256 (class 0 OID 0)
-- Dependencies: 246
-- Name: v_meteo_real_time; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_meteo_real_time FROM PUBLIC;
REVOKE ALL ON TABLE v_meteo_real_time FROM postgres;
GRANT ALL ON TABLE v_meteo_real_time TO postgres;
GRANT SELECT ON TABLE v_meteo_real_time TO webgis_r;


--
-- TOC entry 5258 (class 0 OID 0)
-- Dependencies: 295
-- Name: v_meteo_tot_real_time; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE v_meteo_tot_real_time FROM PUBLIC;
REVOKE ALL ON TABLE v_meteo_tot_real_time FROM postgres;
GRANT ALL ON TABLE v_meteo_tot_real_time TO postgres;
GRANT SELECT ON TABLE v_meteo_tot_real_time TO webgis_r;


--
-- TOC entry 5260 (class 0 OID 0)
-- Dependencies: 232
-- Name: webgis_tickets; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON TABLE webgis_tickets FROM PUBLIC;
REVOKE ALL ON TABLE webgis_tickets FROM postgres;
GRANT ALL ON TABLE webgis_tickets TO postgres;
GRANT ALL ON TABLE webgis_tickets TO webgis_r;
GRANT ALL ON TABLE webgis_tickets TO radar_rw;


--
-- TOC entry 5262 (class 0 OID 0)
-- Dependencies: 233
-- Name: webgis_tickets_gid_seq; Type: ACL; Schema: realtime; Owner: postgres
--

REVOKE ALL ON SEQUENCE webgis_tickets_gid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE webgis_tickets_gid_seq FROM postgres;
GRANT ALL ON SEQUENCE webgis_tickets_gid_seq TO postgres;
GRANT ALL ON SEQUENCE webgis_tickets_gid_seq TO radar_rw;


SET search_path = warning, pg_catalog;

--
-- TOC entry 5266 (class 0 OID 0)
-- Dependencies: 234
-- Name: warning_area; Type: ACL; Schema: warning; Owner: postgres
--

REVOKE ALL ON TABLE warning_area FROM PUBLIC;
REVOKE ALL ON TABLE warning_area FROM postgres;
GRANT ALL ON TABLE warning_area TO postgres;
GRANT SELECT ON TABLE warning_area TO webgis_r;
GRANT ALL ON TABLE warning_area TO radar_rw;


--
-- TOC entry 5268 (class 0 OID 0)
-- Dependencies: 235
-- Name: warning_levels; Type: ACL; Schema: warning; Owner: postgres
--

REVOKE ALL ON TABLE warning_levels FROM PUBLIC;
REVOKE ALL ON TABLE warning_levels FROM postgres;
GRANT ALL ON TABLE warning_levels TO postgres;
GRANT SELECT ON TABLE warning_levels TO webgis_r;
GRANT ALL ON TABLE warning_levels TO radar_rw;


--
-- TOC entry 5270 (class 0 OID 0)
-- Dependencies: 236
-- Name: warning_users; Type: ACL; Schema: warning; Owner: postgres
--

REVOKE ALL ON TABLE warning_users FROM PUBLIC;
REVOKE ALL ON TABLE warning_users FROM postgres;
GRANT ALL ON TABLE warning_users TO postgres;
GRANT SELECT ON TABLE warning_users TO webgis_r;
GRANT ALL ON TABLE warning_users TO radar_rw;


--
-- TOC entry 5271 (class 0 OID 0)
-- Dependencies: 237
-- Name: v_active_warnings; Type: ACL; Schema: warning; Owner: postgres
--

REVOKE ALL ON TABLE v_active_warnings FROM PUBLIC;
REVOKE ALL ON TABLE v_active_warnings FROM postgres;
GRANT ALL ON TABLE v_active_warnings TO postgres;
GRANT SELECT ON TABLE v_active_warnings TO webgis_r;
GRANT ALL ON TABLE v_active_warnings TO radar_rw;


--
-- TOC entry 5273 (class 0 OID 0)
-- Dependencies: 238
-- Name: warning_issued; Type: ACL; Schema: warning; Owner: postgres
--

REVOKE ALL ON TABLE warning_issued FROM PUBLIC;
REVOKE ALL ON TABLE warning_issued FROM postgres;
GRANT ALL ON TABLE warning_issued TO postgres;
GRANT SELECT ON TABLE warning_issued TO webgis_r;
GRANT ALL ON TABLE warning_issued TO radar_rw;
GRANT ALL ON TABLE warning_issued TO webgis;


-- Completed on 2018-02-28 12:17:16

--
-- PostgreSQL database dump complete
--

